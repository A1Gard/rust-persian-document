# خطاهای غیرقابل بازیابی با `panic!`

گاهی اوقات در کد شما اتفاقات بدی رخ می‌دهد و هیچ کاری نمی‌توانید برای آن انجام دهید. در چنین مواردی، زبان برنامه‌نویسی **Rust** ماکروی `panic!` را ارائه می‌دهد. دو راه برای ایجاد یک **panic** در عمل وجود دارد:

1. انجام عملی که باعث **panic** شدن کد می‌شود (مثل دسترسی به یک آرایه فراتر از انتهای آن).
2. فراخوانی صریح ماکروی `panic!`.

در هر دو حالت، برنامه شما دچار **panic** می‌شود. به‌طور پیش‌فرض، این **panic**ها یک پیام خطا چاپ می‌کنند، پشته (stack) را بازمی‌گردانند، داده‌ها را پاکسازی می‌کنند و برنامه را خاتمه می‌دهند. با استفاده از یک متغیر محیطی، می‌توانید کاری کنید که **Rust** هنگام وقوع **panic**، پشته فراخوانی (call stack) را نمایش دهد تا ردیابی منبع **panic** آسان‌تر شود.

> **توجه**: **panic** در **Rust** به معنای توقف ناگهانی برنامه به دلیل یک خطای غیرقابل بازیابی است. این مکانیزم برای شرایطی طراحی شده که ادامه اجرای برنامه منطقی یا امن نیست.

## بازگرداندن پشته یا توقف فوری در پاسخ به **panic**

به‌طور پیش‌فرض، وقتی یک **panic** رخ می‌دهد، برنامه شروع به **بازگرداندن پشته (unwinding)** می‌کند. این یعنی **Rust** به سمت بالا در پشته حرکت کرده و داده‌های هر تابع را که با آن مواجه می‌شود پاکسازی می‌کند. اما این فرآیند بازگرداندن و پاکسازی کار زیادی می‌طلبد. به همین دلیل، **Rust** به شما اجازه می‌دهد که به‌جای آن، گزینه **توقف فوری (aborting)** را انتخاب کنید که برنامه را بدون پاکسازی خاتمه می‌دهد.

در این حالت، حافظه‌ای که برنامه استفاده می‌کرد باید توسط سیستم‌عامل پاکسازی شود. اگر در پروژه‌تان نیاز دارید که فایل باینری نهایی تا حد ممکن کوچک باشد، می‌توانید با افزودن `panic = 'abort'` به بخش‌های مناسب `[profile]` در فایل `Cargo.toml`، از **بازگرداندن** به **توقف فوری** در هنگام **panic** سوئیچ کنید. برای مثال، اگر می‌خواهید در حالت **release** هنگام **panic** توقف فوری رخ دهد، این را اضافه کنید:

```toml
[profile.release]
panic = 'abort'
```

### آزمایش فراخوانی `panic!` در یک برنامه ساده

بیایید یک برنامه ساده را با فراخوانی `panic!` امتحان کنیم:

**فایل: src/main.rs**

```rust
// این کد باعث panic می‌شود!
fn main() {
    panic!("crash and burn");
}
```

وقتی این برنامه را اجرا کنید، چیزی شبیه به این خواهید دید:

```bash
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

فراخوانی `panic!` باعث ایجاد پیام خطایی می‌شود که در دو خط آخر خروجی نمایش داده شده است. خط اول پیام **panic** ما و مکان وقوع آن در کد منبع را نشان می‌دهد: `src/main.rs:2:5` به این معناست که این خط دوم، کاراکتر پنجم در فایل `src/main.rs` است.

در این مورد، خط مشخص‌شده بخشی از کد ماست و اگر به آن خط برویم، فراخوانی ماکروی `panic!` را می‌بینیم. اما در موارد دیگر، ممکن است فراخوانی `panic!` در کدی باشد که کد ما آن را فراخوانی کرده است. در این حالت، نام فایل و شماره خط گزارش‌شده توسط پیام خطا به کد شخص دیگری اشاره دارد که ماکروی `panic!` در آن فراخوانی شده، نه خطی از کد ما که در نهایت به این **panic** منجر شده است.

## استفاده از **Backtrace** برای ردیابی خطا

می‌توانیم از **backtrace** (ردیابی پشته) توابعی که منجر به فراخوانی `panic!` شده‌اند استفاده کنیم تا بخشی از کد خودمان را که باعث مشکل شده پیدا کنیم. برای درک نحوه استفاده از **backtrace** در **panic!**، بیایید یک مثال دیگر را بررسی کنیم و ببینیم وقتی فراخوانی `panic!` از یک کتابخانه به دلیل باگ در کد ما می‌آید، به چه شکل است، نه از فراخوانی مستقیم ماکرو توسط کد ما.

**فایل: src/main.rs**

```rust
// این کد باعث panic می‌شود!
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

**جدول 9-1**: تلاش برای دسترسی به عنصری فراتر از انتهای یک وکتور که باعث فراخوانی `panic!` می‌شود.

در اینجا، ما سعی می‌کنیم به صدمین عنصر وکتور (که در اندیس 99 قرار دارد چون اندیس‌گذاری از صفر شروع می‌شود) دسترسی پیدا کنیم، اما وکتور فقط سه عنصر دارد. در این موقعیت، **Rust** دچار **panic** می‌شود. استفاده از `[]` باید یک عنصر را برگرداند، اما اگر اندیس نامعتبری وارد کنید، هیچ عنصری وجود ندارد که **Rust** بتواند به‌درستی برگرداند.

> **توجه**: در زبان **C**، تلاش برای خواندن فراتر از انتهای یک ساختار داده رفتار تعریف‌نشده‌ای (undefined behavior) ایجاد می‌کند. ممکن است هر چیزی که در آن مکان حافظه قرار دارد را دریافت کنید، حتی اگر آن حافظه متعلق به آن ساختار نباشد. این مشکل به نام **buffer overread** شناخته می‌شود و می‌تواند به آسیب‌پذیری‌های امنیتی منجر شود اگر مهاجمی بتواند اندیس را دستکاری کند تا داده‌هایی را بخواند که نباید به آن‌ها دسترسی داشته باشد.

برای محافظت از برنامه در برابر این نوع آسیب‌پذیری، اگر سعی کنید به عنصری در اندیسی که وجود ندارد دسترسی پیدا کنید، **Rust** اجرای برنامه را متوقف کرده و ادامه نمی‌دهد. بیایید این را امتحان کنیم:

```bash
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

این خطا به خط 4 فایل `main.rs` اشاره دارد، جایی که ما سعی کردیم به اندیس 99 وکتور `v` دسترسی پیدا کنیم.

> **توجه**: خط `note:` به ما می‌گوید که می‌توانیم متغیر محیطی `RUST_BACKTRACE` را تنظیم کنیم تا یک **backtrace** دقیق از اتفاقاتی که باعث خطا شده دریافت کنیم. **Backtrace** لیستی از تمام توابعی است که تا رسیدن به این نقطه فراخوانی شده‌اند.

**Backtrace** در **Rust** مانند سایر زبان‌ها کار می‌کند: کلید خواندن **backtrace** این است که از بالا شروع کنید و بخوانید تا به فایل‌هایی برسید که خودتان نوشته‌اید. آن نقطه‌ای است که مشکل از آنجا شروع شده. خطوط بالای آن نقطه کدی هستند که کد شما فراخوانی کرده؛ خطوط پایین کدی هستند که کد شما را فراخوانی کرده‌اند. این خطوط ممکن است شامل کد هسته **Rust**، کتابخانه استاندارد یا کریت‌هایی (crates) باشند که استفاده می‌کنید.

بیایید با تنظیم متغیر محیطی `RUST_BACKTRACE` به هر مقداری غیر از 0، یک **backtrace** دریافت کنیم. خروجی شبیه به این خواهد بود:

```bash
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

**جدول 9-2**: **Backtrace** تولیدشده توسط فراخوانی `panic!` که با تنظیم متغیر محیطی `RUST_BACKTRACE` نمایش داده شده است.

این خروجی طولانی است! خروجی دقیق ممکن است بسته به سیستم‌عامل و نسخه **Rust** شما متفاوت باشد. برای دریافت **backtrace** با این اطلاعات، باید نمادهای دیباگ (debug symbols) فعال باشند. نمادهای دیباگ به‌طور پیش‌فرض هنگام استفاده از `cargo build` یا `cargo run` بدون پرچم `--release` فعال هستند، همان‌طور که در اینجا داریم.

در خروجی جدول 9-2، خط 6 از **backtrace** به خطی در پروژه ما اشاره دارد که مشکل را ایجاد کرده: خط 4 از `src/main.rs`. اگر نمی‌خواهیم برنامه‌مان **panic** کند، باید بررسی را از مکانی شروع کنیم که اولین خط اشاره به فایلی دارد که خودمان نوشته‌ایم. در جدول 9-1، جایی که عمداً کدی نوشتیم که **panic** کند، راه حل این **panic** این است که درخواست عنصری فراتر از محدوده اندیس‌های وکتور نکنیم.

وقتی در آینده کد شما **panic** کند، باید بفهمید که کد چه عملی را با چه مقادیری انجام می‌دهد که باعث **panic** شده و به‌جای آن کد باید چه کاری انجام دهد.

در بخش بعدی این فصل، به موضوع `panic!` و اینکه چه زمانی باید یا نباید از آن برای مدیریت شرایط خطا استفاده کنیم، در بخش “To panic! or Not to panic!” بازمی‌گردیم. در ادامه، به بررسی نحوه بازیابی از خطاها با استفاده از `Result` خواهیم پرداخت.
# کنار هم قرار دادن همه چیز: Futureها، وظایف، و رسیمان‌ها

همان‌طور که در فصل شانزدهم دیدیم، رسیمان‌ها (threads) یک رویکرد برای همزمانی ارائه می‌دهند. در این فصل، رویکرد دیگری را دیدیم: استفاده از `async` با Futureها و استریم‌ها. اگر فکر می‌کنید که چه زمانی باید یکی را به دیگری ترجیح داد، پاسخ این است: بستگی دارد! و در بسیاری از موارد، انتخاب بین رسیمان‌ها یا `async` نیست، بلکه رسیمان‌ها **و** `async` است.

بسیاری از سیستم‌عامل‌ها دهه‌هاست که مدل‌های همزمانی مبتنی بر رسیمان را ارائه می‌دهند، و به همین دلیل بسیاری از زبان‌های برنامه‌نویسی از آن‌ها پشتیبانی می‌کنند. با این حال، این مدل‌ها بدون معاوضه نیستند. در بسیاری از سیستم‌عامل‌ها، هررسیمان مقدار قابل‌توجهی حافظه مصرف می‌کند و برای راه‌اندازی و خاموش کردن آن‌ها سرباری وجود دارد. رسیمان‌ها همچنین تنها زمانی گزینه هستند که سیستم‌عامل و سخت‌افزار شما از آن‌ها پشتیبانی کنند. برخلاف کامپیوترهای رومیزی و موبایل‌های主流، برخی سیستم‌های نهفته اصلاً سیستم‌عامل ندارند، بنابراینرسیمان هم ندارند.

مدل `async` مجموعه‌ای متفاوت—و در نهایت مکمل—از معاوضه‌ها را ارائه می‌دهد. در مدل `async`، عملیات‌های همزمان نیازی به رسیمان‌های خودشان ندارند. در عوض، می‌توانند روی وظایف (tasks) اجرا شوند، همان‌طور که وقتی از `trpl::spawn_task` برای شروع کار از یک تابع همزمان در بخش استریم‌ها استفاده کردیم. یک وظیفه مشابه یکرسیمان است، اما به جای مدیریت توسط سیستم‌عامل، توسط کد سطح کتابخانه مدیریت می‌شود: زمان‌اجرا (runtime).

در بخش قبلی، دیدیم که می‌توانیم یک استریم را با استفاده از یک کانال غیرهمزمان و ایجاد یک وظیفه غیرهمزمان که می‌توانستیم از کد همزمان فراخوانی کنیم، بسازیم. دقیقاً همین کار را می‌توانیم با یک رسیمان انجام دهیم. در فهرست کد 17-40، از `trpl::spawn_task` و `trpl::sleep` استفاده کردیم. در فهرست کد 17-41، این‌ها را با APIهای `thread::spawn` و `thread::sleep` از کتابخانه استاندارد در تابع `get_intervals` جایگزین می‌کنیم.

**فایل: src/main.rs**

```rust
use std::{thread, time::Duration};
use trpl::{ReceiverStream, Stream};

fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    // این *نه* `trpl::spawn` بلکه `std::thread::spawn` است!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // به همین ترتیب، این *نه* `trpl::sleep` بلکه `std::thread::sleep` است!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("نمی‌توان بازه {count} را ارسال کرد: {send_error}"); // Could not send interval {count}: {send_error}
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}
```

**فهرست کد 17-41: استفاده از APIهای std::thread به جای APIهای غیرهمزمان trpl برای تابع get_intervals**

اگر این کد را اجرا کنید، خروجی آن مشابه خروجی فهرست کد 17-40 است. و توجه کنید که از دیدگاه کد فراخواننده چقدر تغییر کمی ایجاد می‌شود. علاوه بر این، حتی با اینکه یکی از توابع ما یک وظیفه غیرهمزمان روی زمان‌اجرا ایجاد کرد و دیگری یک رسیمان سیستم‌عامل ایجاد کرد، استریم‌های حاصل از این تفاوت‌ها تحت تأثیر قرار نگرفتند.

با وجود شباهت‌هایشان، این دو رویکرد بسیار متفاوت عمل می‌کنند، اگرچه ممکن است در این مثال بسیار ساده سنجش آن دشوار باشد. ما می‌توانستیم میلیون‌ها وظیفه غیرهمزمان را روی هر کامپیوتر شخصی مدرن ایجاد کنیم. اگر سعی کنیم این کار را با رسیمان‌ها انجام دهیم، به معنای واقعی کلمه حافظه تمام می‌شود!

با این حال، دلیلی وجود دارد که این APIها اینقدر شبیه هستند. رسیمان‌ها به‌عنوان مرزی برای مجموعه‌های عملیات همزمان عمل می‌کنند؛ همزمانی بین رسیمان‌ها ممکن است. وظایف به‌عنوان مرزی برای مجموعه‌های عملیات غیرهمزمان عمل می‌کنند؛ همزمانی هم بین وظایف و هم درون وظایف ممکن است، زیرا یک وظیفه می‌تواند بین Futureها در بدنه خود جابه‌جا شود. در نهایت، Futureها کوچک‌ترین واحد همزمانی در Rust هستند، و هر Future ممکن است درختی از Futureهای دیگر را نشان دهد. زمان‌اجرا—به‌ویژه اجراکننده (executor) آن—وظایف را مدیریت می‌کند، و وظایف Futureها را مدیریت می‌کنند. در این زمینه، وظایف شبیه رسیمان‌های سبک‌وزن مدیریت‌شده توسط زمان‌اجرا هستند با قابلیت‌های اضافی که از مدیریت توسط زمان‌اجرا به جای سیستم‌عامل ناشی می‌شود.

این به این معنا نیست که وظایف غیرهمزمان همیشه بهتر از رسیمان‌ها هستند (یا برعکس). همزمانی با رسیمان‌ها در برخی جهات مدل برنامه‌نویسی ساده‌تری نسبت به همزمانی با `async` است. این می‌تواند یک نقطه قوت یا ضعف باشد. رسیمان‌ها تا حدی «شلیک کن و فراموش کن» هستند؛ آن‌ها معادل ذاتی یک Future ندارند، بنابراین به‌سادگی تا تکمیل شدن اجرا می‌شوند بدون اینکه جز توسط خود سیستم‌عامل قطع شوند. یعنی، آن‌ها هیچ پشتیبانی داخلی برای همزمانی درون‌وظیفه‌ای به روشی که Futureها دارند، ندارند. رسیمان‌ها در Rust همچنین هیچ مکانیزمی برای لغو ندارند—موضوعی که در این فصل به‌طور صریح پوشش ندادیم اما به‌طور ضمنی با این واقعیت که هر زمان یک Future را پایان دادیم، حالت آن به‌درستی پاکسازی شد، اشاره شد.

این محدودیت‌ها همچنین ترکیب رسیمان‌ها را دشوارتر از Futureها می‌کند. برای مثال، استفاده از رسیمان‌ها برای ساخت دستیارهایی مانند متدهای `timeout` و `throttle` که قبلاً در این فصل ساختیم، بسیار دشوارتر است. این واقعیت که Futureها ساختارهای داده غنی‌تری هستند به این معناست که می‌توانند به‌طور طبیعی‌تر با هم ترکیب شوند، همان‌طور که دیدیم.

وظایف، در نتیجه، کنترل بیشتری روی Futureها به ما می‌دهند، و به ما اجازه می‌دهند انتخاب کنیم که کجا و چگونه آن‌ها را گروه‌بندی کنیم. و مشخص می‌شود که رسیمان‌ها و وظایف اغلب خیلی خوب با هم کار می‌کنند، زیرا وظایف می‌توانند (حداقل در برخی زمان‌اجراها) بین رسیمان‌ها جابه‌جا شوند. در واقع، در پشت صحنه، زمان‌اجرایی که ما استفاده کردیم—از جمله توابع `spawn_blocking` و `spawn_task`—به‌طور پیش‌فرض چندرسیمانی است! بسیاری از زمان‌اجراها از رویکردی به نام **دزدی کار** (work stealing) استفاده می‌کنند تا وظایف را به‌طور شفاف بین رسیمان‌ها جابه‌جا کنند، بر اساس اینکه رسیمان‌ها در حال حاضر چگونه استفاده می‌شوند، تا عملکرد کلی سیستم را بهبود دهند. این رویکرد در واقع به رسیمان‌ها و وظایف، و بنابراین Futureها، نیاز دارد.

وقتی فکر می‌کنید که از کدام روش چه زمانی استفاده کنید، این قوانین سرانگشتی را در نظر بگیرید:

- اگر کار بسیار موازی‌پذیر باشد، مانند پردازش مجموعه‌ای از داده‌ها که هر بخش می‌تواند به‌صورت جداگانه پردازش شود، رسیمان‌ها انتخاب بهتری هستند.
- اگر کار بسیار همزمان باشد، مانند مدیریت پیام‌ها از منابع مختلف که ممکن است در فواصل یا نرخ‌های مختلف وارد شوند، `async` انتخاب بهتری است.
- و اگر به هر دو موازی‌سازی و همزمانی نیاز دارید، نیازی به انتخاب بین رسیمان‌ها و `async` ندارید. می‌توانید آزادانه از آن‌ها با هم استفاده کنید، و اجازه دهید هر کدام نقشی را که در آن بهترین است ایفا کنند.

برای مثال، فهرست کد 17-42 یک نمونه نسبتاً رایج از این نوع ترکیب در کد واقعی Rust را نشان می‌دهد.

**فایل: src/main.rs**

```rust
use std::{thread, time::Duration};
use trpl::StreamExt;

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}
```

**فهرست کد 17-42: ارسال پیام‌ها با کد مسدودکننده در یکرسیمان و انتظار پیام‌ها در یک بلوک غیرهمزمان**

ما با ایجاد یک کانال غیرهمزمان شروع می‌کنیم، سپس یکرسیمان ایجاد می‌کنیم که مالکیت سمت فرستنده کانال را می‌گیرد. درون نخ، اعداد 1 تا 10 را ارسال می‌کنیم، بین هر کدام یک ثانیه می‌خوابیم. در نهایت، یک Future ایجادشده با یک بلوک `async` را که به `trpl::run` پاس داده شده، همان‌طور که در طول فصل انجام دادیم، اجرا می‌کنیم. در آن Future، آن پیام‌ها را انتظار می‌کنیم، درست مثل سایر نمونه‌های پیام‌رسانی که دیدیم.

برای بازگشت به سناریویی که در ابتدای فصل مطرح کردیم، تصور کنید مجموعه‌ای از وظایف رمزگذاری ویدئو را با استفاده از یکرسیمان اختصاصی اجرا می‌کنید (زیرا رمزگذاری ویدئو محاسباتی است) اما رابط کاربری را با یک کانال غیرهمزمان از اتمام آن عملیات‌ها مطلع می‌کنید. نمونه‌های بی‌شماری از این نوع ترکیب‌ها در موارد استفاده واقعی وجود دارد.

## خلاصه

این آخرین باری نیست که در این کتاب همزمانی را خواهید دید. پروژه در فصل بیست و یکم این مفاهیم را در موقعیت واقعی‌تری نسبت به نمونه‌های ساده‌تر بحث‌شده اینجا اعمال خواهد کرد و حل مسئله با رسیمان‌ها در مقابل وظایف را به‌طور مستقیم‌تر مقایسه خواهد کرد.

صرف‌نظر از اینکه کدام‌یک از این رویکردها را انتخاب کنید، Rust ابزارهایی را که برای نوشتن کد همزمان ایمن و سریع نیاز دارید—چه برای یک سرور وب با توان بالا یا یک سیستم‌عامل نهفته—در اختیارتان قرار می‌دهد.

در ادامه، درباره روش‌های اصولی مدل‌سازی مسائل و ساختاردهی راه‌حل‌ها صحبت خواهیم کرد وقتی برنامه‌های Rust شما بزرگ‌تر می‌شوند. علاوه بر این، بحث خواهیم کرد که چگونه اصول Rust به آن‌هایی که ممکن است از برنامه‌نویسی شیءگرا با آن‌ها آشنا باشید مرتبط می‌شوند.
# پیوست CS: صفات قابل اشتقاق

در بخش‌های مختلف کتاب، درباره ویژگی `derive` بحث کرده‌ایم که می‌توانید آن را روی تعریف یک ساختار یا شمارش اعمال کنید. ویژگی `derive` کدی تولید می‌کند که یک ویژگی‌ را با پیاده‌سازی پیش‌فرض خود روی نوعی که با نحو `derive` حاشیه‌نویسی کرده‌اید پیاده‌سازی می‌کند.

در این پیوست، مرجعی از تمام صفات موجود در کتابخانه استاندارد که می‌توانید با `derive` استفاده کنید ارائه می‌دهیم. هر بخش شامل موارد زیر است:

- چه عملگرها و متدهایی با اشتقاق این ویژگی‌ فعال می‌شوند
- پیاده‌سازی ویژگی‌ی که توسط `derive` ارائه شده چه کاری انجام می‌دهد
- پیاده‌سازی ویژگی‌ چه چیزی درباره نوع نشان می‌دهد
- شرایطی که در آن‌ها مجاز به پیاده‌سازی ویژگی‌ هستید یا نیستید
- نمونه‌هایی از عملیات‌هایی که به ویژگی‌ نیاز دارند

اگر بخواهید رفتاری متفاوت از آنچه توسط ویژگی `derive` ارائه شده داشته باشید، برای جزئیات درباره نحوه پیاده‌سازی دستی آن‌ها، مستندات کتابخانه استاندارد را برای هر ویژگی‌ بررسی کنید.

صفات ذکر شده در اینجا تنها صفاتی هستند که توسط کتابخانه استاندارد تعریف شده‌اند و می‌توانند با استفاده از `derive` روی انواع شما پیاده‌سازی شوند. سایر صفات تعریف‌شده در کتابخانه استاندارد رفتار پیش‌فرض معقولی ندارند، بنابراین این به شما بستگی دارد که آن‌ها را به روشی که برای آنچه می‌خواهید انجام دهید منطقی است پیاده‌سازی کنید.

یک نمونه از ویژگی‌ی که نمی‌توان آن را اشتقاق کرد، `Display` است که قالب‌بندی برای کاربران نهایی را مدیریت می‌کند. شما همیشه باید روش مناسب برای نمایش یک نوع به کاربر نهایی را در نظر بگیرید. چه بخش‌هایی از نوع باید برای کاربر نهایی قابل مشاهده باشد؟ کدام بخش‌ها برای آن‌ها مرتبط خواهند بود؟ چه فرمتی از داده‌ها برای آن‌ها بیشترین اهمیت را خواهد داشت؟ کامپایلر Rust این بینش را ندارد، بنابراین نمی‌تواند رفتار پیش‌فرض مناسبی برای شما فراهم کند.

لیست صفات قابل اشتقاق ارائه‌شده در این پیوست جامع نیست: کتابخانه‌ها می‌توانند `derive` را برای صفات خودشان پیاده‌سازی کنند، که باعث می‌شود لیست صفاتی که می‌توانید با `derive` استفاده کنید واقعاً باز باشد. پیاده‌سازی `derive` شامل استفاده از یک ماکرو رویه‌ای است که در بخش «ماکروها» در فصل بیستم پوشش داده شده است.

## Debug برای خروجی برنامه‌نویس

ویژگی‌ `Debug` امکان قالب‌بندی اشکال‌زدایی را در رشته‌های قالب فراهم می‌کند، که با افزودن `:؟` در داخل جایگاه‌های `{}` مشخص می‌کنید.

ویژگی‌ `Debug` به شما امکان می‌دهد نمونه‌های یک نوع را برای اهداف اشکال‌زدایی چاپ کنید، تا شما و سایر برنامه‌نویسان که از نوع شما استفاده می‌کنند بتوانند یک نمونه را در نقطه خاصی از اجرای برنامه بررسی کنند.

ویژگی‌ `Debug` برای مثال در استفاده از ماکرو `assert_eq!` مورد نیاز است. این ماکرو مقادیر نمونه‌های داده‌شده به‌عنوان آرگومان‌ها را در صورت شکست ادعای برابری چاپ می‌کند تا برنامه‌نویسان بتوانند ببینند چرا دو نمونه برابر نبودند.

## PartialEq و Eq برای مقایسه‌های برابری

ویژگی‌ `PartialEq` به شما امکان می‌دهد نمونه‌های یک نوع را برای بررسی برابری مقایسه کنید و استفاده از عملگرهای `==` و `!=` را فعال می‌کند.

اشتقاق `PartialEq` متد `eq` را پیاده‌سازی می‌کند. وقتی `PartialEq` روی ساختارها اشتقاق می‌شود، دو نمونه تنها در صورتی برابر هستند که تمام فیلدها برابر باشند، و اگر هر یک از فیلدها برابر نباشد، نمونه‌ها برابر نیستند. وقتی روی شمارش‌ها اشتقاق می‌شود، هر گونه برابر با خودش است و با گونه‌های دیگر برابر نیست.

ویژگی‌ `PartialEq` برای مثال با استفاده از ماکرو `assert_eq!` مورد نیاز است، که باید بتواند دو نمونه از یک نوع را برای برابری مقایسه کند.

ویژگی‌ `Eq` هیچ متدی ندارد. هدف آن این است که نشان دهد برای هر مقدار از نوع حاشیه‌نویسی‌شده، مقدار با خودش برابر است. ویژگی‌ `Eq` تنها می‌تواند روی انواعی اعمال شود که `PartialEq` را نیز پیاده‌سازی کرده‌اند، اگرچه همه انواع پیاده‌سازی‌کننده `PartialEq` نمی‌توانند `Eq` را پیاده‌سازی کنند. یک نمونه از این مورد انواع اعداد ممیز شناور است: پیاده‌سازی اعداد ممیز شناور بیان می‌کند که دو نمونه از مقدار غیرعدد (NaN) با یکدیگر برابر نیستند.

یک نمونه از زمانی که `Eq` مورد نیاز است، برای کلیدها در یک `HashMap<K, V>` است تا `HashMap<K, V>` بتواند تشخیص دهد که آیا دو کلید یکسان هستند یا خیر.

## PartialOrd و Ord برای مقایسه‌های ترتیب

ویژگی‌ `PartialOrd` به شما امکان می‌دهد نمونه‌های یک نوع را برای اهداف مرتب‌سازی مقایسه کنید. نوعی که `PartialOrd` را پیاده‌سازی می‌کند می‌تواند با عملگرهای `<`، `>`، `<=`، و `>=` استفاده شود. شما تنها می‌توانید ویژگی‌ `PartialOrd` را روی انواعی اعمال کنید که `PartialEq` را نیز پیاده‌سازی کرده‌اند.

اشتقاق `PartialOrd` متد `partial_cmp` را پیاده‌سازی می‌کند، که یک `Option<Ordering>` برمی‌گرداند که وقتی مقادیر داده‌شده ترتیبی تولید نکنند، `None` خواهد بود. یک نمونه از مقداری که ترتیبی تولید نمی‌کند، حتی اگر بیشتر مقادیر آن نوع قابل مقایسه باشند، مقدار ممیز شناور غیرعدد (NaN) است. فراخوانی `partial_cmp` با هر عدد ممیز شناور و مقدار ممیز شناور NaN، `None` را برمی‌گرداند.

وقتی روی ساختارها اشتقاق می‌شود، `PartialOrd` دو نمونه را با مقایسه مقدار هر فیلد به ترتیبی که فیلدها در تعریف ساختار ظاهر می‌شوند مقایسه می‌کند. وقتی روی شمارش‌ها اشتقاق می‌شود، گونه‌های شمارش که زودتر در تعریف شمارش اعلام شده‌اند کمتر از گونه‌های بعدی در نظر گرفته می‌شوند.

ویژگی‌ `PartialOrd` برای مثال برای متد `gen_range` از crate `rand` که یک مقدار تصادفی در محدوده مشخص‌شده توسط یک عبارت محدوده تولید می‌کند، مورد نیاز است.

ویژگی‌ `Ord` به شما امکان می‌دهد بدانید که برای هر دو مقدار از نوع حاشیه‌نویسی‌شده، یک ترتیب معتبر وجود خواهد داشت. ویژگی‌ `Ord` متد `cmp` را پیاده‌سازی می‌کند، که یک `Ordering` به‌جای `Option<Ordering>` برمی‌گرداند زیرا همیشه یک ترتیب معتبر ممکن است. شما تنها می‌توانید ویژگی‌ `Ord` را روی انواعی اعمال کنید که `PartialOrd` و `Eq` را نیز پیاده‌سازی کرده‌اند (و `Eq` به `PartialEq` نیاز دارد). وقتی روی ساختارها و شمارش‌ها اشتقاق می‌شود، `cmp` همان‌طور که پیاده‌سازی اشتقاق‌شده برای `partial_cmp` با `PartialOrd` رفتار می‌کند، عمل می‌کند.

یک نمونه از زمانی که `Ord` مورد نیاز است، هنگام ذخیره مقادیر در یک `BTreeSet<T>` است، یک ساختار داده که داده‌ها را بر اساس ترتیب مرتب‌سازی مقادیر ذخیره می‌کند.

## Clone و Copy برای تکثیر مقادیر

ویژگی‌ `Clone` به شما امکان می‌دهد یک کپی عمیق از یک مقدار را به‌صراحت ایجاد کنید، و فرآیند تکثیر ممکن است شامل اجرای کد دلخواه و کپی داده‌های هیپ باشد. برای اطلاعات بیشتر درباره `Clone` به بخش «متغیرها و تعامل داده‌ها با Clone» در فصل چهارم مراجعه کنید.

اشتقاق `Clone` متد `clone` را پیاده‌سازی می‌کند، که وقتی برای کل نوع پیاده‌سازی می‌شود، روی هر یک از بخش‌های نوع `clone` را فراخوانی می‌کند. این به این معناست که تمام فیلدها یا مقادیر در نوع باید `Clone` را نیز پیاده‌سازی کنند تا بتوان `Clone` را اشتقاق کرد.

یک نمونه از زمانی که `Clone` مورد نیاز است، هنگام فراخوانی متد `to_vec` روی یک برش است. برش مالک نمونه‌های نوعی که شامل آن است نیست، اما بردار بازگشتی از `to_vec` باید مالک نمونه‌های خود باشد، بنابراین `to_vec` روی هر آیتم `clone` را فراخوانی می‌کند. بنابراین نوع ذخیره‌شده در برش باید `Clone` را پیاده‌سازی کند.

ویژگی‌ `Copy` به شما امکان می‌دهد یک مقدار را فقط با کپی کردن بیت‌های ذخیره‌شده در پشته تکثیر کنید؛ هیچ کد دلخواهی لازم نیست. برای اطلاعات بیشتر درباره `Copy` به بخش «داده‌های فقط پشته: Copy» در فصل چهارم مراجعه کنید.

ویژگی‌ `Copy` هیچ متدی تعریف نمی‌کند تا از بازنویسی آن متدها توسط برنامه‌نویسان و نقض فرضیه عدم اجرای کد دلخواه جلوگیری کند. به این ترتیب، همه برنامه‌نویسان می‌توانند فرض کنند که کپی کردن یک مقدار بسیار سریع خواهد بود.

شما می‌توانید `Copy` را روی هر نوعی که تمام بخش‌های آن `Copy` را پیاده‌سازی کرده‌اند اشتقاق کنید. نوعی که `Copy` را پیاده‌سازی می‌کند باید `Clone` را نیز پیاده‌سازی کند، زیرا نوعی که `Copy` را پیاده‌سازی می‌کند یک پیاده‌سازی پیش‌پاافتاده از `Clone` دارد که همان وظیفه `Copy` را انجام می‌دهد.

ویژگی‌ `Copy` به‌ندرت مورد نیاز است؛ انواعی که `Copy` را پیاده‌سازی می‌کنند بهینه‌سازی‌هایی در دسترس دارند، به این معنا که نیازی به فراخوانی `clone` ندارید، که کد را مختصرتر می‌کند.

هر چیزی که با `Copy` ممکن است با `Clone` نیز قابل دستیابی است، اما کد ممکن است کندتر باشد یا مجبور به استفاده از `clone` در جاهایی باشد.

## Hash برای نگاشت یک مقدار به مقداری با اندازه ثابت

ویژگی‌ `Hash` به شما امکان می‌دهد یک نمونه از نوعی با اندازه دلخواه را بگیرید و آن نمونه را با استفاده از یک تابع هش به مقداری با اندازه ثابت نگاشت کنید. اشتقاق `Hash` متد `hash` را پیاده‌سازی می‌کند. پیاده‌سازی اشتقاق‌شده متد `hash` نتیجه فراخوانی `hash` روی هر یک از بخش‌های نوع را ترکیب می‌کند، به این معنا که تمام فیلدها یا مقادیر باید `Hash` را نیز پیاده‌سازی کنند تا بتوان `Hash` را اشتقاق کرد.

یک نمونه از زمانی که `Hash` مورد نیاز است، در ذخیره کلیدها در یک `HashMap<K, V>` برای ذخیره داده‌ها به‌صورت کارآمد است.

## Default برای مقادیر پیش‌فرض

ویژگی‌ `Default` به شما امکان می‌دهد یک مقدار پیش‌فرض برای یک نوع ایجاد کنید. اشتقاق `Default` تابع `default` را پیاده‌سازی می‌کند. پیاده‌سازی اشتقاق‌شده تابع `default` روی هر بخش از نوع تابع `default` را فراخوانی می‌کند، به این معنا که تمام فیلدها یا مقادیر در نوع باید `Default` را نیز پیاده‌سازی کنند تا بتوان `Default` را اشتقاق کرد.

تابع `Default::default` معمولاً در ترکیب با نحو به‌روزرسانی ساختار که در بخش «ایجاد نمونه‌ها از نمونه‌های دیگر با نحو به‌روزرسانی ساختار» در فصل پنجم بحث شده استفاده می‌شود. می‌توانید چند فیلد از یک ساختار را سفارشی کنید و سپس با استفاده از `..Default::default()` مقدار پیش‌فرض را برای بقیه فیلدها تنظیم و استفاده کنید.

ویژگی‌ `Default` برای مثال وقتی از متد `unwrap_or_default` روی نمونه‌های `Option<T>` استفاده می‌کنید مورد نیاز است. اگر `Option<T>` برابر `None` باشد، متد `unwrap_or_default` نتیجه `Default::default` را برای نوع `T` ذخیره‌شده در `Option<T>` برمی‌گرداند.
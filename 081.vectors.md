
## ذخیره لیست‌های مقادیر با وکتورها

اولین نوع مجموعه‌ای که بررسی خواهیم کرد، `Vec<T>` است که به نام **وکتور** نیز شناخته می‌شود. وکتورها به شما امکان می‌دهند بیش از یک مقدار را در یک ساختار داده‌ای واحد ذخیره کنید که همه مقادیر را کنار یکدیگر در حافظه قرار می‌دهد. وکتورها فقط می‌توانند مقادیر از یک نوع یکسان را ذخیره کنند. آن‌ها زمانی مفید هستند که لیستی از موارد دارید، مانند خطوط متن در یک فایل یا قیمت‌های اقلام در سبد خرید.

### ایجاد یک وکتور جدید

برای ایجاد یک وکتور خالی جدید، از تابع `Vec::new` استفاده می‌کنیم، همان‌طور که در لیست ۸-۱ نشان داده شده است.

```rust
let v: Vec<i32> = Vec::new();
```

**لیست ۸-۱:** ایجاد یک وکتور خالی جدید برای نگه‌داری مقادیر از نوع `i32`

توجه کنید که اینجا یک حاشیه‌نویسی نوع اضافه کردیم. چون هیچ مقداری در این وکتور وارد نکرده‌ایم، Rust نمی‌داند چه نوع عناصری قصد داریم ذخیره کنیم. این نکته مهمی است. وکتورها با استفاده از Generic‌ها پیاده‌سازی شده‌اند؛ در فصل دهم نحوه استفاده از Generic‌ها با انواع خودتان را پوشش خواهیم داد. برای حالا، بدانید که نوع `Vec<T>` ارائه‌شده توسط کتابخانه استاندارد می‌تواند هر نوع را نگه دارد. وقتی وکتوری برای نگه‌داری یک نوع خاص ایجاد می‌کنیم، می‌توانیم نوع را درون کروشه‌های زاویه‌دار مشخص کنیم. در لیست ۸-۱، به Rust گفته‌ایم که `Vec<T>` در `v` عناصری از نوع `i32` را نگه خواهد داشت.

اغلب اوقات، یک `Vec<T>` را با مقادیر اولیه ایجاد می‌کنید و Rust نوع مقداری که می‌خواهید ذخیره کنید را استنباط می‌کند، بنابراین به‌ندرت نیاز به حاشیه‌نویسی نوع دارید. Rust به‌طور مناسب ماکروی `vec!` را ارائه می‌دهد که یک وکتور جدید ایجاد می‌کند و مقادیری که به آن می‌دهید را نگه می‌دارد. لیست ۸-۲ یک `Vec<i32>` جدید ایجاد می‌کند که مقادیر ۱، ۲، و ۳ را نگه می‌دارد. نوع عدد صحیح `i32` است، زیرا این نوع عدد صحیح پیش‌فرض است، همان‌طور که در بخش «انواع داده» در فصل سوم بحث کردیم.

```rust
let v = vec![1, 2, 3];
```

**لیست ۸-۲:** ایجاد یک وکتور جدید حاوی مقادیر

چون مقادیر اولیه `i32` داده‌ایم، Rust می‌تواند استنباط کند که نوع `v` برابر `Vec<i32>` است، و حاشیه‌نویسی نوع لازم نیست. حالا بیایید ببینیم چگونه یک وکتور را به‌روزرسانی کنیم.

### به‌روزرسانی یک وکتور

برای ایجاد یک وکتور و سپس افزودن عناصر به آن، می‌توانیم از متد `push` استفاده کنیم، همان‌طور که در لیست ۸-۳ نشان داده شده است.

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

**لیست ۸-۳:** استفاده از متد `push` برای افزودن مقادیر به یک وکتور

مانند هر متغیر دیگری، اگر بخواهیم بتوانیم مقدار آن را تغییر دهیم، باید آن را با کلمه‌کلیدی `mut` قابل‌تغییر کنیم، همان‌طور که در فصل سوم بحث کردیم. اعدادی که داخل آن قرار می‌دهیم همگی از نوع `i32` هستند، و Rust این را از داده‌ها استنباط می‌کند، بنابراین نیازی به حاشیه‌نویسی `Vec<i32>` نداریم.

### خواندن عناصر وکتورها

دو روش برای ارجاع به مقداری که در یک وکتور ذخیره شده وجود دارد: از طریق اندیس‌گذاری یا با استفاده از متد `get`. در مثال‌های زیر، نوع مقادیری که از این توابع برگردانده می‌شوند را برای وضوح بیشتر حاشیه‌نویسی کرده‌ایم.

لیست ۸-۴ هر دو روش دسترسی به یک مقدار در وکتور را، با نحو اندیس‌گذاری و متد `get`، نشان می‌دهد.

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("عنصر سوم {third} است");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("عنصر سوم {third} است"),
    None => println!("عنصر سومی وجود ندارد."),
}
```

**لیست ۸-۴:** استفاده از نحو اندیس‌گذاری و متد `get` برای دسترسی به یک مورد در وکتور

چند جزئیات را اینجا توجه کنید. ما از مقدار اندیس ۲ برای گرفتن عنصر سوم استفاده می‌کنیم، زیرا وکتورها با شماره اندیس‌گذاری می‌شوند و از صفر شروع می‌کنند. استفاده از `&` و `[]` یک ارجاع به عنصر در مقدار اندیس به ما می‌دهد. وقتی از متد `get` با اندیس به‌عنوان آرگومان استفاده می‌کنیم، یک `Option<&T>` دریافت می‌کنیم که می‌توانیم با `match` از آن استفاده کنیم.

Rust این دو روش را برای ارجاع به یک عنصر ارائه می‌دهد تا بتوانید انتخاب کنید که وقتی سعی می‌کنید از مقدار اندیسی خارج از محدوده عناصر موجود استفاده کنید، برنامه چگونه رفتار کند. به‌عنوان مثال، بیایید ببینیم وقتی یک وکتور با پنج عنصر داریم و سپس سعی می‌کنیم به عنصر در اندیس ۱۰۰ با هر تکنیک دسترسی پیدا کنیم، چه اتفاقی می‌افتد، همان‌طور که در لیست ۸-۵ نشان داده شده است.

<div class="err"> <img src="img/panics.svg" > <span> این کد پنیک می‌کند! </span> </div>

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

**لیست ۸-۵:** تلاش برای دسترسی به عنصر در اندیس ۱۰۰ در وکتوری با پنج عنصر

وقتی این کد را اجرا کنیم، روش اول `[]` باعث می‌شود برنامه پنیک کند، زیرا به یک عنصر ناموجود ارجاع می‌دهد. این روش زمانی بهترین است که بخواهید اگر تلاشی برای دسترسی به عنصری فراتر از انتهای وکتور وجود داشت، برنامه‌تان کرش کند.

وقتی متد `get` اندیسی خارج از وکتور دریافت کند، بدون پنیک کردن `None` برمی‌گرداند. این روش را زمانی استفاده می‌کنید که دسترسی به عنصری فراتر از محدوده وکتور ممکن است به‌صورت گاه‌به‌گاه در شرایط عادی رخ دهد. کد شما سپس باید منطقی برای مدیریت داشتن `Some(&element)` یا `None` داشته باشد، همان‌طور که در فصل ششم بحث کردیم. برای مثال، اندیس ممکن است از کاربری بیاید که یک شماره وارد می‌کند. اگر به‌طور تصادفی شماره‌ای بیش از حد بزرگ وارد کنند و برنامه مقدار `None` دریافت کند، می‌توانید به کاربر بگویید چند مورد در وکتور فعلی وجود دارد و به او فرصت دیگری برای وارد کردن یک مقدار معتبر بدهید. این از کرش کردن برنامه به دلیل یک خطای تایپی کاربرپسندتر است!

وقتی برنامه یک ارجاع معتبر دارد، بررسی‌کننده قرض (borrow checker) قوانین مالکیت و قرض‌گیری (که در فصل چهارم پوشش داده شد) را اعمال می‌کند تا اطمینان حاصل کند که این ارجاع و هر ارجاع دیگری به محتوای وکتور معتبر باقی می‌ماند. قانون را به یاد بیاورید که می‌گوید نمی‌توانید ارجاع‌های قابل‌تغییر و غیرقابل‌تغییر را در یک حوزه داشته باشید. این قانون در لیست ۸-۶ اعمال می‌شود، جایی که ما یک ارجاع غیرقابل‌تغییر به اولین عنصر در یک وکتور نگه می‌داریم و سعی می‌کنیم عنصری به انتها اضافه کنیم. این برنامه اگر بعداً در تابع به آن عنصر ارجاع دهیم، کار نخواهد کرد.

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("عنصر اول: {first}");
```

**لیست ۸-۶:** تلاش برای افزودن یک عنصر به وکتور در حالی که ارجاعی به یک مورد نگه داشته شده است

کامپایل این کد منجر به این خطا می‌شود:

```bash
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: نمی‌توان `v` را به‌صورت قابل‌تغییر قرض گرفت زیرا قبلاً به‌صورت غیرقابل‌تغییر قرض گرفته شده است
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - قرض غیرقابل‌تغییر اینجا رخ می‌دهد
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ قرض قابل‌تغییر اینجا رخ می‌دهد
7 |
8 |     println!("عنصر اول: {first}");
  |                                     ------- قرض غیرقابل‌تغییر بعداً اینجا استفاده شده است

برای اطلاعات بیشتر درباره این خطا، `rustc --explain E0502` را امتحان کنید.
error: نتوانست جعبه `collections` (باینری "collections") را به دلیل 1 خطای قبلی کامپایل کند
```

کد در لیست ۸-۶ ممکن است به نظر برسد که باید کار کند: چرا ارجاع به اولین عنصر باید به تغییرات در انتهای وکتور اهمیت دهد؟ این خطا به نحوه کار وکتورها برمی‌گردد: چون وکتورها مقادیر را کنار یکدیگر در حافظه قرار می‌دهند، افزودن یک عنصر جدید به انتهای وکتور ممکن است نیاز به تخصیص حافظه جدید و کپی کردن عناصر قدیمی به فضای جدید داشته باشد، اگر فضای کافی برای قرار دادن همه عناصر کنار یکدیگر در جایی که وکتور فعلی ذخیره شده وجود نداشته باشد. در این صورت، ارجاع به اولین عنصر به حافظه‌ای که آزاد شده اشاره خواهد کرد. قوانین قرض‌گیری از قرار گرفتن برنامه‌ها در چنین موقعیتی جلوگیری می‌کنند.

**توجه:** برای جزئیات بیشتر درباره پیاده‌سازی نوع `Vec<T>`، به «The Rustonomicon» مراجعه کنید.

### پیمایش روی مقادیر در یک وکتور

برای دسترسی به هر عنصر در یک وکتور به نوبت، باید همه عناصر را پیمایش کنیم به‌جای اینکه از اندیس‌ها برای دسترسی به یک عنصر در هر زمان استفاده کنیم. لیست ۸-۷ نشان می‌دهد چگونه از یک حلقه `for` برای دریافت ارجاع‌های غیرقابل‌تغییر به هر عنصر در یک وکتور از مقادیر `i32` استفاده کنیم و آن‌ها را چاپ کنیم.

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

**لیست ۸-۷:** چاپ هر عنصر در یک وکتور با پیمایش روی عناصر با استفاده از حلقه `for`

همچنین می‌توانیم روی ارجاع‌های قابل‌تغییر به هر عنصر در یک وکتور قابل‌تغییر پیمایش کنیم تا تغییراتی در همه عناصر اعمال کنیم. حلقه `for` در لیست ۸-۸ به هر عنصر ۵۰ اضافه می‌کند.

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

**لیست ۸-۸:** پیمایش روی ارجاع‌های قابل‌تغییر به عناصر در یک وکتور

برای تغییر مقداری که ارجاع قابل‌تغییر به آن اشاره می‌کند، باید از عملگر دی‌رفرنس `*` استفاده کنیم تا به مقدار در `i` برسیم قبل از اینکه بتوانیم از عملگر `+=` استفاده کنیم. در بخش «دنبال کردن اشاره‌گر به مقدار» در فصل پانزدهم بیشتر درباره عملگر دی‌رفرنس صحبت خواهیم کرد.

پیمایش روی یک وکتور، چه به‌صورت غیرقابل‌تغییر و چه قابل‌تغییر، به دلیل قوانین بررسی‌کننده قرض ایمن است. اگر در بدنه‌های حلقه `for` در لیست ۸-۷ و ۸-۸ سعی کنیم مواردی را وارد کنیم یا حذف کنیم، خطای کامپایلر مشابه خطایی که در کد لیست ۸-۶ دریافت کردیم، خواهیم گرفت. ارجاعی که حلقه `for` به وکتور نگه می‌دارد، از تغییر همزمان کل وکتور جلوگیری می‌کند.

### استفاده از یک شمارش برای ذخیره انواع مختلف

وکتورها فقط می‌توانند مقادیری را ذخیره کنند که از یک نوع یکسان باشند. این می‌تواند ناخوشایند باشد؛ قطعاً مواردی وجود دارد که نیاز به ذخیره لیستی از موارد با انواع مختلف دارید. خوشبختانه، انواع یک شمارش تحت همان نوع شمارش تعریف می‌شوند، بنابراین وقتی نیاز داریم یک نوع برای نشان دادن عناصری از انواع مختلف داشته باشیم، می‌توانیم یک شمارش تعریف و استفاده کنیم!

برای مثال، فرض کنید می‌خواهیم مقادیری را از یک ردیف در یک صفحه‌گسترده دریافت کنیم که برخی از ستون‌های ردیف شامل اعداد صحیح، برخی اعداد اعشاری، و برخی رشته‌ها هستند. می‌توانیم یک شمارش تعریف کنیم که انواع آن مقادیر مختلف را نگه دارد، و همه انواع شمارش به‌عنوان یک نوع یکسان در نظر گرفته می‌شوند: نوع شمارش. سپس می‌توانیم وکتوری ایجاد کنیم که آن شمارش را نگه دارد و در نتیجه، انواع مختلف را نگه دارد. این را در لیست ۸-۹ نشان داده‌ایم.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

**لیست ۸-۹:** تعریف یک شمارش برای ذخیره مقادیر از انواع مختلف در یک وکتور

Rust نیاز دارد در زمان کامپایل بداند چه انواعی در وکتور خواهند بود تا دقیقاً بداند چه مقدار حافظه روی هیپ برای ذخیره هر عنصر نیاز است. همچنین باید صریحاً مشخص کنیم چه انواعی در این وکتور مجاز هستند. اگر Rust به وکتوری اجازه می‌داد هر نوع را نگه دارد، این احتمال وجود داشت که یک یا چند نوع باعث خطاهایی در عملیات انجام‌شده روی عناصر وکتور شوند. استفاده از یک شمارش به علاوه یک عبارت `match` به این معناست که Rust در زمان کامپایل اطمینان حاصل می‌کند که هر حالت ممکن مدیریت شده است، همان‌طور که در فصل ششم بحث کردیم.

اگر در زمان اجرا مجموعه جامعی از انواعی که یک برنامه در وکتور ذخیره خواهد کرد را ندانید، تکنیک شمارش کار نخواهد کرد. در عوض، می‌توانید از یک شیء ویژگی‌ (trait object) استفاده کنید، که در فصل هجدهم پوشش خواهیم داد.

حالا که برخی از رایج‌ترین روش‌های استفاده از وکتورها را بحث کردیم، حتماً مستندات API را برای همه متدهای مفید متعددی که توسط کتابخانه استاندارد روی `Vec<T>` تعریف شده‌اند، بررسی کنید. برای مثال، علاوه بر `push`، یک متد `pop` عنصر آخر را حذف می‌کند و برمی‌گرداند.

### حذف وکتور عناصرش را حذف می‌کند

مانند هر ساختار دیگری، یک وکتور وقتی از حوزه خارج می‌شود آزاد می‌شود، همان‌طور که در لیست ۸-۱۰ حاشیه‌نویسی شده است.

```rust
{
    let v = vec![1, 2, 3, 4];

    // کارهایی با v انجام دهید
} // <- v از حوزه خارج می‌شود و اینجا آزاد می‌شود
```

**لیست ۸-۱۰:** نشان دادن جایی که وکتور و عناصرش حذف می‌شوند

وقتی وکتور حذف می‌شود، همه محتوای آن نیز حذف می‌شود، به این معنی که اعداد صحیحی که نگه می‌دارد پاکسازی می‌شوند. بررسی‌کننده قرض اطمینان می‌دهد که هر ارجاعی به محتوای یک وکتور فقط زمانی استفاده می‌شود که خود وکتور معتبر باشد.

بیایید به نوع مجموعه بعدی برویم: `String`!

---

**توضیحات اضافی:**

- **ترجمه:** متن به‌صورت روان و با زبانی ساده ترجمه شد تا برای خواننده قابل‌فهم باشد. پیام‌های خطا و خروجی‌های کنسول به فارسی ترجمه شدند تا با متن هم‌خوانی داشته باشند، اما ساختار فنی آن‌ها حفظ شد.
- **کد:** کدهای خام بدون تغییر باقی ماندند، و فقط توضیحات و پیام‌های اطراف ترجمه شدند.
- **اصطلاحات:** کلمات «Rust» و «heap» به‌صورت لاتین نگه داشته شدند. اصطلاحات فنی مانند «vector»، «Vec<T>»، «push»، «get»، «Option»، «match»، «panic»، «borrow checker»، و «enum» به‌صورت لاتین استفاده شدند اما با معادل‌های فارسی (مانند «وکتور»، «فشار دادن»، «گرفتن»، «گزینه»، «تطبیق»، «پنیک»، «بررسی‌کننده قرض»، و «شمارش») توضیح داده شدند تا مفهوم واضح باشد.
- **توضیحات اضافی:** توضیحات مختصر اضافه شد تا تأکید شود که وکتورها برای مدیریت لیست‌های پویا با نوع یکسان طراحی شده‌اند و قوانین قرض‌گیری Rust از خطاهای حافظه جلوگیری می‌کند.
- **سبک:** سبک ترجمه ساده و مستقیم است، با تمرکز بر وضوح و انتقال دقیق مفاهیم فنی.

اگر بخش بعدی (مثل رشته‌ها، `String`، یا نقشه‌های هش) یا نکته خاصی (مثل تغییر سبک، معادل‌های خاص، یا سرعت) مدنظرتون هست، بفرمایید تا سریع ادامه بدم!
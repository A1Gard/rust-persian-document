# ویژگی‌های زبان‌های شیءگرا

در جامعه برنامه‌نویسی، توافقی درباره اینکه یک زبان برای اینکه شیءگرا محسوب شود باید چه ویژگی‌هایی داشته باشد وجود ندارد. Rust تحت تأثیر پارادایم‌های برنامه‌نویسی متعددی قرار دارد، از جمله شیءگرایی (OOP)؛ برای مثال، در فصل سیزدهم ویژگی‌هایی را که از برنامه‌نویسی تابعی آمده‌اند بررسی کردیم. به‌طور کلی، می‌توان گفت که زبان‌های شیءگرا ویژگی‌های مشترکی دارند، یعنی اشیاء، کپسوله‌سازی، و وراثت. بیایید ببینیم هر یک از این ویژگی‌ها چه معنایی دارند و آیا Rust از آن‌ها پشتیبانی می‌کند.

## اشیاء شامل داده و رفتار هستند

کتاب *Design Patterns: Elements of Reusable Object-Oriented Software* نوشته اریک گاما، ریچارد هلم، رالف جانسون، و جان ولیسیدس (Addison-Wesley، 1994)، که به‌طور محاوره‌ای به‌عنوان کتاب «گروه چهار نفره» شناخته می‌شود، کاتالوگی از الگوهای طراحی شیءگرا است. این کتاب شیءگرایی را این‌گونه تعریف می‌کند:

> برنامه‌های شیءگرا از اشیاء تشکیل شده‌اند. یک شیء هم داده‌ها و هم رویه‌هایی که روی آن داده‌ها عمل می‌کنند را بسته‌بندی می‌کند. این رویه‌ها معمولاً متدها یا عملیات نامیده می‌شوند.

با این تعریف، Rust شیءگرا است: ساختارها (structs) و شمارش‌ها (enums) داده دارند، و بلوک‌های `impl` متدهایی را برای ساختارها و شمارش‌ها فراهم می‌کنند. اگرچه ساختارها و شمارش‌هایی که متد دارند «اشیاء» نامیده نمی‌شوند، اما طبق تعریف گروه چهار نفره از اشیاء، همان عملکرد را ارائه می‌دهند.

## کپسوله‌سازی که جزئیات پیاده‌سازی را مخفی می‌کند

جنبه دیگری که معمولاً با شیءگرایی مرتبط است، ایده کپسوله‌سازی است، به این معنا که جزئیات پیاده‌سازی یک شیء برای کدی که از آن شیء استفاده می‌کند قابل دسترسی نیست. بنابراین، تنها راه تعامل با یک شیء از طریق API عمومی آن است؛ کدی که از شیء استفاده می‌کند نباید بتواند به داخل شیء نفوذ کند و داده‌ها یا رفتار آن را مستقیماً تغییر دهد. این امکان را به برنامه‌نویس می‌دهد که بدون نیاز به تغییر کدی که از شیء استفاده می‌کند، داخلی‌های شیء را تغییر دهد یا بازسازی کند.

در فصل هفتم درباره نحوه کنترل کپسوله‌سازی صحبت کردیم: می‌توانیم از کلمه کلیدی `pub` برای تصمیم‌گیری درباره اینکه کدام ماژول‌ها، نوع‌ها، توابع، و متدها در کد ما باید عمومی باشند استفاده کنیم، و به‌طور پیش‌فرض همه چیز دیگر خصوصی است. برای مثال، می‌توانیم یک ساختار `AveragedCollection` تعریف کنیم که یک فیلد حاوی یک وکتور از مقادیر `i32` دارد. این ساختار همچنین می‌تواند یک فیلد داشته باشد که میانگین مقادیر موجود در وکتور را نگه می‌دارد، به این معنا که نیازی نیست هر بار که کسی به میانگین نیاز دارد، آن را محاسبه کنیم. به عبارت دیگر، `AveragedCollection` میانگین محاسبه‌شده را برای ما ذخیره (cache) می‌کند. Listing 18-1 تعریف ساختار `AveragedCollection` را نشان می‌دهد:

**فایل: src/lib.rs**

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

**Listing 18-1: یک ساختار AveragedCollection که لیستی از اعداد صحیح و میانگین آیتم‌های مجموعه را نگه می‌دارد**

ساختار با `pub` علامت‌گذاری شده تا کدهای دیگر بتوانند از آن استفاده کنند، اما فیلدهای درون ساختار خصوصی باقی می‌مانند. این در این مورد مهم است زیرا می‌خواهیم اطمینان حاصل کنیم که هر زمان مقداری به لیست اضافه یا از آن حذف می‌شود، میانگین نیز به‌روزرسانی شود. ما این کار را با پیاده‌سازی متدهای `add`، `remove`، و `average` روی ساختار انجام می‌دهیم، همان‌طور که در Listing 18-2 نشان داده شده است:

**فایل: src/lib.rs**

```rust
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

**Listing 18-2: پیاده‌سازی متدهای عمومی add، remove، و average روی AveragedCollection**

متدهای عمومی `add`، `remove`، و `average` تنها راه‌های دسترسی یا تغییر داده‌ها در یک نمونه از `AveragedCollection` هستند. وقتی آیتمی با استفاده از متد `add` به `list` اضافه می‌شود یا با استفاده از متد `remove` حذف می‌شود، پیاده‌سازی هر کدام متد خصوصی `update_average` را فراخوانی می‌کند که وظیفه به‌روزرسانی فیلد `average` را بر عهده دارد.

ما فیلدهای `list` و `average` را خصوصی نگه می‌داریم تا هیچ راهی برای کد خارجی وجود نداشته باشد که مستقیماً آیتم‌هایی را به فیلد `list` اضافه یا از آن حذف کند؛ در غیر این صورت، فیلد `average` ممکن است هنگام تغییر `list` ناهمگام شود. متد `average` مقدار موجود در فیلد `average` را برمی‌گرداند، که به کد خارجی اجازه می‌دهد میانگین را بخواند اما آن را تغییر ندهد.

چون ما جزئیات پیاده‌سازی ساختار `AveragedCollection` را کپسوله کرده‌ایم، می‌توانیم به‌راحتی جنبه‌هایی مانند ساختار داده را در آینده تغییر دهیم. برای مثال، می‌توانیم به جای `Vec<i32>` از `HashSet<i32>` برای فیلد `list` استفاده کنیم. تا زمانی که امضاهای متدهای عمومی `add`، `remove`، و `average` ثابت بمانند، کدی که از `AveragedCollection` استفاده می‌کند نیازی به تغییر ندارد. اگر به جای آن `list` را عمومی می‌کردیم، این لزوماً صادق نبود: `HashSet<i32>` و `Vec<i32>` متدهای متفاوتی برای افزودن و حذف آیتم‌ها دارند، بنابراین کد خارجی احتمالاً باید تغییر می‌کرد اگر مستقیماً `list` را تغییر می‌داد.

اگر کپسوله‌سازی یک جنبه مورد نیاز برای اینکه یک زبان شیءگرا محسوب شود باشد، Rust این نیاز را برآورده می‌کند. گزینه استفاده یا عدم استفاده از `pub` برای بخش‌های مختلف کد، کپسوله‌سازی جزئیات پیاده‌سازی را ممکن می‌کند.

## وراثت به‌عنوان یک سیستم نوع و به‌عنوان اشتراک کد

وراثت مکانیزمی است که از طریق آن یک شیء می‌تواند عناصری را از تعریف شیء دیگری به ارث ببرد، و بنابراین داده‌ها و رفتار شیء والد را بدون نیاز به تعریف دوباره آن‌ها به دست آورد.

اگر یک زبان برای شیءگرا بودن باید وراثت داشته باشد، Rust چنین زبانی نیست. هیچ راهی برای تعریف یک ساختار که فیلدها و پیاده‌سازی‌های متد ساختار والد را بدون استفاده از ماکرو به ارث ببرد وجود ندارد.

با این حال، اگر به استفاده از وراثت در جعبه‌ابزار برنامه‌نویسی خود عادت دارید، می‌توانید از راه‌حل‌های دیگری در Rust استفاده کنید، بسته به اینکه چرا در درجه اول به سراغ وراثت می‌روید.

شما به دو دلیل اصلی از وراثت استفاده می‌کنید. یکی برای استفاده مجدد از کد: می‌توانید رفتار خاصی را برای یک نوع پیاده‌سازی کنید، و وراثت به شما امکان می‌دهد آن پیاده‌سازی را برای نوع دیگری استفاده مجدد کنید. در Rust می‌توانید این کار را به‌صورت محدود با استفاده از پیاده‌سازی‌های پیش‌فرض متدهای ویژگی انجام دهید، که در Listing 10-14 دیدید وقتی یک پیاده‌سازی پیش‌فرض از متد `summarize` را به ویژگی `Summary` اضافه کردیم. هر نوع‌ای که ویژگی `Summary` را پیاده‌سازی کند، متد `summarize` را بدون نیاز به کد اضافی در دسترس خواهد داشت. این مشابه این است که یک کلاس والد پیاده‌سازی یک متد را داشته باشد و یک کلاس فرزند که از آن ارث می‌برد نیز پیاده‌سازی آن متد را داشته باشد. همچنین می‌توانیم هنگام پیاده‌سازی ویژگی `Summary`، پیاده‌سازی پیش‌فرض متد `summarize` را بازنویسی کنیم، که مشابه بازنویسی پیاده‌سازی یک متد به ارث برده‌شده از یک کلاس والد توسط یک کلاس فرزند است.

دلیل دیگر استفاده از وراثت به سیستم نوع مربوط می‌شود: برای اینکه نوع فرزند بتواند در همان جاهایی که نوع والد استفاده می‌شود، استفاده شود. این را پلی‌مورفیسم (چندریختی) نیز می‌نامند، به این معنا که می‌توانید چندین شیء را در زمان اجرا با یکدیگر جایگزین کنید اگر ویژگی‌های مشترکی داشته باشند.

### پلی‌مورفیسم

برای بسیاری از افراد، پلی‌مورفیسم مترادف با وراثت است. اما در واقع مفهومی کلی‌تر است که به کدی اشاره دارد که می‌تواند با داده‌هایی از چندین نوع کار کند. برای وراثت، این نوع‌ها معمولاً زیرکلاس‌ها هستند.

Rust به جای آن از جنریک‌ها (generics) برای انتزاع روی نوع‌های مختلف ممکن و محدودیت‌های ویژگی (trait bounds) برای اعمال محدودیت‌ها روی آنچه آن نوع‌ها باید فراهم کنند استفاده می‌کند. این گاهی به‌عنوان پلی‌مورفیسم پارامتری محدود (bounded parametric polymorphism) نامیده می‌شود.

وراثت اخیراً در بسیاری از زبان‌های برنامه‌نویسی به‌عنوان یک راه‌حل طراحی برنامه‌نویسی از محبوبیت افتاده است، زیرا اغلب در معرض خطر اشتراک بیش از حد کد است. زیرکلاس‌ها همیشه نباید همه ویژگی‌های کلاس والد خود را به اشتراک بگذارند، اما با وراثت این کار را می‌کنند. این می‌تواند طراحی یک برنامه را کمتر انعطاف‌پذیر کند. همچنین امکان فراخوانی متدهایی روی زیرکلاس‌ها را فراهم می‌کند که منطقی نیستند یا باعث خطا می‌شوند زیرا متدها برای زیرکلاس اعمال نمی‌شوند. علاوه بر این، برخی زبان‌ها فقط اجازه وراثت تک (single inheritance) را می‌دهند (به این معنا که یک زیرکلاس فقط می‌تواند از یک کلاس ارث ببرد)، که انعطاف‌پذیری طراحی یک برنامه را بیشتر محدود می‌کند.

به همین دلایل، Rust رویکرد متفاوتی را در پیش گرفته و به جای وراثت از اشیاء ویژگی (trait objects) استفاده می‌کند. بیایید ببینیم چگونه اشیاء ویژگی در Rust پلی‌مورفیسم را ممکن می‌کنند.
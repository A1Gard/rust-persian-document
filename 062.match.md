## ساختار کنترل جریان `match`

Rust یک ساختار کنترل جریان بسیار قدرتمند به نام `match` دارد که به شما امکان می‌دهد یک مقدار را با مجموعه‌ای از الگوها مقایسه کنید و سپس بر اساس الگویی که مطابقت دارد، کد را اجرا کنید. الگوها می‌توانند از مقادیر لفظی، نام‌های متغیر، کاراکترهای عام (wildcards)، و بسیاری چیزهای دیگر تشکیل شوند؛ فصل نوزدهم تمام انواع مختلف الگوها و کارهایی که انجام می‌دهند را پوشش می‌دهد. قدرت `match` از بیانگری الگوها و این واقعیت ناشی می‌شود که کامپایلر تأیید می‌کند همه موارد ممکن پوشش داده شده‌اند.

عبارت `match` را مانند یک دستگاه مرتب‌سازی سکه در نظر بگیرید: سکه‌ها از یک مسیر با سوراخ‌هایی با اندازه‌های مختلف پایین می‌روند، و هر سکه در اولین سوراخی که مناسب آن باشد می‌افتد. به همین ترتیب، مقادیر در `match` از هر الگو عبور می‌کنند، و در اولین الگویی که مقدار با آن «مطابقت» دارد، مقدار به بلوک کد مرتبط می‌افتد تا در طول اجرا استفاده شود.

با صحبت از سکه‌ها، بیایید از آن‌ها به‌عنوان مثالی برای استفاده از `match` استفاده کنیم! می‌توانیم تابعی بنویسیم که یک سکه ناشناخته آمریکایی را می‌گیرد و، مشابه دستگاه شمارش، تشخیص می‌دهد که چه سکه‌ای است و ارزش آن را به سنت برمی‌گرداند، همان‌طور که در لیست ۶-۳ نشان داده شده است.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

**لیست ۶-۳:** یک شمارش و یک عبارت `match` که انواع شمارش را به‌عنوان الگوهای خود دارد

بیایید `match` در تابع `value_in_cents` را تجزیه کنیم. ابتدا کلمه‌کلیدی `match` را فهرست می‌کنیم و به دنبال آن یک عبارت، که در این مورد مقدار `coin` است. این بسیار شبیه به یک عبارت شرطی استفاده‌شده با `if` به نظر می‌رسد، اما تفاوت بزرگی وجود دارد: با `if`، شرط باید به یک مقدار بولین ارزیابی شود، اما اینجا می‌تواند هر نوع باشد. نوع `coin` در این مثال شمارش `Coin` است که در خط اول تعریف کردیم.

سپس بازوهای (arms) `match` می‌آیند. یک بازو دو بخش دارد: یک الگو و مقداری کد. اولین بازو اینجا الگویی دارد که مقدار `Coin::Penny` است و سپس عملگر `=>` که الگو و کدی که باید اجرا شود را جدا می‌کند. کد در این مورد فقط مقدار `1` است. هر بازو از بازوی بعدی با یک کاما جدا می‌شود.

وقتی عبارت `match` اجرا می‌شود، مقدار حاصل را با الگوی هر بازو، به ترتیب، مقایسه می‌کند. اگر الگویی با مقدار مطابقت داشته باشد، کد مرتبط با آن الگو اجرا می‌شود. اگر آن الگو با مقدار مطابقت نداشته باشد، اجرا به بازوی بعدی ادامه می‌یابد، مشابه دستگاه مرتب‌سازی سکه. ما می‌توانیم به تعداد مورد نیاز بازو داشته باشیم: در لیست ۶-۳، `match` ما چهار بازو دارد.

کد مرتبط با هر بازو یک عبارت است، و مقدار حاصل از عبارت در بازوی مطابقت‌یافته، مقداری است که برای کل عبارت `match` برگردانده می‌شود.

اگر کد بازوی `match` کوتاه باشد، مانند لیست ۶-۳ که هر بازو فقط یک مقدار را برمی‌گرداند، معمولاً از کروشه‌ها استفاده نمی‌کنیم. اگر بخواهید چندین خط کد در یک بازوی `match` اجرا کنید، باید از کروشه‌ها استفاده کنید، و کاما پس از بازو در آن صورت اختیاری است. برای مثال، کد زیر هر بار که متد با `Coin::Penny` فراخوانی شود، «پنی خوش‌شانس!» را چاپ می‌کند، اما همچنان آخرین مقدار بلوک، یعنی `1`، را برمی‌گرداند:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("پنی خوش‌شانس!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### الگوهایی که به مقادیر متصل می‌شوند

ویژگی مفید دیگر بازوهای `match` این است که می‌توانند به بخش‌هایی از مقادیر که با الگو مطابقت دارند متصل شوند. این‌گونه می‌توانیم مقادیر را از انواع شمارش استخراج کنیم.

به‌عنوان مثال، بیایید یکی از انواع شمارش خود را تغییر دهیم تا داده‌ای در داخل آن نگه دارد. از سال ۱۹۹۹ تا ۲۰۰۸، ایالات متحده سکه‌های ربع‌دلاری با طرح‌های مختلف برای هر یک از ۵۰ ایالت روی یک طرف ضرب کرد. هیچ سکه دیگری طرح‌های ایالتی نداشت، بنابراین فقط ربع‌دلارها این مقدار اضافی را دارند. می‌توانیم این اطلاعات را به شمارش خود اضافه کنیم با تغییر نوع `Quarter` برای شامل یک مقدار `UsState` که در داخل آن ذخیره شده است، همان‌طور که در لیست ۶-۴ انجام دادیم.

```rust
#[derive(Debug)] // تا بتوانیم ایالت را در لحظه بررسی کنیم
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

**لیست ۶-۴:** یک شمارش `Coin` که نوع `Quarter` آن همچنین یک مقدار `UsState` را نگه می‌دارد

فرض کنید دوستی در حال جمع‌آوری تمام ۵۰ ربع‌دلار ایالتی است. در حالی که پول خرد خود را بر اساس نوع سکه مرتب می‌کنیم، همچنین نام ایالت مرتبط با هر ربع‌دلار را اعلام می‌کنیم تا اگر یکی باشد که دوستمان ندارد، بتواند آن را به مجموعه‌اش اضافه کند.

در عبارت `match` برای این کد، یک متغیر به نام `state` به الگویی که مقادیر نوع `Coin::Quarter` را مطابقت می‌دهد اضافه می‌کنیم. وقتی یک `Coin::Quarter` مطابقت پیدا کند، متغیر `state` به مقدار ایالت آن ربع‌دلار متصل خواهد شد. سپس می‌توانیم از `state` در کد آن بازو استفاده کنیم، مانند زیر:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("ربع‌دلار ایالتی از {state:?}!");
            25
        }
    }
}
```

اگر `value_in_cents(Coin::Quarter(UsState::Alaska))` را فراخوانی کنیم، `coin` برابر با `Coin::Quarter(UsState::Alaska)` خواهد بود. وقتی آن مقدار را با هر یک از بازوهای `match` مقایسه کنیم، هیچ‌کدام مطابقت نمی‌کنند تا به `Coin::Quarter(state)` برسیم. در آن نقطه، اتصال برای `state` مقدار `UsState::Alaska` خواهد بود. سپس می‌توانیم از آن اتصال در عبارت `println!` استفاده کنیم، و بدین ترتیب مقدار ایالت داخلی را از نوع شمارش `Coin` برای `Quarter` استخراج کنیم.

### تطبیق با `Option<T>`

در بخش قبلی، می‌خواستیم مقدار داخلی `T` را از مورد `Some` وقتی از `Option<T>` استفاده می‌کنیم، خارج کنیم؛ همچنین می‌توانیم `Option<T>` را با استفاده از `match` مدیریت کنیم، همان‌طور که با شمارش `Coin` کردیم! به‌جای مقایسه سکه‌ها، انواع `Option<T>` را مقایسه خواهیم کرد، اما نحوه کار عبارت `match` همان است.

فرض کنید می‌خواهیم تابعی بنویسیم که یک `Option<i32>` می‌گیرد و، اگر مقداری در داخل آن باشد، ۱ به آن مقدار اضافه می‌کند. اگر هیچ مقداری در داخل نباشد، تابع باید مقدار `None` را برگرداند و هیچ عملیاتی انجام ندهد.

این تابع به لطف `match` بسیار آسان نوشته می‌شود و مانند لیست ۶-۵ خواهد بود.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

**لیست ۶-۵:** تابعی که از یک عبارت `match` روی یک `Option<i32>` استفاده می‌کند

بیایید اولین اجرای `plus_one` را با جزئیات بیشتری بررسی کنیم. وقتی `plus_one(five)` را فراخوانی می‌کنیم، متغیر `x` در بدنه `plus_one` مقدار `Some(5)` را خواهد داشت. سپس آن را با هر بازوی `match` مقایسه می‌کنیم:

```rust
None => None,
```

مقدار `Some(5)` با الگوی `None` مطابقت ندارد، بنابراین به بازوی بعدی ادامه می‌دهیم:

```rust
Some(i) => Some(i + 1),
```

آیا `Some(5)` با `Some(i)` مطابقت دارد؟ بله! ما نوع یکسانی داریم. `i` به مقدار داخل `Some` متصل می‌شود، بنابراین `i` مقدار `5` را می‌گیرد. سپس کد در بازوی `match` اجرا می‌شود، بنابراین ۱ به مقدار `i` اضافه می‌کنیم و یک مقدار `Some` جدید با مجموع ۶ در داخل آن ایجاد می‌کنیم.

حالا بیایید دومین فراخوانی `plus_one` در لیست ۶-۵ را در نظر بگیریم، جایی که `x` برابر `None` است. وارد `match` می‌شویم و با اولین بازو مقایسه می‌کنیم:

```rust
None => None,
```

مطابقت دارد! هیچ مقداری برای اضافه کردن وجود ندارد، بنابراین برنامه متوقف می‌شود و مقدار `None` در سمت راست `=>` را برمی‌گرداند. چون اولین بازو مطابقت داشت، بازوهای دیگر مقایسه نمی‌شوند.

ترکیب `match` و شمارش‌ها در بسیاری از موقعیت‌ها مفید است. این الگو را زیاد در کدهای Rust خواهید دید: تطبیق با یک شمارش، اتصال یک متغیر به داده داخل آن، و سپس اجرای کد بر اساس آن. در ابتدا کمی پیچیده است، اما وقتی به آن عادت کنید، آرزو می‌کنید در همه زبان‌ها وجود داشت. این به‌طور مداوم مورد علاقه کاربران است.

### تطبیق‌ها باید جامع باشند

یک جنبه دیگر از `match` که باید بحث کنیم این است: الگوهای بازوها باید همه امکانات را پوشش دهند. این نسخه از تابع `plus_one` ما را در نظر بگیرید، که یک باگ دارد و کامپایل نمی‌شود:

**این کد کامپایل نمی‌شود!**

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

ما مورد `None` را مدیریت نکردیم، بنابراین این کد باعث یک باگ می‌شود. خوشبختانه، این باگی است که Rust می‌داند چگونه آن را بگیرد. اگر سعی کنیم این کد را کامپایل کنیم، خطای زیر را دریافت خواهیم کرد:

```bash
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option<i32>` defined here
   --> file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/option.rs:572:1
    |
572 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^
...
576 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) => Some(i + 1),
5   ~             None => todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
```

Rust می‌داند که ما هر مورد ممکن را پوشش ندادیم، و حتی می‌داند کدام الگو را فراموش کردیم! تطبیق‌ها در Rust جامع (exhaustive) هستند: باید هر امکان نهایی را پوشش دهیم تا کد معتبر باشد. به‌ویژه در مورد `Option<T>`، وقتی Rust ما را از فراموش کردن مدیریت صریح مورد `None` بازمی‌دارد، ما را از فرض اینکه مقداری داریم وقتی ممکن است نال باشد محافظت می‌کند، و بدین ترتیب اشتباه میلیارد دلاری که قبلاً بحث کردیم را غیرممکن می‌کند.

### الگوهای گیرنده همه و جایگاه‌نگهدار `_`

با استفاده از شمارش‌ها، می‌توانیم برای چند مقدار خاص اقدامات ویژه‌ای انجام دهیم، اما برای همه مقادیر دیگر یک اقدام پیش‌فرض انجام دهیم. فرض کنید در حال پیاده‌سازی یک بازی هستیم که اگر در پرتاب تاس عدد ۳ بیاورید، بازیکن شما حرکت نمی‌کند، اما به‌جای آن یک کلاه فانتزی جدید می‌گیرد. اگر ۷ بیاورید، بازیکن شما یک کلاه فانتزی را از دست می‌دهد. برای همه مقادیر دیگر، بازیکن شما به تعداد آن عدد روی تخته بازی حرکت می‌کند. اینجا یک `match` است که این منطق را پیاده‌سازی می‌کند، با نتیجه پرتاب تاس به‌صورت سخت‌کدشده به‌جای مقدار تصادفی، و تمام منطق‌های دیگر با توابع بدون بدنه نشان داده شده‌اند زیرا پیاده‌سازی واقعی آن‌ها خارج از محدوده این مثال است:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

برای دو بازوی اول، الگوها مقادیر لفظی ۳ و ۷ هستند. برای آخرین بازو که هر مقدار ممکن دیگر را پوشش می‌دهد، الگو متغیری است که ما انتخاب کردیم به نام `other`. کدی که برای بازوی `other` اجرا می‌شود از متغیر با پاس دادن آن به تابع `move_player` استفاده می‌کند.

این کد کامپایل می‌شود، حتی اگر ما همه مقادیر ممکنی که یک `u8` می‌تواند داشته باشد را فهرست نکرده باشیم، زیرا الگوی آخر همه مقادیر مشخص‌نشده را مطابقت می‌دهد. این الگوی گیرنده همه (catch-all pattern) نیاز به جامع بودن `match` را برآورده می‌کند. توجه کنید که باید بازوی گیرنده همه را آخر قرار دهیم زیرا الگوها به ترتیب ارزیابی می‌شوند. اگر بازوی گیرنده همه را زودتر قرار دهیم، بازوهای دیگر هرگز اجرا نمی‌شوند، بنابراین Rust اگر بازوهایی پس از یک گیرنده همه اضافه کنیم، به ما هشدار می‌دهد!

Rust همچنین الگویی دارد که می‌توانیم وقتی می‌خواهیم یک گیرنده همه داشته باشیم اما نمی‌خواهیم از مقدار در الگوی گیرنده همه استفاده کنیم، استفاده کنیم: `_` یک الگوی خاص است که با هر مقداری مطابقت دارد و به آن مقدار متصل نمی‌شود. این به Rust می‌گوید که ما قصد استفاده از مقدار را نداریم، بنابراین Rust درباره متغیر استفاده‌نشده به ما هشدار نمی‌دهد.

بیایید قوانین بازی را تغییر دهیم: حالا، اگر هر چیزی غیر از ۳ یا ۷ بیاورید، باید دوباره تاس بریزید. دیگر نیازی به استفاده از مقدار گیرنده همه نداریم، بنابراین می‌توانیم کدمان را تغییر دهیم تا به‌جای متغیر به نام `other` از `_` استفاده کنیم:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

این مثال همچنین نیاز به جامع بودن را برآورده می‌کند زیرا در آخرین بازو به‌صراحت همه مقادیر دیگر را نادیده می‌گیریم؛ ما چیزی را فراموش نکرده‌ایم.

در نهایت، قوانین بازی را یک بار دیگر تغییر می‌دهیم تا اگر هر چیزی غیر از ۳ یا ۷ بیاورید، در نوبت شما هیچ اتفاق دیگری نیفتد. می‌توانیم این را با استفاده از مقدار واحد (نوع تاپل خالی که در بخش «نوع تاپل» ذکر کردیم) به‌عنوان کدی که با بازوی `_` همراه است، بیان کنیم:

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

در اینجا، ما به Rust به‌صراحت می‌گوییم که هیچ مقدار دیگری که با الگویی در بازوی قبلی مطابقت ندارد را استفاده نخواهیم کرد، و نمی‌خواهیم در این مورد هیچ کدی اجرا کنیم.

درباره الگوها و تطبیق در فصل نوزدهم بیشتر صحبت خواهیم کرد. برای حالا، به سینتکس `if let` می‌رویم، که می‌تواند در موقعیت‌هایی که عبارت `match` کمی طولانی است، مفید باشد.

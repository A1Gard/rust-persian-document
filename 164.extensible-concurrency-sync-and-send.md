# همزمانی قابل‌گسترش با ویژگی‌های `Send` و `Sync`

جالب است که تقریباً تمام ویژگی‌های همزمانی که تاکنون در این فصل درباره آن‌ها صحبت کردیم، بخشی از کتابخانه استاندارد بوده‌اند، نه خود زبان. گزینه‌های شما برای مدیریت همزمانی به زبان یا کتابخانه استاندارد محدود نمی‌شوند؛ می‌توانید ویژگی‌های همزمانی خود را بنویسید یا از آن‌هایی که دیگران نوشته‌اند استفاده کنید.

با این حال، در میان مفاهیم کلیدی همزمانی که در خود زبان (به جای کتابخانه استاندارد) جای گرفته‌اند، ویژگی‌های نشانگر (marker traits) `Send` و `Sync` از ماژول `std::marker` قرار دارند.

## اجازه انتقال مالکیت بین نخ‌ها با `Send`

ویژگی نشانگر `Send` نشان می‌دهد که مالکیت مقادیر نوعی که `Send` را پیاده‌سازی کرده است، می‌تواند بین نخ‌ها منتقل شود. تقریباً همه نوع‌های Rust به‌طور پیش‌فرض `Send` هستند، اما استثناهایی وجود دارد، از جمله `Rc<T>`: این نوع نمی‌تواند `Send` را پیاده‌سازی کند، زیرا اگر شما یک مقدار `Rc<T>` را کلون کنید و سعی کنید مالکیت کلون را به نخ دیگری منتقل کنید، هر دو نخ ممکن است برشمارش مرجع را به‌طور همزمان به‌روزرسانی کنند. به همین دلیل، `Rc<T>` برای استفاده در موقعیت‌های تک‌نخی طراحی شده است، جایی که نمی‌خواهید هزینه عملکرد ایمنی نخ را بپردازید.

بنابراین، سیستم نوع و محدودیت‌های ویژگی (trait bounds) در Rust تضمین می‌کنند که شما هرگز به‌طور تصادفی یک مقدار `Rc<T>` را به‌صورت غیرایمن بین نخ‌ها ارسال نکنید. وقتی در Listing 16-14 سعی کردیم این کار را انجام دهیم، خطای «ویژگی `Send` برای `Rc<Mutex<i32>>` پیاده‌سازی نشده است» را دریافت کردیم. وقتی به `Arc<T>` که `Send` را پیاده‌سازی می‌کند تغییر دادیم، کد کامپایل شد.

هر نوعی که کاملاً از نوع‌های `Send` تشکیل شده باشد، به‌طور خودکار به‌عنوان `Send` علامت‌گذاری می‌شود. تقریباً همه نوع‌های اولیه (primitive types) به جز اشاره‌گرهای خام (raw pointers) که در فصل بیستم بحث خواهیم کرد، `Send` هستند.

## اجازه دسترسی از چندین نخ با `Sync`

ویژگی نشانگر `Sync` نشان می‌دهد که برای نوعی که `Sync` را پیاده‌سازی کرده است، ارجاع از چندین نخ به آن ایمن است. به عبارت دیگر، هر نوع `T` ویژگی `Sync` را پیاده‌سازی می‌کند اگر `&T` (یک ارجاع غیرقابل تغییر به `T`) ویژگی `Send` را داشته باشد، به این معنا که ارجاع می‌تواند به‌طور ایمن به نخ دیگری ارسال شود. مشابه `Send`، نوع‌های اولیه همگی `Sync` را پیاده‌سازی می‌کنند، و نوع‌هایی که کاملاً از نوع‌هایی که `Sync` را پیاده‌سازی می‌کنند تشکیل شده‌اند، نیز `Sync` هستند.

اشاره‌گر هوشمند `Rc<T>` به همان دلایلی که `Send` را پیاده‌سازی نمی‌کند، `Sync` را نیز پیاده‌سازی نمی‌کند. نوع `RefCell<T>` (که در فصل پانزدهم درباره آن صحبت کردیم) و خانواده مرتبط نوع‌های `Cell<T>` نیز `Sync` را پیاده‌سازی نمی‌کنند. پیاده‌سازی بررسی قرض‌گیری (borrow checking) که `RefCell<T>` در زمان اجرا انجام می‌دهد، ایمن برای نخ نیست. اما اشاره‌گر هوشمند `Mutex<T>` ویژگی `Sync` را پیاده‌سازی می‌کند و همان‌طور که در بخش «اشتراک یک `Mutex<T>` بین چندین نخ» دیدید، می‌تواند برای اشتراک دسترسی با چندین نخ استفاده شود.

## پیاده‌سازی دستی `Send` و `Sync` غیرایمن است

چون نوع‌هایی که کاملاً از نوع‌های دیگر که ویژگی‌های `Send` و `Sync` را پیاده‌سازی کرده‌اند تشکیل شده‌اند، به‌طور خودکار `Send` و `Sync` را پیاده‌سازی می‌کنند، نیازی به پیاده‌سازی دستی این ویژگی‌ها نداریم. به‌عنوان ویژگی‌های نشانگر، این ویژگی‌ها حتی متدی برای پیاده‌سازی ندارند. آن‌ها فقط برای اعمال محدودیت‌های (invariants) مرتبط با همزمانی مفید هستند.

پیاده‌سازی دستی این ویژگی‌ها شامل نوشتن کد Rust غیرایمن (unsafe) است. در فصل بیستم درباره استفاده از کد غیرایمن Rust صحبت خواهیم کرد؛ فعلاً، نکته مهم این است که ساخت نوع‌های همزمانی جدید که از بخش‌های `Send` و `Sync` تشکیل نشده‌اند، نیاز به تفکر دقیق برای حفظ تضمین‌های ایمنی دارد. منبع «The Rustonomicon» اطلاعات بیشتری درباره این تضمین‌ها و نحوه حفظ آن‌ها ارائه می‌دهد.

## خلاصه

این آخرین باری نیست که در این کتاب درباره همزمانی صحبت می‌کنیم: فصل بعدی روی برنامه‌نویسی غیرهمزمان (async programming) تمرکز دارد، و پروژه در فصل بیست‌ویکم از مفاهیم این فصل در موقعیتی واقعی‌تر نسبت به مثال‌های کوچک بحث‌شده در اینجا استفاده خواهد کرد.

همان‌طور که قبلاً ذکر شد، چون بخش بسیار کمی از نحوه مدیریت همزمانی در Rust بخشی از خود زبان است، بسیاری از راه‌حل‌های همزمانی به‌عنوان کریت‌ها (crates) پیاده‌سازی شده‌اند. این کریت‌ها سریع‌تر از کتابخانه استاندارد تکامل می‌یابند، بنابراین حتماً به‌صورت آنلاین برای یافتن کریت‌های به‌روز و پیشرفته برای استفاده در موقعیت‌های چندنخی جستجو کنید.

کتابخانه استاندارد Rust کانال‌هایی برای انتقال پیام و نوع‌های اشاره‌گر هوشمند مانند `Mutex<T>` و `Arc<T>` را ارائه می‌دهد که برای استفاده در زمینه‌های همزمان ایمن هستند. سیستم نوع و بررسی‌کننده قرض‌گیری (borrow checker) تضمین می‌کنند که کدی که از این راه‌حل‌ها استفاده می‌کند، دچار رقابت داده‌ای (data races) یا ارجاعات نامعتبر نشود. وقتی کد شما کامپایل می‌شود، می‌توانید مطمئن باشید که به‌راحتی روی چندین نخ اجرا خواهد شد بدون خطاهای دشوار برای ردیابی که در زبان‌های دیگر رایج هستند. برنامه‌نویسی همزمان دیگر مفهومی نیست که از آن بترسید: پیش بروید و برنامه‌های خود را به‌صورت همزمان کنید، بدون ترس!
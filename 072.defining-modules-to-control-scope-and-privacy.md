ببخشید، اشتباه شد! برمی‌گردم به روال قبلی و ترجمه رو ادامه می‌دم. درختی که خواستی رو هم به صورت متنی در قالب کد درست کردم، حالا ادامه متن رو با همون سبک ترجمه روان و ساده پیش می‌برم.

---

## تعریف ماژول‌ها برای کنترل حوزه و حریم خصوصی

در این بخش، درباره **ماژول‌ها** و سایر بخش‌های سیستم ماژول صحبت خواهیم کرد، به‌ویژه **مسیرها (paths)** که به شما امکان می‌دهند موارد را نام‌گذاری کنید؛ کلمه‌کلیدی `use` که یک مسیر را به حوزه می‌آورد؛ و کلمه‌کلیدی `pub` برای عمومی کردن موارد. همچنین درباره کلمه‌کلیدی `as`، بسته‌های خارجی، و عملگر گلوب (glob operator) بحث خواهیم کرد.

### برگه تقلب ماژول‌ها

قبل از اینکه به جزئیات ماژول‌ها و مسیرها بپردازیم، یک مرجع سریع درباره نحوه کار ماژول‌ها، مسیرها، کلمه‌کلیدی `use`، و کلمه‌کلیدی `pub` در کامپایلر و نحوه سازمان‌دهی کد توسط اکثر توسعه‌دهندگان ارائه می‌دهیم. در طول این فصل، مثال‌هایی از هر یک از این قوانین را بررسی خواهیم کرد، اما این بخش مکان خوبی برای مراجعه به‌عنوان یادآوری نحوه کار ماژول‌ها است.

- **شروع از ریشه جعبه:** وقتی یک جعبه کامپایل می‌شود، کامپایلر ابتدا در فایل ریشه جعبه (معمولاً `src/lib.rs` برای جعبه کتابخانه‌ای یا `src/main.rs` برای جعبه باینری) به دنبال کد برای کامپایل می‌گردد.
- **اعلان ماژول‌ها:** در فایل ریشه جعبه، می‌توانید ماژول‌های جدید اعلان کنید؛ فرض کنید یک ماژول «باغ» با `mod garden;` اعلان می‌کنید. کامپایلر کد ماژول را در این مکان‌ها جستجو می‌کند:
    - به‌صورت درون‌خطی، داخل کروشه‌هایی که به‌جای سمی‌کالن پس از `mod garden` می‌آیند.
    - در فایل `src/garden.rs`.
    - در فایل `src/garden/mod.rs`.
- **اعلان زیرماژول‌ها:** در هر فایلی غیر از ریشه جعبه، می‌توانید زیرماژول‌ها را اعلان کنید. برای مثال، ممکن است `mod vegetables;` را در `src/garden.rs` اعلان کنید. کامپایلر کد زیرماژول را در دایرکتوری‌ای که به نام ماژول والد است در این مکان‌ها جستجو می‌کند:
    - به‌صورت درون‌خطی، بلافاصله پس از `mod vegetables`، داخل کروشه‌ها به‌جای سمی‌کالن.
    - در فایل `src/garden/vegetables.rs`.
    - در فایل `src/garden/vegetables/mod.rs`.
- **مسیرها به کد در ماژول‌ها:** وقتی یک ماژول بخشی از جعبه شما باشد، می‌توانید به کد آن ماژول از هر جای دیگر در همان جعبه ارجاع دهید، به شرطی که قوانین حریم خصوصی اجازه دهند، با استفاده از مسیر به کد. برای مثال، یک نوع `Asparagus` در ماژول سبزیجات باغ در `crate::garden::vegetables::Asparagus` یافت می‌شود.
- **خصوصی در مقابل عمومی:** کد داخل یک ماژول به‌صورت پیش‌فرض از ماژول‌های والد خود خصوصی است. برای عمومی کردن یک ماژول، آن را با `pub mod` به‌جای `mod` اعلان کنید. برای عمومی کردن موارد داخل یک ماژول عمومی، قبل از اعلان آن‌ها از `pub` استفاده کنید.
- **کلمه‌کلیدی `use`:** در یک حوزه، کلمه‌کلیدی `use` میانبرهایی به موارد ایجاد می‌کند تا تکرار مسیرهای طولانی کاهش یابد. در هر حوزه‌ای که بتواند به `crate::garden::vegetables::Asparagus` ارجاع دهد، می‌توانید با `use crate::garden::vegetables::Asparagus;` یک میانبر ایجاد کنید و از آن پس فقط با نوشتن `Asparagus` از آن نوع در حوزه استفاده کنید.

در اینجا، یک جعبه باینری به نام `backyard` ایجاد می‌کنیم که این قوانین را نشان می‌دهد. دایرکتوری جعبه، که آن هم `backyard` نامیده می‌شود، شامل این فایل‌ها و دایرکتوری‌ها است:

```plaintext
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

فایل ریشه جعبه در این مورد `src/main.rs` است، و شامل این محتوا است:

**نام فایل:** `src/main.rs`

```rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("دارم {plant:?} پرورش می‌دم!");
}
```

خط `pub mod garden;` به کامپایلر می‌گوید که کد موجود در `src/garden.rs` را شامل کند، که به این صورت است:

**نام فایل:** `src/garden.rs`

```rust
pub mod vegetables;
```

در اینجا، `pub mod vegetables;` به این معناست که کد موجود در `src/garden/vegetables.rs` نیز شامل می‌شود. آن کد به این صورت است:

**نام فایل:** `src/garden/vegetables.rs`

```rust
#[derive(Debug)]
pub struct Asparagus {}
```

حالا بیایید به جزئیات این قوانین بپردازیم و آن‌ها را در عمل نشان دهیم!

### گروه‌بندی کد مرتبط در ماژول‌ها

ماژول‌ها به ما امکان می‌دهند کد را در یک جعبه برای خوانایی و استفاده مجدد آسان سازمان‌دهی کنیم. ماژول‌ها همچنین به ما اجازه می‌دهند حریم خصوصی موارد را کنترل کنیم، زیرا کد داخل یک ماژول به‌صورت پیش‌فرض خصوصی است. موارد خصوصی جزئیات پیاده‌سازی داخلی هستند که برای استفاده خارجی در دسترس نیستند. ما می‌توانیم انتخاب کنیم که ماژول‌ها و موارد داخل آن‌ها را عمومی کنیم، که آن‌ها را آشکار می‌کند تا کد خارجی بتواند از آن‌ها استفاده کند و به آن‌ها وابسته باشد.

به‌عنوان مثال، بیایید یک جعبه کتابخانه‌ای بنویسیم که قابلیت‌های یک رستوران را فراهم می‌کند. ما امضاهای توابع را تعریف می‌کنیم اما بدنه‌های آن‌ها را خالی می‌گذاریم تا روی سازمان‌دهی کد تمرکز کنیم، نه پیاده‌سازی یک رستوران.

در صنعت رستوران، برخی بخش‌های رستوران به‌عنوان **جلوی سالن (front of house)** و برخی دیگر به‌عنوان **پشت سالن (back of house)** شناخته می‌شوند. جلوی سالن جایی است که مشتریان هستند؛ این شامل جایی است که میزبانان مشتریان را به میزها هدایت می‌کنند، خدمتکاران سفارش‌ها و پرداخت را می‌گیرند، و متصدیان بار نوشیدنی‌ها را درست می‌کنند. پشت سالن جایی است که سرآشپزها و آشپزها در آشپزخانه کار می‌کنند، ظرفشویان تمیزکاری می‌کنند، و مدیران کارهای اداری انجام می‌دهند.

برای ساختاردهی جعبه‌مان به این روش، می‌توانیم توابع آن را در ماژول‌های تودرتو سازمان‌دهی کنیم. یک کتابخانه جدید به نام `restaurant` با اجرای `cargo new restaurant --lib` ایجاد کنید. سپس کد موجود در لیست ۷-۱ را در `src/lib.rs` وارد کنید تا برخی ماژول‌ها و امضاهای تابع را تعریف کنید؛ این کد بخش جلوی سالن است.

**نام فایل:** `src/lib.rs`

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

**لیست ۷-۱:** یک ماژول `front_of_house` که شامل ماژول‌های دیگری است که خود شامل توابع هستند

ما یک ماژول را با کلمه‌کلیدی `mod` و سپس نام ماژول (در این مورد، `front_of_house`) تعریف می‌کنیم. بدنه ماژول سپس داخل کروشه‌ها قرار می‌گیرد. داخل ماژول‌ها، می‌توانیم ماژول‌های دیگری قرار دهیم، مانند اینجا با ماژول‌های `hosting` و `serving`. ماژول‌ها همچنین می‌توانند تعریف‌هایی برای موارد دیگر، مانند ساختارها، برشمارش‌ها، ثابت‌ها، ویژگی‌‌ها، و همان‌طور که در لیست ۷-۱ می‌بینید، توابع را نگه دارند.

با استفاده از ماژول‌ها، می‌توانیم تعریف‌های مرتبط را با هم گروه‌بندی کنیم و نام‌گذاری کنیم که چرا مرتبط هستند. برنامه‌نویسانی که از این کد استفاده می‌کنند می‌توانند بر اساس گروه‌ها در کد پیمایش کنند به‌جای اینکه مجبور باشند تمام تعریف‌ها را بخوانند، که پیدا کردن تعریف‌های مرتبط با آن‌ها را آسان‌تر می‌کند. برنامه‌نویسانی که قابلیت جدیدی به این کد اضافه می‌کنند، می‌دانند کد را کجا قرار دهند تا برنامه سازمان‌یافته بماند.

قبلاً ذکر کردیم که `src/main.rs` و `src/lib.rs` به‌عنوان **ریشه‌های جعبه** شناخته می‌شوند. دلیل نام‌گذاری آن‌ها این است که محتوای هر یک از این دو فایل یک ماژول به نام `crate` را در ریشه ساختار ماژول جعبه تشکیل می‌دهد، که به‌عنوان **درخت ماژول (module tree)** شناخته می‌شود.

لیست ۷-۲ درخت ماژول را برای ساختار موجود در لیست ۷-۱ نشان می‌دهد:

```plaintext
crate
└── front_of_house
    ├── hosting
    │   ├── add_to_waitlist
    │   └── seat_at_table
    └── serving
        ├── take_order
        ├── serve_order
        └── take_payment
```

**لیست ۷-۲:** درخت ماژول برای کد موجود در لیست ۷-۱

این درخت نشان می‌دهد که چگونه برخی ماژول‌ها داخل ماژول‌های دیگر تودرتو هستند؛ برای مثال، `hosting` داخل `front_of_house` تودرتو است. درخت همچنین نشان می‌دهد که برخی ماژول‌ها **خواهر و برادر** هستند، به این معنی که در یک ماژول یکسان تعریف شده‌اند؛ `hosting` و `serving` خواهر و برادر هستند که داخل `front_of_house` تعریف شده‌اند. اگر ماژول A داخل ماژول B باشد، می‌گوییم ماژول A **فرزند** ماژول B است و ماژول B **والد** ماژول A است. توجه کنید که کل درخت ماژول تحت ماژول ضمنی به نام `crate` ریشه دارد.

درخت ماژول ممکن است شما را به یاد درخت دایرکتوری فایل‌سیستم در کامپیوترتان بیندازد؛ این مقایسه بسیار مناسبی است! درست مانند دایرکتوری‌ها در یک فایل‌سیستم، از ماژول‌ها برای سازمان‌دهی کد خود استفاده می‌کنید. و درست مانند فایل‌ها در یک دایرکتوری، نیاز به راهی برای پیدا کردن ماژول‌هایمان داریم.

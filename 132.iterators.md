# پردازش مجموعه‌ای از آیتم‌ها با تکرارسازها

الگوی تکرارساز به شما امکان می‌دهد وظیفه‌ای را به ترتیب روی یک دنباله از آیتم‌ها انجام دهید. یک تکرارساز مسئول منطق پیمایش روی هر آیتم و تعیین زمان پایان دنباله است. وقتی از تکرارسازها استفاده می‌کنید، نیازی به پیاده‌سازی مجدد آن منطق ندارید.

در **Rust**، تکرارسازها **تنبل (lazy)** هستند، به این معنی که تا زمانی که متدهایی را که تکرارساز را مصرف می‌کنند فراخوانی نکنید، هیچ اثری ندارند. به عنوان مثال، کد در **جدول 13-10** با فراخوانی متد `iter` تعریف‌شده روی `Vec<T>`، یک تکرارساز روی آیتم‌های بردار `v1` ایجاد می‌کند. این کد به‌خودی‌خود کار مفیدی انجام نمی‌دهد.

**فایل: src/main.rs**

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
}
```

**جدول 13-10**: ایجاد یک تکرارساز

تکرارساز در متغیر `v1_iter` ذخیره می‌شود. هنگامی که یک تکرارساز ایجاد کردیم، می‌توانیم از آن به روش‌های مختلفی استفاده کنیم. در **جدول 3-5** در فصل سوم، ما با استفاده از یک حلقه `for` روی یک آرایه پیمایش کردیم تا کدی را روی هر یک از آیتم‌های آن اجرا کنیم. در پشت صحنه، این کار به‌صورت ضمنی یک تکرارساز ایجاد و سپس مصرف کرد، اما ما تا حالا توضیح دقیق چگونگی کارکرد آن را نادیده گرفته بودیم.

در مثال در **جدول 13-11**، ما ایجاد تکرارساز را از استفاده از تکرارساز در حلقه `for` جدا می‌کنیم. وقتی حلقه `for` با استفاده از تکرارساز در `v1_iter` فراخوانی می‌شود، هر عنصر در تکرارساز در یک تکرار از حلقه استفاده می‌شود، که هر مقدار را چاپ می‌کند.

**فایل: src/main.rs**

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
}
```

**جدول 13-11**: استفاده از یک تکرارساز در یک حلقه `for`

در زبان‌هایی که تکرارسازها توسط کتابخانه استانداردشان ارائه نمی‌شوند، احتمالاً این عملکرد مشابه را با شروع یک متغیر در شاخص 0، استفاده از آن متغیر برای شاخص‌گذاری در بردار برای به‌دست‌آوردن یک مقدار، و افزایش مقدار متغیر در یک حلقه تا زمانی که به تعداد کل آیتم‌های بردار برسد، می‌نوشتید.

تکرارسازها تمام این منطق را برای شما مدیریت می‌کنند، و کد تکراری‌ای که ممکن است اشتباه کنید را کاهش می‌دهند. تکرارسازها انعطاف‌پذیری بیشتری برای استفاده از همان منطق با انواع مختلف دنباله‌ها، نه فقط ساختارهای داده‌ای که می‌توانید در آن‌ها شاخص‌گذاری کنید، مانند بردارها، به شما می‌دهند. بیایید بررسی کنیم که تکرارسازها چگونه این کار را انجام می‌دهند.

## ویژگی‌ Iterator و متد next

همه تکرارسازها یک ویژگی‌ به نام `Iterator` را پیاده‌سازی می‌کنند که در کتابخانه استاندارد تعریف شده است. تعریف این ویژگی‌ به این شکل است:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // متدهای با پیاده‌سازی‌های پیش‌فرض حذف شده‌اند
}
```

توجه کنید که این تعریف از یک نحو جدید استفاده می‌کند: `type Item` و `Self::Item`، که یک نوع مرتبط با این ویژگی‌ را تعریف می‌کنند. ما در فصل بیستم درباره انواع مرتبط به‌طور عمیق صحبت خواهیم کرد. برای حالا، فقط باید بدانید که این کد می‌گوید پیاده‌سازی ویژگی‌ `Iterator` نیازمند تعریف یک نوع `Item` است، و این نوع `Item` در نوع بازگشتی متد `next` استفاده می‌شود. به عبارت دیگر، نوع `Item` نوع‌ای خواهد بود که از تکرارساز برگردانده می‌شود.

ویژگی‌ `Iterator` فقط از پیاده‌سازان می‌خواهد که یک متد را تعریف کنند: متد `next`، که یک آیتم از تکرارساز را در هر زمان، پیچیده‌شده در `Some` برمی‌گرداند و وقتی پیمایش تمام شود، `None` را برمی‌گرداند.

ما می‌توانیم متد `next` را روی تکرارسازها مستقیماً فراخوانی کنیم؛ **جدول 13-12** نشان می‌دهد که چه مقادیری از فراخوانی‌های مکرر `next` روی تکرارسازی که از بردار ایجاد شده است برگردانده می‌شود.

**فایل: src/lib.rs**

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

**جدول 13-12**: فراخوانی متد `next` روی یک تکرارساز

توجه کنید که نیاز داشتیم `v1_iter` را قابل تغییر کنیم: فراخوانی متد `next` روی یک تکرارساز حالت داخلی‌ای را که تکرارساز برای ردیابی موقعیت خود در دنباله استفاده می‌کند تغییر می‌دهد. به عبارت دیگر، این کد تکرارساز را مصرف می‌کند یا استفاده می‌کند. هر فراخوانی به `next` یک آیتم از تکرارساز را مصرف می‌کند. ما نیازی به قابل تغییر کردن `v1_iter` نداشتیم وقتی از یک حلقه `for` استفاده کردیم زیرا حلقه مالکیت `v1_iter` را گرفت و آن را در پشت صحنه قابل تغییر کرد.

همچنین توجه کنید که مقادیری که از فراخوانی‌های `next` دریافت می‌کنیم ارجاعات غیرقابل تغییر به مقادیر در بردار هستند. متد `iter` یک تکرارساز روی ارجاعات غیرقابل تغییر تولید می‌کند. اگر بخواهیم یک تکرارساز ایجاد کنیم که مالکیت `v1` را بگیرد و مقادیر مالک‌شده را برگرداند، می‌توانیم به جای `iter` از `into_iter` فراخوانی کنیم. به‌طور مشابه، اگر بخواهیم روی ارجاعات قابل تغییر پیمایش کنیم، می‌توانیم به جای `iter` از `iter_mut` فراخوانی کنیم.

## متدهایی که تکرارساز را مصرف می‌کنند

ویژگی‌ `Iterator` تعداد زیادی متد مختلف با پیاده‌سازی‌های پیش‌فرض ارائه‌شده توسط کتابخانه استاندارد دارد؛ می‌توانید درباره این متدها با نگاه کردن به مستندات API کتابخانه استاندارد برای ویژگی‌ `Iterator` اطلاعات کسب کنید. برخی از این متدها در تعریف خود متد `next` را فراخوانی می‌کنند، به همین دلیل است که هنگام پیاده‌سازی ویژگی‌ `Iterator` نیاز به پیاده‌سازی متد `next` دارید.

متدهایی که `next` را فراخوانی می‌کنند، **آداپتورهای مصرف‌کننده** نامیده می‌شوند زیرا فراخوانی آن‌ها تکرارساز را مصرف می‌کند. یک مثال متد `sum` است، که مالکیت تکرارساز را می‌گیرد و با فراخوانی مکرر `next` روی آیتم‌ها پیمایش می‌کند، بنابراین تکرارساز را مصرف می‌کند. در حین پیمایش، هر آیتم را به یک مجموع در حال اجرا اضافه می‌کند و وقتی پیمایش کامل شود، مجموع را برمی‌گرداند. **جدول 13-13** یک تست را نشان می‌دهد که استفاده از متد `sum` را نشان می‌دهد.

**فایل: src/lib.rs**

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

**جدول 13-13**: فراخوانی متد `sum` برای به‌دست‌آوردن مجموع همه آیتم‌های در تکرارساز

ما اجازه نداریم از `v1_iter` بعد از فراخوانی `sum` استفاده کنیم زیرا `sum` مالکیت تکرارسازی که روی آن فراخوانی شده را می‌گیرد.

## متدهایی که تکرارسازهای دیگر تولید می‌کنند

**آداپتورهای تکرارساز** متدهایی هستند که روی ویژگی‌ `Iterator` تعریف شده‌اند و تکرارساز را مصرف نمی‌کنند. در عوض، آن‌ها تکرارسازهای متفاوتی را با تغییر برخی جنبه‌های تکرارساز اصلی تولید می‌کنند.

**جدول 13-14** مثالی از فراخوانی متد آداپتور تکرارساز `map` را نشان می‌دهد، که یک بسته‌بندی می‌گیرد تا روی هر آیتم هنگام پیمایش آیتم‌ها فراخوانی شود. متد `map` یک تکرارساز جدید برمی‌گرداند که آیتم‌های اصلاح‌شده را تولید می‌کند. بسته‌بندی در اینجا یک تکرارساز جدید ایجاد می‌کند که در آن هر آیتم از بردار 1 واحد افزایش می‌یابد:

**فایل: src/main.rs**

**این کد رفتار مورد نظر را تولید نمی‌کند.**

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
}
```

**جدول 13-14**: فراخوانی آداپتور تکرارساز `map` برای ایجاد یک تکرارساز جدید

با این حال، این کد یک هشدار تولید می‌کند:

```bash
$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
```

کد در **جدول 13-14** هیچ کاری انجام نمی‌دهد؛ بسته‌بندی‌ای که مشخص کرده‌ایم هرگز فراخوانی نمی‌شود. هشدار به ما یادآوری می‌کند که چرا: آداپتورهای تکرارساز تنبل هستند، و ما باید تکرارساز را اینجا مصرف کنیم.

برای رفع این هشدار و مصرف تکرارساز، از متد `collect` استفاده خواهیم کرد، که در فصل دوازدهم با `env::args` در **جدول 12-1** استفاده کردیم. این متد تکرارساز را مصرف می‌کند و مقادیر حاصل را در یک نوع داده مجموعه جمع‌آوری می‌کند.

در **جدول 13-15**، ما نتایج پیمایش روی تکرارسازی که از فراخوانی `map` برگردانده شده است را در یک بردار جمع‌آوری می‌کنیم. این بردار در نهایت شامل هر آیتم از بردار اصلی خواهد بود که 1 واحد افزایش یافته است.

**فایل: src/main.rs**

```rust
fn main() {
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}
```

**جدول 13-15**: فراخوانی متد `map` برای ایجاد یک تکرارساز جدید و سپس فراخوانی متد `collect` برای مصرف تکرارساز جدید و ایجاد یک بردار

چون `map` یک بسته‌بندی می‌گیرد، می‌توانیم هر عملیاتی که می‌خواهیم روی هر آیتم انجام شود را مشخص کنیم. این یک مثال عالی از این است که چگونه بسته‌بندی‌ها به شما اجازه می‌دهند برخی رفتارها را سفارشی کنید در حالی که رفتار پیمایشی که ویژگی‌ `Iterator` فراهم می‌کند را دوباره استفاده می‌کنید.

می‌توانید چندین فراخوانی به آداپتورهای تکرارساز را زنجیره کنید تا اقدامات پیچیده‌ای را به روشی خوانا انجام دهید. اما چون همه تکرارسازها تنبل هستند، باید یکی از متدهای آداپتور مصرف‌کننده را فراخوانی کنید تا نتایجی از فراخوانی‌های آداپتورهای تکرارساز بگیرید.

## استفاده از بسته‌بندی‌هایی که محیط خود را ضبط می‌کنند

بسیاری از آداپتورهای تکرارساز بسته‌بندی‌ها را به‌عنوان آرگومان می‌گیرند، و معمولاً بسته‌بندی‌هایی که به‌عنوان آرگومان به آداپتورهای تکرارساز مشخص می‌کنیم، بسته‌بندی‌هایی خواهند بود که محیط خود را ضبط می‌کنند.

برای این مثال، از متد `filter` استفاده خواهیم کرد که یک بسته‌بندی می‌گیرد. بسته‌بندی یک آیتم از تکرارساز دریافت می‌کند و یک مقدار بولی برمی‌گرداند. اگر بسته‌بندی `true` برگرداند، مقدار در پیمایش تولید‌شده توسط `filter` گنجانده خواهد شد. اگر بسته‌بندی `false` برگرداند، مقدار گنجانده نخواهد شد.

در **جدول 13-16**، ما از `filter` با یک بسته‌بندی استفاده می‌کنیم که متغیر `shoe_size` را از محیط خود ضبط می‌کند تا روی مجموعه‌ای از نمونه‌های ساختار `Shoe` پیمایش کند. این فقط کفش‌هایی را که اندازه مشخص‌شده دارند برمی‌گرداند.

**فایل: src/lib.rs**

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```

**جدول 13-16**: استفاده از متد `filter` با یک بسته‌بندی که `shoe_size` را ضبط می‌کند

تابع `shoes_in_size` مالکیت یک بردار از کفش‌ها و یک اندازه کفش را به‌عنوان پارامتر می‌گیرد. این یک بردار را برمی‌گرداند که فقط شامل کفش‌های اندازه مشخص‌شده است.

در بدنه `shoes_in_size`، ما `into_iter` را فراخوانی می‌کنیم تا یک تکرارساز ایجاد کنیم که مالکیت بردار را می‌گیرد. سپس `filter` را فراخوانی می‌کنیم تا آن تکرارساز را به یک تکرارساز جدید تطبیق دهیم که فقط شامل عناصری است که بسته‌بندی برای آن‌ها `true` برمی‌گرداند.

بسته‌بندی پارامتر `shoe_size` را از محیط ضبط می‌کند و مقدار را با اندازه هر کفش مقایسه می‌کند، و فقط کفش‌های اندازه مشخص‌شده را نگه می‌دارد. در نهایت، فراخوانی `collect` مقادیر برگردانده‌شده توسط تکرارساز تطبیق‌یافته را در یک بردار جمع‌آوری می‌کند که توسط تابع برگردانده می‌شود.

تست نشان می‌دهد که وقتی `shoes_in_size` را فراخوانی می‌کنیم، فقط کفش‌هایی را که اندازه‌ای برابر با مقدار مشخص‌شده دارند برمی‌گردانیم.
# قابل‌رد بودن: آیا یک الگو ممکن است در تطبیق شکست بخورد

الگوها در دو شکل وجود دارند: **غیرقابل‌رد (irrefutable)** و **قابل‌رد (refutable)**. الگوهای غیرقابل‌رد آن‌هایی هستند که برای هر مقدار ممکنی که پاس داده شود، مطابقت خواهند داشت. برای مثال، `x` در عبارت `let x = 5;` یک الگوی غیرقابل‌رد است، زیرا `x` با هر چیزی مطابقت دارد و بنابراین نمی‌تواند در تطبیق شکست بخورد. الگوهای قابل‌رد آن‌هایی هستند که ممکن است برای برخی مقادیر ممکن در تطبیق شکست بخورند. برای مثال، `Some(x)` در عبارت `if let Some(x) = a_value` یک الگوی قابل‌رد است، زیرا اگر مقدار در متغیر `a_value` به‌جای `Some` برابر با `None` باشد، الگوی `Some(x)` مطابقت نخواهد داشت.

پارامترهای تابع، عبارت‌های `let`، و حلقه‌های `for` فقط می‌توانند الگوهای غیرقابل‌رد را بپذیرند، زیرا برنامه نمی‌تواند کار معنی‌داری انجام دهد وقتی مقادیر مطابقت نداشته باشند. عبارت‌های `if let`، `while let`، و عبارت `let...else` می‌توانند الگوهای قابل‌رد و غیرقابل‌رد را بپذیرند، اما کامپایلر در برابر الگوهای غیرقابل‌رد هشدار می‌دهد، زیرا به‌طور ذاتی برای مدیریت شکست‌های احتمالی طراحی شده‌اند: عملکرد یک شرط در توانایی آن برای انجام متفاوت بسته به موفقیت یا شکست است.

به‌طور کلی، نیازی به نگرانی در مورد تمایز بین الگوهای قابل‌رد و غیرقابل‌رد ندارید؛ با این حال، باید با مفهوم قابل‌رد بودن آشنا باشید تا وقتی در پیام خطا با آن مواجه شدید، بتوانید واکنش نشان دهید. در این موارد، بسته به رفتار مورد نظر کد، باید یا الگو یا ساختار استفاده‌شده با الگو را تغییر دهید.

بیایید مثالی را بررسی کنیم که چه اتفاقی می‌افتد وقتی سعی کنیم یک الگوی قابل‌رد را در جایی که Rust به یک الگوی غیرقابل‌رد نیاز دارد استفاده کنیم و برعکس. Listing 19-8 یک عبارت `let` را نشان می‌دهد، اما برای الگو، ما `Some(x)` را مشخص کرده‌ایم، که یک الگوی قابل‌رد است. همان‌طور که ممکن است انتظار داشته باشید، این کد کامپایل نخواهد شد.

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
let Some(x) = some_option_value;
```

**Listing 19-8: تلاش برای استفاده از یک الگوی قابل‌رد با let**

اگر `some_option_value` یک مقدار `None` باشد، در تطبیق با الگوی `Some(x)` شکست خواهد خورد، به این معنا که الگو قابل‌رد است. با این حال، عبارت `let` فقط می‌تواند یک الگوی غیرقابل‌رد را بپذیرد، زیرا کد نمی‌تواند با یک مقدار `None` کار معتبر انجام دهد. در زمان کامپایل، Rust شکایت خواهد کرد که ما سعی کرده‌ایم یک الگوی قابل‌رد را در جایی که یک الگوی غیرقابل‌رد لازم است استفاده کنیم:

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --> src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option<i32>`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

چون ما با الگوی `Some(x)` هر مقدار معتبر را پوشش ندادیم (و نمی‌توانستیم پوشش دهیم!)، Rust به‌درستی یک خطای کامپایلر تولید می‌کند.

اگر یک الگوی قابل‌رد در جایی داریم که یک الگوی غیرقابل‌رد لازم است، می‌توانیم با تغییر کدی که از الگو استفاده می‌کند آن را برطرف کنیم: به‌جای استفاده از `let`، می‌توانیم از `if let` استفاده کنیم. سپس اگر الگو مطابقت نداشته باشد، کد فقط کد داخل کروشه‌ها را رد می‌کند و راهی برای ادامه معتبر فراهم می‌کند. Listing 19-9 نشان می‌دهد چگونه کد در Listing 19-8 را برطرف کنیم.

```rust
let Some(x) = some_option_value else {
    return;
};
```

**Listing 19-9: استفاده از let...else و یک بلوک با الگوهای قابل‌رد به‌جای let**

ما به کد یک راه خروج دادیم! این کد حالا کاملاً معتبر است. با این حال، اگر به `if let` یک الگوی غیرقابل‌رد (الگویی که همیشه مطابقت دارد)، مانند `x`، بدهیم، همان‌طور که در Listing 19-10 نشان داده شده است، کامپایلر یک هشدار خواهد داد.

```rust
let x = 5 else {
    return;
};
```

**Listing 19-10: تلاش برای استفاده از یک الگوی غیرقابل‌رد با if let**

Rust شکایت می‌کند که استفاده از `if let` با یک الگوی غیرقابل‌رد منطقی نیست:

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --> src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
```

به همین دلیل، بازوهای `match` باید از الگوهای قابل‌رد استفاده کنند، به‌جز بازوی آخر، که باید هر مقدار باقی‌مانده را با یک الگوی غیرقابل‌رد تطبیق دهد. Rust به ما اجازه می‌دهد از یک الگوی غیرقابل‌رد در یک `match` با تنها یک بازو استفاده کنیم، اما این نحو چندان مفید نیست و می‌تواند با یک عبارت `let` ساده‌تر جایگزین شود.

حالا که می‌دانید الگوها کجا استفاده می‌شوند و تفاوت بین الگوهای قابل‌رد و غیرقابل‌رد چیست، بیایید تمام نحو‌هایی که می‌توانیم برای ایجاد الگوها استفاده کنیم را پوشش دهیم.
## سلام، Cargo!

Cargo سیستم ساخت و مدیر بسته Rust است. اکثر Rustaceanها (لقبی که به خودمان می‌دهیم) از این ابزار برای مدیریت پروژه‌های Rust خود استفاده می‌کنند، زیرا Cargo بسیاری از کارها را برای شما انجام می‌دهد، مانند ساخت کد، دانلود کتابخانه‌هایی که کد شما به آن‌ها وابسته است، و ساخت آن کتابخانه‌ها. (ما به کتابخانه‌هایی که کد شما نیاز دارد، وابستگی‌ها یا *dependencies* می‌گوییم.)

برنامه‌های ساده Rust، مانند برنامه‌ای که تاکنون نوشته‌ایم، هیچ وابستگی‌ای ندارند. اگر پروژه «Hello, world!» را با Cargo ساخته بودیم، فقط از بخشی از Cargo که ساخت کد را مدیریت می‌کند استفاده می‌کرد. اما وقتی برنامه‌های پیچیده‌تر Rust می‌نویسید، وابستگی‌هایی اضافه خواهید کرد، و اگر پروژه‌ای را با Cargo شروع کنید، افزودن وابستگی‌ها بسیار آسان‌تر خواهد بود.

از آنجا که اکثریت قریب به اتفاق پروژه‌های Rust از Cargo استفاده می‌کنند، بقیه این کتاب نیز فرض می‌کند که شما از Cargo استفاده می‌کنید. Cargo همراه با Rust نصب می‌شود، اگر از نصب‌کننده‌های رسمی که در بخش «نصب» بحث کردیم استفاده کرده باشید. اگر Rust را از طریق روش دیگری نصب کرده‌اید، بررسی کنید که آیا Cargo نصب شده است یا خیر، با وارد کردن دستور زیر در ترمینال:

```bash
$ cargo --version
```

اگر شماره نسخه را دیدید، Cargo را دارید! اگر خطایی مثل «command not found» دیدید، مستندات روش نصب خود را بررسی کنید تا ببینید چگونه Cargo را جداگانه نصب کنید.

### ایجاد پروژه با Cargo
بیایید یک پروژه جدید با Cargo بسازیم و ببینیم چگونه با پروژه اصلی «Hello, world!» ما متفاوت است. به پوشه `projects` خود (یا هر جایی که تصمیم گرفته‌اید کد خود را ذخیره کنید) برگردید. سپس، در هر سیستم‌عاملی، دستورات زیر را اجرا کنید:

```bash
$ cargo new hello_cargo
$ cd hello_cargo
```

دستور اول یک پوشه و پروژه جدید به نام `hello_cargo` ایجاد می‌کند. ما پروژه‌مان را `hello_cargo` نام‌گذاری کردیم، و Cargo فایل‌های آن را در پوشه‌ای به همین نام ایجاد می‌کند.

به پوشه `hello_cargo` بروید و فایل‌ها را لیست کنید. خواهید دید که Cargo دو فایل و یک پوشه برای ما تولید کرده است: فایل `Cargo.toml` و پوشه `src` که حاوی فایل `main.rs` است.

همچنین یک مخزن Git جدید همراه با فایل `.gitignore` مقداردهی اولیه شده است. اگر دستور `cargo new` را در یک مخزن Git موجود اجرا کنید، فایل‌های Git تولید نمی‌شوند؛ می‌توانید با استفاده از `cargo new --vcs=git` این رفتار را لغو کنید.

> **توجه:** Git یک سیستم کنترل نسخه رایج است. می‌توانید با استفاده از پرچم `--vcs`، دستور `cargo new` را تغییر دهید تا از سیستم کنترل نسخه دیگری یا بدون سیستم کنترل نسخه استفاده کند. برای دیدن گزینه‌های موجود، دستور `cargo new --help` را اجرا کنید.

فایل `Cargo.toml` را در ویرایشگر متن دلخواه خود باز کنید. باید شبیه کد زیر در لیست ۱-۲ باشد:

**نام فایل:** `Cargo.toml`

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

**لیست ۱-۲:** محتوای `Cargo.toml` تولیدشده توسط `cargo new`

این فایل در فرمت TOML (Tom’s Obvious, Minimal Language) است، که فرمت پیکربندی Cargo است.

خط اول، `[package]`، یک عنوان بخش است که نشان می‌دهد عبارات بعدی یک بسته را پیکربندی می‌کنند. با افزودن اطلاعات بیشتر به این فایل، بخش‌های دیگری اضافه خواهیم کرد.

سه خط بعدی اطلاعات پیکربندی موردنیاز Cargo برای کامپایل برنامه شما را تنظیم می‌کنند: نام، نسخه، و ویرایش Rust که باید استفاده شود. درباره کلید `edition` در پیوست E صحبت خواهیم کرد.

خط آخر، `[dependencies]`، شروع بخشی است که می‌توانید وابستگی‌های پروژه خود را در آن لیست کنید. در Rust، بسته‌های کد به‌عنوان *crate* شناخته می‌شوند. برای این پروژه به هیچ crate دیگری نیاز نداریم، اما در پروژه اول فصل دوم به آن‌ها نیاز خواهیم داشت، بنابراین آن موقع از این بخش استفاده می‌کنیم.

**توضیح اضافی:** در Rust، crate‌ها واحدهای کد هستند که می‌توانند کتابخانه یا برنامه‌های اجرایی باشند. بخش `[dependencies]` به شما امکان می‌دهد crate‌های خارجی را که پروژه‌تان به آن‌ها نیاز دارد، مشخص کنید.

حالا فایل `src/main.rs` را باز کنید و نگاهی بیندازید:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo یک برنامه «Hello, world!» برای شما تولید کرده است، دقیقاً مثل برنامه‌ای که در لیست ۱-۱ نوشتیم! تاکنون، تفاوت‌های بین پروژه ما و پروژه‌ای که Cargo تولید کرده این است که Cargo کد را در پوشه `src` قرار داده و ما یک فایل پیکربندی `Cargo.toml` در پوشه اصلی داریم.

Cargo انتظار دارد فایل‌های منبع شما در پوشه `src` باشند. پوشه اصلی پروژه فقط برای فایل‌های README، اطلاعات مجوز، فایل‌های پیکربندی، و هر چیز دیگری که به کد شما مرتبط نیست، استفاده می‌شود. استفاده از Cargo به شما کمک می‌کند پروژه‌هایتان را سازمان‌دهی کنید. هر چیزی جای خود را دارد، و همه‌چیز در جای خود است.

اگر پروژه‌ای را بدون استفاده از Cargo شروع کرده‌اید، مانند پروژه «Hello, world!»، می‌توانید آن را به پروژه‌ای که از Cargo استفاده می‌کند تبدیل کنید. کد پروژه را به پوشه `src` منتقل کنید و یک فایل `Cargo.toml` مناسب ایجاد کنید. یک راه ساده برای دریافت فایل `Cargo.toml` اجرای دستور `cargo init` است که به‌طور خودکار آن را برای شما ایجاد می‌کند.

### ساخت و اجرای پروژه Cargo
حالا بیایید ببینیم وقتی برنامه «Hello, world!» را با Cargo می‌سازیم و اجرا می‌کنیم چه تفاوتی دارد! از پوشه `hello_cargo`، پروژه خود را با وارد کردن دستور زیر بسازید:

```bash
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

این دستور یک فایل اجرایی در `target/debug/hello_cargo` (یا `target\debug\hello_cargo.exe` در ویندوز) ایجاد می‌کند، نه در پوشه فعلی شما. چون ساخت پیش‌فرض یک ساخت دیباگ است، Cargo فایل باینری را در پوشه‌ای به نام `debug` قرار می‌دهد. می‌توانید فایل اجرایی را با این دستور اجرا کنید:

```bash
$ ./target/debug/hello_cargo # یا .\target\debug\hello_cargo.exe در ویندوز
Hello, world!
```

اگر همه‌چیز خوب پیش برود، `Hello, world!` باید در ترمینال چاپ شود. اجرای `cargo build` برای اولین بار همچنین باعث می‌شود Cargo یک فایل جدید در سطح اصلی ایجاد کند: `Cargo.lock`. این فایل نسخه‌های دقیق وابستگی‌های پروژه شما را ردیابی می‌کند. این پروژه هیچ وابستگی‌ای ندارد، بنابراین فایل بسیار خلاصه است. شما هرگز نیازی به تغییر دستی این فایل ندارید؛ Cargo محتوای آن را برای شما مدیریت می‌کند.

ما پروژه را با `cargo build` ساختیم و با `./target/debug/hello_cargo` اجرا کردیم، اما می‌توانیم از `cargo run` استفاده کنیم تا کد را کامپایل کرده و سپس فایل اجرایی حاصل را در یک دستور اجرا کنیم:

```bash
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

استفاده از `cargo run` راحت‌تر است تا اینکه مجبور باشید `cargo build` را اجرا کنید و سپس مسیر کامل فایل باینری را وارد کنید، بنابراین اکثر توسعه‌دهندگان از `cargo run` استفاده می‌کنند.

توجه کنید که این بار خروجی‌ای که نشان دهد Cargo در حال کامپایل `hello_cargo` است ندیدیم. Cargo تشخیص داد فایل‌ها تغییر نکرده‌اند، بنابراین دوباره نساخت و فقط فایل باینری را اجرا کرد. اگر کد منبع خود را تغییر داده بودید، Cargo قبل از اجرا پروژه را بازسازی می‌کرد، و این خروجی را می‌دیدید:

```bash
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo همچنین دستوری به نام `cargo check` ارائه می‌دهد. این دستور کد شما را به‌سرعت بررسی می‌کند تا مطمئن شود کامپایل می‌شود، اما فایل اجرایی تولید نمی‌کند:

```bash
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

چرا ممکن است نخواهید فایل اجرایی داشته باشید؟ اغلب، `cargo check` بسیار سریع‌تر از `cargo build` است، زیرا مرحله تولید فایل اجرایی را رد می‌کند. اگر در حین نوشتن کد مدام کار خود را بررسی می‌کنید، استفاده از `cargo check` فرآیند آگاهی از اینکه آیا پروژه شما هنوز کامپایل می‌شود را تسریع می‌کند! به همین دلیل، بسیاری از Rustaceanها به‌صورت دوره‌ای `cargo check` را اجرا می‌کنند تا مطمئن شوند برنامه‌شان کامپایل می‌شود. سپس وقتی آماده استفاده از فایل اجرایی هستند، `cargo build` را اجرا می‌کنند.

بیایید آنچه تاکنون درباره Cargo آموخته‌ایم مرور کنیم:

- می‌توانیم با `cargo new` پروژه ایجاد کنیم.
- می‌توانیم با `cargo build` پروژه را بسازیم.
- می‌توانیم با `cargo run` پروژه را در یک مرحله بسازیم و اجرا کنیم.
- می‌توانیم با `cargo check` پروژه را بدون تولید فایل باینری بررسی کنیم تا خطاها را پیدا کنیم.
- به‌جای ذخیره نتیجه ساخت در همان پوشه کد، Cargo آن را در پوشه `target/debug` ذخیره می‌کند.

یک مزیت اضافی استفاده از Cargo این است که دستورات آن در هر سیستم‌عاملی یکسان هستند. بنابراین، از این پس دیگر دستورات خاص برای لینوکس و مک‌او‌اس در مقابل ویندوز ارائه نمی‌کنیم.

### ساخت برای انتشار
وقتی پروژه شما بالاخره برای انتشار آماده است، می‌توانید از `cargo build --release` برای کامپایل آن با بهینه‌سازی‌ها استفاده کنید. این دستور فایل اجرایی را در `target/release` به‌جای `target/debug` ایجاد می‌کند. بهینه‌سازی‌ها باعث می‌شوند کد Rust شما سریع‌تر اجرا شود، اما فعال کردن آن‌ها زمان کامپایل برنامه را طولانی‌تر می‌کند. به همین دلیل دو پروفایل مختلف وجود دارد: یکی برای توسعه، وقتی می‌خواهید سریع و مکرر بازسازی کنید، و دیگری برای ساخت برنامه نهایی که به کاربر می‌دهید، که بارها بازسازی نمی‌شود و باید تا حد ممکن سریع اجرا شود. اگر در حال محک‌زدن زمان اجرای کد خود هستید، حتماً `cargo build --release` را اجرا کنید و با فایل اجرایی در `target/release` محک بزنید.

### Cargo به‌عنوان یک قرارداد
در پروژه‌های ساده، Cargo ارزش زیادی نسبت به استفاده مستقیم از `rustc` اضافه نمی‌کند، اما با پیچیده‌تر شدن برنامه‌هایتان ارزش خود را نشان می‌دهد. وقتی برنامه‌ها به چندین فایل یا نیاز به وابستگی گسترش می‌یابند، اجازه دادن به Cargo برای هماهنگی ساخت بسیار آسان‌تر است.

گرچه پروژه `hello_cargo` ساده است، اما اکنون از بسیاری از ابزارهای واقعی که در ادامه مسیر Rust خود استفاده خواهید کرد، بهره می‌برد. در واقع، برای کار روی هر پروژه موجود، می‌توانید از دستورات زیر استفاده کنید تا کد را با Git دریافت کنید، به پوشه پروژه بروید و بسازید:

```bash
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

برای اطلاعات بیشتر درباره Cargo، مستندات آن را بررسی کنید.

### خلاصه
شما شروع بسیار خوبی در سفر Rust خود داشته‌اید! در این فصل، آموختید چگونه:

- آخرین نسخه پایدار Rust را با استفاده از `rustup` نصب کنید
- به نسخه جدیدتر Rust به‌روزرسانی کنید
- مستندات نصب‌شده محلی را باز کنید
- برنامه «Hello, world!» را مستقیماً با `rustc` بنویسید و اجرا کنید
- پروژه‌ای جدید با قراردادهای Cargo ایجاد و اجرا کنید

اکنون زمان خوبی است که برنامه‌ای بزرگ‌تر بسازید تا به خواندن و نوشتن کد Rust عادت کنید. بنابراین، در فصل دوم، یک برنامه بازی حدس‌زدن خواهیم ساخت. اگر ترجیح می‌دهید ابتدا نحوه کار مفاهیم برنامه‌نویسی رایج در Rust را یاد بگیرید، به فصل سوم بروید و سپس به فصل دوم برگردید.

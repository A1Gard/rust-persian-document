## متغیرها و تغییرپذیری

همان‌طور که در بخش «ذخیره مقادیر با متغیرها» ذکر شد، به‌طور پیش‌فرض، متغیرها در Rust غیرقابل‌تغییر (immutable) هستند. این یکی از تشویق‌های Rust است تا کد خود را به روشی بنویسید که از ایمنی و هم‌زمانی آسان ارائه‌شده توسط Rust بهره ببرد. با این حال، شما همچنان گزینه‌ای برای قابل‌تغییر (mutable) کردن متغیرهای خود دارید. بیایید بررسی کنیم که چگونه و چرا Rust شما را به ترجیح غیرقابل‌تغییر بودن تشویق می‌کند و چرا گاهی ممکن است بخواهید از این گزینه صرف‌نظر کنید.

وقتی یک متغیر غیرقابل‌تغییر است، پس از اینکه مقداری به یک نام متصل شد، نمی‌توانید آن مقدار را تغییر دهید. برای نشان دادن این موضوع، یک پروژه جدید به نام `variables` در پوشه `projects` خود با استفاده از `cargo new variables` ایجاد کنید.

سپس، در پوشه جدید `variables`، فایل `src/main.rs` را باز کنید و کد آن را با کد زیر جایگزین کنید، که هنوز کامپایل نمی‌شود:

**نام فایل:** `src/main.rs`

**این کد کامپایل نمی‌شود!**

```rust
fn main() {
    let x = 5;
    println!("مقدار x برابر است با: {x}");
    x = 6;
    println!("مقدار x برابر است با: {x}");
}
```

فایل را ذخیره کنید و برنامه را با استفاده از `cargo run` اجرا کنید. باید یک پیام خطا درباره خطای غیرقابل‌تغییر بودن دریافت کنید، همان‌طور که در این خروجی نشان داده شده است:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("مقدار x برابر است با: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

این مثال نشان می‌دهد که چگونه کامپایلر به شما کمک می‌کند خطاها را در برنامه‌های خود پیدا کنید. خطاهای کامپایلر می‌توانند ناامیدکننده باشند، اما در واقع فقط به این معنی هستند که برنامه شما هنوز به‌طور ایمن آنچه می‌خواهید انجام دهد را انجام نمی‌دهد؛ آن‌ها به این معنی نیستند که شما برنامه‌نویس خوبی نیستید! حتی Rustaceanهای باتجربه همچنان خطاهای کامپایلر دریافت می‌کنند.

شما پیام خطای `cannot assign twice to immutable variable `x`` را دریافت کردید زیرا سعی کردید مقدار دومی را به متغیر غیرقابل‌تغییر `x` اختصاص دهید.

این مهم است که وقتی سعی می‌کنیم مقداری را که به‌عنوان غیرقابل‌تغییر مشخص شده تغییر دهیم، خطاهای زمان کامپایل دریافت کنیم، زیرا این موقعیت دقیقاً می‌تواند به باگ‌هایی منجر شود. اگر بخشی از کد ما فرض کند که یک مقدار هرگز تغییر نمی‌کند و بخش دیگری از کد آن مقدار را تغییر دهد، ممکن است بخش اول کد کاری که برای آن طراحی شده را انجام ندهد. ردیابی دلیل این نوع باگ پس از وقوع می‌تواند دشوار باشد، به‌ویژه وقتی بخش دوم کد فقط گاهی مقدار را تغییر می‌دهد. کامپایلر Rust تضمین می‌کند که وقتی شما اعلام می‌کنید مقداری تغییر نمی‌کند، واقعاً تغییر نخواهد کرد، بنابراین نیازی به ردیابی آن به‌صورت دستی ندارید. در نتیجه، کد شما آسان‌تر قابل‌فهم خواهد بود.

اما تغییرپذیری می‌تواند بسیار مفید باشد و می‌تواند نوشتن کد را راحت‌تر کند. گرچه متغیرها به‌طور پیش‌فرض غیرقابل‌تغییر هستند، می‌توانید با افزودن `mut` قبل از نام متغیر، همان‌طور که در فصل دوم انجام دادید، آن‌ها را قابل‌تغییر کنید. افزودن `mut` همچنین به خوانندگان آینده کد نیت شما را منتقل می‌کند، با نشان دادن اینکه بخش‌های دیگر کد مقدار این متغیر را تغییر خواهند داد.

برای مثال، بیایید `src/main.rs` را به کد زیر تغییر دهیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let mut x = 5;
    println!("مقدار x برابر است با: {x}");
    x = 6;
    println!("مقدار x برابر است با: {x}");
}
```

وقتی حالا برنامه را اجرا کنیم، این را دریافت می‌کنیم:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
مقدار x برابر است با: 5
مقدار x برابر است با: 6
```

وقتی از `mut` استفاده می‌کنیم، اجازه داریم مقدار متصل به `x` را از ۵ به ۶ تغییر دهیم. در نهایت، تصمیم‌گیری درباره استفاده یا عدم استفاده از تغییرپذیری به شما بستگی دارد و به این بستگی دارد که در آن موقعیت خاص چه چیزی را واضح‌تر می‌دانید.

### ثابت‌ها

مانند متغیرهای غیرقابل‌تغییر، ثابت‌ها (constants) مقادیری هستند که به یک نام متصل می‌شوند و اجازه تغییر ندارند، اما چند تفاوت بین ثابت‌ها و متغیرها وجود دارد.

اول، اجازه ندارید از `mut` با ثابت‌ها استفاده کنید. ثابت‌ها نه‌تنها به‌طور پیش‌فرض غیرقابل‌تغییر هستند—آن‌ها همیشه غیرقابل‌تغییرند. شما ثابت‌ها را با استفاده از کلیدواژه `const` به‌جای کلیدواژه `let` اعلان می‌کنید، و نوع مقدار باید حاشیه‌نویسی (annotated) شود. ما نوع‌ها و حاشیه‌نویسی نوع را در بخش بعدی، «نوع‌های داده»، پوشش خواهیم داد، بنابراین فعلاً نگران جزئیات نباشید. فقط بدانید که همیشه باید نوع را حاشیه‌نویسی کنید.

ثابت‌ها می‌توانند در هر محدوده‌ای، از جمله محدوده جهانی، اعلان شوند، که آن‌ها را برای مقادیری که بخش‌های زیادی از کد نیاز به دانستن آن‌ها دارند مفید می‌کند.

آخرین تفاوت این است که ثابت‌ها فقط می‌توانند به یک عبارت ثابت تنظیم شوند، نه نتیجه مقداری که فقط در زمان اجرا محاسبه می‌شود.

اینجا یک مثال از اعلان ثابت است:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

نام ثابت `THREE_HOURS_IN_SECONDS` است و مقدار آن نتیجه ضرب ۶۰ (تعداد ثانیه‌ها در یک دقیقه) در ۶۰ (تعداد دقیقه‌ها در یک ساعت) در ۳ (تعداد ساعت‌هایی که می‌خواهیم در این برنامه بشماریم) تنظیم شده است. قرارداد نام‌گذاری Rust برای ثابت‌ها استفاده از حروف بزرگ با زیرخط بین کلمات است. کامپایلر قادر است مجموعه محدودی از عملیات را در زمان کامپایل ارزیابی کند، که به ما امکان می‌دهد این مقدار را به روشی بنویسیم که درک و تأیید آن آسان‌تر باشد، به‌جای اینکه این ثابت را به مقدار ۱۰۸۰۰ تنظیم کنیم. برای اطلاعات بیشتر درباره عملیاتی که می‌توان هنگام اعلان ثابت‌ها استفاده کرد، به بخش ارزیابی ثابت در مرجع Rust مراجعه کنید.

**توضیح اضافی:** ثابت‌ها در Rust برای مقادیر غیرقابل‌تغییری استفاده می‌شوند که در زمان کامپایل شناخته شده‌اند، مانند تنظیمات پیکربندی یا مقادیر ریاضی ثابت.

ثابت‌ها در تمام مدت اجرای برنامه، در محدوده‌ای که اعلان شده‌اند، معتبر هستند. این ویژگی ثابت‌ها را برای مقادیر در حوزه کاربرد شما که بخش‌های مختلف برنامه ممکن است نیاز به دانستن آن‌ها داشته باشند، مانند حداکثر تعداد امتیازهایی که هر بازیکن در یک بازی می‌تواند کسب کند، یا سرعت نور، مفید می‌کند.

نام‌گذاری مقادیر سخت‌کدنشده‌ای که در سراسر برنامه استفاده می‌شوند به‌عنوان ثابت‌ها در انتقال معنای آن مقدار به نگهدارندگان آینده کد مفید است. همچنین کمک می‌کند که فقط یک مکان در کد خود داشته باشید که اگر مقدار سخت‌کدنشده نیاز به به‌روزرسانی در آینده داشت، باید تغییر کند.

### سایه‌زدن

همان‌طور که در آموزش بازی حدس در فصل دوم دیدید، می‌توانید یک متغیر جدید با همان نام یک متغیر قبلی اعلان کنید. Rustaceanها می‌گویند که متغیر اول توسط متغیر دوم سایه‌زده (shadowed) می‌شود، به این معنی که وقتی از نام متغیر استفاده می‌کنید، متغیر دوم چیزی است که کامپایلر خواهد دید. در واقع، متغیر دوم متغیر اول را تحت‌الشعاع قرار می‌دهد و هر استفاده از نام متغیر را به خود اختصاص می‌دهد تا زمانی که خودش سایه‌زده شود یا محدوده پایان یابد. ما می‌توانیم یک متغیر را با استفاده از همان نام متغیر و تکرار استفاده از کلیدواژه `let` سایه بزنیم، به این صورت:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("مقدار x در محدوده داخلی برابر است با: {x}");
    }

    println!("مقدار x برابر است با: {x}");
}
```

این برنامه ابتدا `x` را به مقدار ۵ متصل می‌کند. سپس با تکرار `let x =` یک متغیر جدید `x` ایجاد می‌کند، مقدار اصلی را می‌گیرد و ۱ به آن اضافه می‌کند، بنابراین مقدار `x` حالا ۶ است. سپس، در یک محدوده داخلی که با کروشه‌ها ایجاد شده، عبارت `let` سوم نیز `x` را سایه می‌زند و یک متغیر جدید ایجاد می‌کند، مقدار قبلی را در ۲ ضرب می‌کند تا `x` مقدار ۱۲ داشته باشد. وقتی آن محدوده تمام می‌شود، سایه‌زدن داخلی پایان می‌یابد و `x` به ۶ برمی‌گردد. وقتی این برنامه را اجرا کنیم، خروجی زیر را خواهد داشت:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
مقدار x در محدوده داخلی برابر است با: 12
مقدار x برابر است با: 6
```

سایه‌زدن با علامت‌گذاری یک متغیر به‌عنوان `mut` متفاوت است، زیرا اگر به‌طور تصادفی سعی کنیم بدون استفاده از کلیدواژه `let` به این متغیر دوباره مقدار اختصاص دهیم، یک خطای زمان کامپایل دریافت خواهیم کرد. با استفاده از `let`، می‌توانیم چند تبدیل روی یک مقدار انجام دهیم اما پس از اتمام این تبدیل‌ها، متغیر غیرقابل‌تغییر باقی بماند.

تفاوت دیگر بین `mut` و سایه‌زدن این است که چون وقتی دوباره از کلیدواژه `let` استفاده می‌کنیم، به‌طور مؤثر یک متغیر جدید ایجاد می‌کنیم، می‌توانیم نوع مقدار را تغییر دهیم اما از همان نام استفاده کنیم. برای مثال، فرض کنید برنامه ما از کاربر می‌خواهد تعداد فاصله‌هایی که بین متن می‌خواهد را با وارد کردن کاراکترهای فاصله نشان دهد، و سپس می‌خواهیم آن ورودی را به‌عنوان یک عدد ذخیره کنیم:

```rust
    let spaces = "   ";
    let spaces = spaces.len();
```

متغیر `spaces` اول یک نوع رشته‌ای است و متغیر `spaces` دوم یک نوع عددی است. سایه‌زدن ما را از نیاز به ابداع نام‌های مختلف، مانند `spaces_str` و `spaces_num`، نجات می‌دهد؛ در عوض، می‌توانیم از نام ساده‌تر `spaces` دوباره استفاده کنیم. اما اگر سعی کنیم از `mut` برای این کار استفاده کنیم، همان‌طور که اینجا نشان داده شده، یک خطای زمان کامپایل دریافت خواهیم کرد:

**این کد کامپایل نمی‌شود!**

```rust
    let mut spaces = "   ";
    spaces = spaces.len();
```

خطا می‌گوید که اجازه نداریم نوع یک متغیر را تغییر دهیم:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
```

**توضیح اضافی:** خطای `E0308` به دلیل تلاش برای اختصاص مقداری از نوع `usize` (نوع عددی برای طول رشته) به متغیری است که قبلاً به‌عنوان `&str` (نوع رشته) تعریف شده است. Rust تغییر نوع متغیرهای `mut` را مجاز نمی‌داند، اما سایه‌زدن این مشکل را با ایجاد یک متغیر جدید حل می‌کند.

حالا که بررسی کردیم متغیرها چگونه کار می‌کنند، بیایید به نوع‌های داده‌ای بیشتری که می‌توانند داشته باشند نگاه کنیم.

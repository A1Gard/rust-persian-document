
# استریم‌ها: Futureها به‌صورت متوالی

تاکنون در این فصل، بیشتر به Futureهای فردی پرداخته‌ایم. استثنای بزرگ، کانال غیرهمزمانی بود که استفاده کردیم. به یاد بیاورید که چگونه در بخش «پیام‌رسانی» در این فصل، از گیرنده (receiver) کانال غیرهمزمان استفاده کردیم. متد غیرهمزمان `recv` دنباله‌ای از آیتم‌ها را در طول زمان تولید می‌کند. این نمونه‌ای از یک الگوی عمومی‌تر به نام **استریم** (stream) است.

ما دنباله‌ای از آیتم‌ها را در فصل سیزدهم دیدیم، وقتی به ویژگی `Iterator` در بخش «ویژگی Iterator و متد next» نگاه کردیم، اما دو تفاوت بین تکرارکننده‌ها (iterators) و گیرنده کانال غیرهمزمان وجود دارد. تفاوت اول زمان است: تکرارکننده‌ها همزمان (synchronous) هستند، در حالی که گیرنده کانال غیرهمزمان است. تفاوت دوم API است. هنگام کار مستقیم با `Iterator`، متد همزمان `next` آن را فراخوانی می‌کنیم. اما با استریم `trpl::Receiver` به‌ویژه، به جای آن متد غیرهمزمان `recv` را فراخوانی کردیم. در غیر این صورت، این APIها بسیار شبیه به هم احساس می‌شوند، و این شباهت تصادفی نیست. یک استریم مانند یک فرم غیرهمزمان از تکرار است. در حالی که `trpl::Receiver` به‌طور خاص منتظر دریافت پیام‌ها می‌ماند، API استریم عمومی بسیار گسترده‌تر است: آیتم بعدی را همان‌طور که `Iterator` انجام می‌دهد ارائه می‌دهد، اما به‌صورت غیرهمزمان.

شباهت بین تکرارکننده‌ها و استریم‌ها در Rust به این معناست که ما می‌توانیم از هر تکرارکننده‌ای یک استریم ایجاد کنیم. مانند یک تکرارکننده، می‌توانیم با یک استریم کار کنیم با فراخوانی متد `next` آن و سپس انتظار خروجی، همان‌طور که در Listing 17-30 نشان داده شده است.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let iter = values.iter().map(|n| n * 2);
let mut stream = trpl::stream_from_iter(iter);

while let Some(value) = stream.next().await {
    println!("مقدار برابر بود با: {value}"); // The value was: {value}
}
```

**Listing 17-30: ایجاد یک استریم از یک تکرارکننده و چاپ مقادیر آن**

ما با یک آرایه از اعداد شروع می‌کنیم، که آن را به یک تکرارکننده تبدیل می‌کنیم و سپس `map` را روی آن فراخوانی می‌کنیم تا همه مقادیر را دو برابر کنیم. سپس تکرارکننده را با استفاده از تابع `trpl::stream_from_iter` به یک استریم تبدیل می‌کنیم. در ادامه، با استفاده از حلقه `while let` روی آیتم‌های استریم به محض رسیدنشان پیمایش می‌کنیم.

متأسفانه، وقتی سعی می‌کنیم کد را اجرا کنیم، کامپایل نمی‌شود، بلکه گزارش می‌دهد که متد `next` در دسترس نیست:

```
error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --> src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async-await/target/debug/deps/async_await-575db3dd3197d257.long-type-14490787947592691573.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
```

همان‌طور که این خروجی توضیح می‌دهد، دلیل خطای کامپایلر این است که برای استفاده از متد `next` نیاز به وارد کردن ویژگی مناسب در حوزه (scope) داریم. با توجه به بحث ما تا اینجا، ممکن است به‌طور منطقی انتظار داشته باشید که این ویژگی `Stream` باشد، اما در واقع `StreamExt` است. مخفف extension، `Ext` یک الگوی رایج در جامعه Rust برای گسترش یک ویژگی با ویژگی دیگر است.

ما ویژگی‌های `Stream` و `StreamExt` را کمی بعد در این فصل با جزئیات بیشتری توضیح خواهیم داد، اما فعلاً فقط باید بدانید که ویژگی `Stream` یک رابط سطح پایین را تعریف می‌کند که به‌طور مؤثر ویژگی‌های `Iterator` و `Future` را ترکیب می‌کند. `StreamExt` مجموعه‌ای از APIهای سطح بالاتر را روی `Stream` ارائه می‌دهد، از جمله متد `next` و همچنین سایر متدهای کاربردی مشابه آن‌هایی که توسط ویژگی `Iterator` ارائه شده‌اند. `Stream` و `StreamExt` هنوز بخشی از کتابخانه استاندارد Rust نیستند، اما اکثر کریت‌های اکوسیستم از تعریف یکسانی استفاده می‌کنند.

رفع خطای کامپایلر اضافه کردن یک عبارت `use` برای `trpl::StreamExt` است، همان‌طور که در Listing 17-31 نشان داده شده است.

**فایل: src/main.rs**

```rust
use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("مقدار برابر بود با: {value}"); // The value was: {value}
        }
    });
}
```

**Listing 17-31: استفاده موفقیت‌آمیز از یک تکرارکننده به‌عنوان پایه یک استریم**

با کنار هم قرار دادن همه این قطعات، این کد همان‌طور که می‌خواهیم کار می‌کند! علاوه بر این، حالا که `StreamExt` را در حوزه داریم، می‌توانیم از همه متدهای کاربردی آن استفاده کنیم، درست مانند تکرارکننده‌ها. برای مثال، در Listing 17-32، از متد `filter` برای فیلتر کردن همه چیز به جز مضرب‌های سه و پنج استفاده می‌کنیم.

**فایل: src/main.rs**

```rust
use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("مقدار برابر بود با: {value}"); // The value was: {value}
        }
    });
}
```

**Listing 17-32: فیلتر کردن یک استریم با متد StreamExt::filter**

البته، این خیلی جالب نیست، زیرا می‌توانستیم همین کار را با تکرارکننده‌های معمولی و بدون هیچ غیرهمزمانی انجام دهیم. بیایید ببینیم چه کاری می‌توانیم انجام دهیم که مختص استریم‌ها باشد.

## ترکیب استریم‌ها

بسیاری از مفاهیم به‌طور طبیعی به‌عنوان استریم نمایش داده می‌شوند: آیتم‌هایی که در یک صف در دسترس قرار می‌گیرند، تکه‌های داده‌ای که به‌صورت تدریجی از فایل‌سیستم کشیده می‌شوند وقتی مجموعه داده کامل برای حافظه کامپیوتر بیش از حد بزرگ است، یا داده‌هایی که در طول زمان از طریق شبکه می‌رسند. چون استریم‌ها Future هستند، می‌توانیم آن‌ها را با هر نوع Future دیگری استفاده کنیم و به روش‌های جالبی ترکیب کنیم. برای مثال، می‌توانیم رویدادها را دسته‌بندی کنیم تا از فراخوانی‌های شبکه‌ای بیش از حد جلوگیری کنیم، تایم‌اوت‌هایی روی دنباله‌ای از عملیات‌های طولانی‌مدت تنظیم کنیم، یا رویدادهای رابط کاربری را محدود کنیم تا از انجام کارهای غیرضروری جلوگیری کنیم.

بیایید با ساخت یک استریم کوچک از پیام‌ها شروع کنیم به‌عنوان جایگزینی برای یک استریم داده‌ای که ممکن است از یک WebSocket یا پروتکل ارتباطی بلادرنگ دیگر ببینیم، همان‌طور که در Listing 17-33 نشان داده شده است.

**فایل: src/main.rs**

```rust
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("پیام: '{message}'")).unwrap(); // Message: '{message}'
    }

    ReceiverStream::new(rx)
}
```

**Listing 17-33: استفاده از گیرنده rx به‌عنوان یک ReceiverStream**

ابتدا، تابعی به نام `get_messages` ایجاد می‌کنیم که `impl Stream<Item = String>` را برمی‌گرداند. برای پیاده‌سازی آن، یک کانال غیرهمزمان ایجاد می‌کنیم، روی 10 حرف اول الفبای انگلیسی پیمایش می‌کنیم و آن‌ها را از طریق کانال ارسال می‌کنیم.

ما همچنین از یک نوع جدید استفاده می‌کنیم: `ReceiverStream`، که گیرنده `rx` از `trpl::channel` را به یک `Stream` با متد `next` تبدیل می‌کند. در `main`، از یک حلقه `while let` برای چاپ همه پیام‌ها از استریم استفاده می‌کنیم.

وقتی این کد را اجرا می‌کنیم، دقیقاً نتایجی را که انتظار داشتیم دریافت می‌کنیم:

```
Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
```

باز هم، می‌توانستیم این کار را با API معمولی `Receiver` یا حتی API معمولی `Iterator` انجام دهیم، بنابراین بیایید یک ویژگی اضافه کنیم که به استریم‌ها نیاز دارد: افزودن یک تایم‌اوت که برای هر آیتم در استریم اعمال می‌شود، و یک تأخیر روی آیتم‌هایی که منتشر می‌کنیم، همان‌طور که در Listing 17-34 نشان داده شده است.

**فایل: src/main.rs**

```rust
use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) => println!("{message}"),
                Err(reason) => eprintln!("مشکل: {reason:?}"), // Problem: {reason:?}
            }
        }
    })
}
```

**Listing 17-34: استفاده از متد StreamExt::timeout برای تنظیم محدودیت زمانی روی آیتم‌های استریم**

ما با افزودن یک تایم‌اوت به استریم با متد `timeout` که از ویژگی `StreamExt` می‌آید شروع می‌کنیم. سپس بدنه حلقه `while let` را به‌روزرسانی می‌کنیم، زیرا استریم حالا یک `Result` برمی‌گرداند. نوع `Ok` نشان می‌دهد که پیام به موقع رسیده است؛ نوع `Err` نشان می‌دهد که تایم‌اوت قبل از رسیدن هر پیامی به پایان رسیده است. ما روی آن نتیجه تطبیق می‌کنیم و یا پیام را وقتی با موفقیت دریافت می‌کنیم چاپ می‌کنیم یا اعلانی درباره تایم‌اوت چاپ می‌کنیم. در نهایت، توجه کنید که ما `messages` را پس از اعمال تایم‌اوت روی آن‌ها پین می‌کنیم، زیرا دستیار `timeout` یک استریم تولید می‌کند که برای نظرسنجی نیاز به پین شدن دارد.

با این حال، چون هیچ تأخیری بین پیام‌ها وجود ندارد، این تایم‌اوت رفتار برنامه را تغییر نمی‌دهد. بیایید یک تأخیر متغیر به پیام‌هایی که ارسال می‌کنیم اضافه کنیم، همان‌طور که در Listing 17-35 نشان داده شده است.

**فایل: src/main.rs**

```rust
fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("پیام: '{message}'")).unwrap(); // Message: '{message}'
        }
    });

    ReceiverStream::new(rx)
}
```

**Listing 17-35: ارسال پیام‌ها از طریق tx با تأخیر غیرهمزمان بدون تبدیل get_messages به یک تابع غیرهمزمان**

در `get_messages`، از متد تکرارکننده `enumerate` با آرایه `messages` استفاده می‌کنیم تا بتوانیم اندیس هر آیتمی که ارسال می‌کنیم را همراه با خود آیتم دریافت کنیم. سپس یک تأخیر 100 میلی‌ثانیه‌ای به آیتم‌های با اندیس زوج و یک تأخیر 300 میلی‌ثانیه‌ای به آیتم‌های با اندیس فرد اعمال می‌کنیم تا تأخیرهای متفاوتی را که ممکن است در دنیای واقعی از یک استریم پیام‌ها ببینیم شبیه‌سازی کنیم. چون تایم‌اوت ما 200 میلی‌ثانیه است، این باید روی نیمی از پیام‌ها تأثیر بگذارد.

برای خوابیدن بین پیام‌ها در تابع `get_messages` بدون مسدود کردن، نیاز به استفاده از غیرهمزمان داریم. با این حال، نمی‌توانیم خود `get_messages` را به یک تابع غیرهمزمان تبدیل کنیم، زیرا در این صورت به جای `Stream<Item = String>>`، یک `Future<Output = Stream<Item = String>>` برمی‌گردانیم. فراخواننده باید خود `get_messages` را `await` کند تا به استریم دسترسی پیدا کند. اما به یاد داشته باشید: همه چیز در یک Future داده‌شده به‌صورت خطی اتفاق می‌افتد؛ همزمانی بین Futureها رخ می‌دهد. انتظار `get_messages` نیاز دارد که همه پیام‌ها را، از جمله تأخیر خواب بین هر پیام، قبل از بازگشت استریم گیرنده ارسال کند. در نتیجه، تایم‌اوت بی‌فایده خواهد بود. هیچ تأخیری در خود استریم وجود نخواهد داشت؛ همه آن‌ها قبل از اینکه استریم حتی در دسترس باشد اتفاق می‌افتند.

در عوض، `get_messages` را به‌عنوان یک تابع معمولی که یک استریم برمی‌گرداند نگه می‌داریم، و یک وظیفه (task) را برای مدیریت فراخوانی‌های خواب غیرهمزمان ایجاد می‌کنیم.

> **توجه**: فراخوانی `spawn_task` به این روش کار می‌کند چون ما قبلاً زمان‌اجرای خود را راه‌اندازی کرده‌ایم؛ اگر این کار را نکرده بودیم، باعث پنیک می‌شد. پیاده‌سازی‌های دیگر تعادل‌های متفاوتی را انتخاب می‌کنند: ممکن است یک زمان‌اجرای جدید ایجاد کنند و از پنیک جلوگیری کنند اما با کمی سربار اضافی مواجه شوند، یا ممکن است به‌سادگی راهی مستقل برای ایجاد وظایف بدون ارجاع به یک زمان‌اجرا ارائه ندهند. مطمئن شوید که می‌دانید زمان‌اجرای شما کدام تعادل را انتخاب کرده است و کد خود را مطابق با آن بنویسید!

حالا کد ما نتیجه بسیار جالب‌تری دارد. بین هر جفت پیام، یک خطای `Problem: Elapsed(())` ظاهر می‌شود:

```
Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
```

تایم‌اوت مانع رسیدن پیام‌ها در نهایت نمی‌شود. ما همچنان همه پیام‌های اصلی را دریافت می‌کنیم، زیرا کانال ما نامحدود است: می‌تواند به اندازه‌ای که در حافظه جا می‌شود پیام نگه دارد. اگر پیام قبل از تایم‌اوت نرسد، مدیریت‌کننده استریم ما این را در نظر می‌گیرد، اما وقتی دوباره استریم را نظرسنجی می‌کند، پیام ممکن است حالا رسیده باشد.

اگر نیاز باشد، می‌توانید با استفاده از انواع دیگر کانال‌ها یا به‌طور کلی انواع دیگر استریم‌ها رفتار متفاوتی دریافت کنید. بیایید یکی از این‌ها را در عمل ببینیم با ترکیب یک استریم از بازه‌های زمانی با این استریم پیام‌ها.

## ادغام استریم‌ها

ابتدا، بیایید یک استریم دیگر ایجاد کنیم که اگر مستقیماً اجرا شود، هر میلی‌ثانیه یک آیتم منتشر می‌کند. برای سادگی، می‌توانیم از تابع `sleep` برای ارسال یک پیام با تأخیر استفاده کنیم و آن را با همان رویکردی که در `get_messages` استفاده کردیم ترکیب کنیم تا یک استریم از یک کانال ایجاد کنیم. تفاوت این است که این بار، تعداد بازه‌های سپری‌شده را برمی‌گردانیم، بنابراین نوع بازگشتی `impl Stream<Item = u32>` خواهد بود، و می‌توانیم تابع را `get_intervals` بنامیم (به Listing 17-36 نگاه کنید).

**فایل: src/main.rs**

```rust
fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}
```

**Listing 17-36: ایجاد یک استریم با یک شمارشگر که هر میلی‌ثانیه یک‌بار منتشر می‌شود**

ما با تعریف یک `count` در وظیفه شروع می‌کنیم. (می‌توانستیم آن را خارج از وظیفه هم تعریف کنیم، اما محدود کردن حوزه هر متغیر داده‌شده واضح‌تر است.) سپس یک حلقه بی‌نهایت ایجاد می‌کنیم. هر تکرار حلقه به‌صورت غیرهمزمان برای یک میلی‌ثانیه می‌خوابد، `count` را افزایش می‌دهد، و سپس آن را از طریق کانال ارسال می‌کند. چون همه این‌ها در وظیفه ایجادشده توسط `spawn_task` پیچیده شده است، همه چیز—از جمله حلقه بی‌نهایت—همراه با زمان‌اجرا پاکسازی خواهد شد.

این نوع حلقه بی‌نهایت، که فقط زمانی پایان می‌یابد که کل زمان‌اجرا تخریب شود، در Rust غیرهمزمان نسبتاً رایج است: بسیاری از برنامه‌ها نیاز دارند به‌طور نامحدود اجرا شوند. با غیرهمزمان، این هیچ چیز دیگری را مسدود نمی‌کند، به شرطی که حداقل یک نقطه `await` در هر تکرار حلقه وجود داشته باشد.

حالا، در بلوک غیرهمزمان تابع `main`، می‌توانیم سعی کنیم استریم‌های `messages` و `intervals` را ادغام کنیم، همان‌طور که در Listing 17-37 نشان داده شده است.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
let messages = get_messages().timeout(Duration::from_millis(200));
let intervals = get_intervals();
let merged = messages.merge(intervals);
```

**Listing 17-37: تلاش برای ادغام استریم‌های messages و intervals**

ما با فراخوانی `get_intervals` شروع می‌کنیم. سپس استریم‌های `messages` و `intervals` را با متد `merge` ادغام می‌کنیم، که چندین استریم را به یک استریم ترکیب می‌کند که آیتم‌ها را از هر یک از استریم‌های منبع به محض در دسترس بودن تولید می‌کند، بدون اعمال هیچ ترتیب خاصی. در نهایت، به جای پیمایش روی `messages`، روی این استریم ترکیب‌شده پیمایش می‌کنیم.

در این مرحله، نه `messages` و نه `intervals` نیاز به پین شدن یا قابل‌تغییر بودن ندارند، زیرا هر دو در استریم واحد `merged` ترکیب خواهند شد. با این حال، این فراخوانی به `merge` کامپایل نمی‌شود! (فراخوانی بعدی در حلقه `while let` هم کامپایل نمی‌شود، اما به آن بازخواهیم گشت.) این به این دلیل است که دو استریم نوع‌های متفاوتی دارند. استریم `messages` نوع `Timeout<impl Stream<Item = String>>` دارد، که `Timeout` نوع پیاده‌سازی‌کننده `Stream` برای فراخوانی تایم‌اوت است. استریم `intervals` نوع `impl Stream<Item = u32>` دارد. برای ادغام این دو استریم، باید یکی از آن‌ها را تبدیل کنیم تا با دیگری مطابقت داشته باشد. ما استریم `intervals` را بازسازی می‌کنیم، زیرا `messages` قبلاً در فرمتی اساسی است که می‌خواهیم و باید خطاهای تایم‌اوت را مدیریت کند (به Listing 17-38 نگاه کنید).

**فایل: src/main.rs**

```rust
let messages = get_messages().timeout(Duration::from_millis(200));
let intervals = get_intervals()
    .map(|count| format!("بازه: {count}")) // Interval: {count}
    .timeout(Duration::from_secs(10));
let merged = messages.merge(intervals);
let mut stream = pin!(merged);
```

**Listing 17-38: هم‌راستا کردن نوع استریم intervals با نوع استریم messages**

ابتدا، می‌توانیم از متد دستیار `map` برای تبدیل `intervals` به یک رشته استفاده کنیم. دوم، باید `Timeout` از `messages` را مطابقت دهیم. چون واقعاً برای `intervals` تایم‌اوت نمی‌خواهیم، می‌توانیم فقط یک تایم‌اوت ایجاد کنیم که طولانی‌تر از سایر مدت‌زمان‌هایی است که استفاده می‌کنیم. اینجا، یک تایم‌اوت 10 ثانیه‌ای با `Duration::from_secs(10)` ایجاد می‌کنیم. در نهایت، باید `stream` را قابل‌تغییر کنیم، تا فراخوانی‌های `next` حلقه `while let` بتوانند از طریق استریم پیمایش کنند، و آن را پین کنیم تا انجام این کار امن باشد. این ما را تقریباً به جایی که نیاز داریم می‌رساند. همه چیز از نظر نوع بررسی می‌شود. اما اگر این را اجرا کنید، دو مشکل وجود خواهد داشت. اول، هرگز متوقف نمی‌شود! باید آن را با `ctrl-c` متوقف کنید. دوم، پیام‌ها از الفبای انگلیسی در میان همه پیام‌های شمارشگر بازه غرق خواهند شد:

```
--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
```

Listing 17-39 یک راه برای حل این دو مشکل آخر را نشان می‌دهد.

**فایل: src/main.rs**

```rust
let messages = get_messages().timeout(Duration::from_millis(200));
let intervals = get_intervals()
    .map(|count| format!("بازه: {count}")) // Interval: {count}
    .throttle(Duration::from_millis(100))
    .timeout(Duration::from_secs(10));
let merged = messages.merge(intervals).take(20);
let mut stream = pin!(merged);
```

**Listing 17-39: استفاده از throttle و take برای مدیریت استریم‌های ادغام‌شده**

ابتدا، از متد `throttle` روی استریم `intervals` استفاده می‌کنیم تا استریم `messages` را تحت فشار قرار ندهد. محدود کردن (throttling) راهی برای محدود کردن نرخ فراخوانی یک تابع است—یا، در این مورد، اینکه استریم هر چند وقت یک‌بار نظرسنجی می‌شود. یک‌بار در هر 100 میلی‌ثانیه باید کافی باشد، زیرا این تقریباً همان زمانی است که پیام‌های ما می‌رسند.

برای محدود کردن تعداد آیتم‌هایی که از یک استریم قبول می‌کنیم، متد `take` را روی استریم `merged` اعمال می‌کنیم، زیرا می‌خواهیم خروجی نهایی را محدود کنیم، نه فقط یکی از استریم‌ها یا دیگری.

حالا وقتی برنامه را اجرا می‌کنیم، پس از کشیدن 20 آیتم از استریم متوقف می‌شود، و بازه‌ها پیام‌ها را تحت فشار قرار نمی‌دهند. همچنین `Interval: 100` یا `Interval: 200` و غیره دریافت نمی‌کنیم، بلکه `Interval: 1`، `Interval: 2` و غیره دریافت می‌کنیم—حتی اگر یک استریم منبع داریم که می‌تواند هر میلی‌ثانیه یک رویداد تولید کند. این به این دلیل است که فراخوانی `throttle` یک استریم جدید تولید می‌کند که استریم اصلی را می‌پیچد، به‌طوری که استریم اصلی فقط با نرخ محدود شده نظرسنجی می‌شود، نه با نرخ «بومی» خودش. ما تعداد زیادی پیام بازه نادیده‌گرفته‌شده نداریم. در عوض، اصلاً آن پیام‌های بازه را تولید نمی‌کنیم! این دوباره **تنبلی** ذاتی Futureهای Rust در کار است، که به ما امکان می‌دهد ویژگی‌های عملکردی خود را انتخاب کنیم.

```
Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
```

یک چیز آخر وجود دارد که باید مدیریت کنیم: خطاها! با هر دو این استریم‌های مبتنی بر کانال، فراخوانی‌های `send` می‌توانند وقتی طرف دیگر کانال بسته می‌شود شکست بخورند—و این فقط به نحوه اجرای Futureهایی که استریم را تشکیل می‌دهند توسط زمان‌اجرا بستگی دارد. تا حالا، ما این احتمال را با فراخوانی `unwrap` نادیده گرفته‌ایم، اما در یک برنامه خوش‌رفتار، باید خطا را به‌طور صریح مدیریت کنیم، حداقل با پایان دادن به حلقه تا دیگر سعی نکنیم پیام‌های بیشتری ارسال کنیم. Listing 17-40 یک استراتژی خطای ساده را نشان می‌دهد: چاپ مشکل و سپس شکستن حلقه‌ها.

**فایل: src/main.rs**

```rust
fn get_messages() -> impl Stream<Item = String> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("پیام: '{message}'")) { // Message: '{message}'
                eprintln!("نمی‌توان پیام '{message}' را ارسال کرد: {send_error}"); // Cannot send message '{message}': {send_error}
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -> impl Stream<Item = u32> {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("نمی‌توان بازه {count} را ارسال کرد: {send_error}"); // Could not send interval {count}: {send_error}
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}
```

**Listing 17-40: مدیریت خطاها و خاموش کردن حلقه‌ها**

مانند همیشه، راه درست برای مدیریت یک خطای ارسال پیام متفاوت خواهد بود؛ فقط مطمئن شوید که یک استراتژی دارید.

حالا که ما مقدار زیادی غیرهمزمان را در عمل دیده‌ایم، بیایید یک قدم به عقب برداریم و کمی در جزئیات نحوه کار `Future`، `Stream`، و سایر ویژگی‌های کلیدی که Rust برای کار غیرهمزمان استفاده می‌کند کاوش کنیم.
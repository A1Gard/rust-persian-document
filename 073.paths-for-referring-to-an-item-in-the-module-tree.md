## مسیرها برای ارجاع به یک مورد در درخت ماژول

برای نشان دادن اینکه Rust کجا باید یک مورد را در درخت ماژول پیدا کند، از یک **مسیر (path)** استفاده می‌کنیم، مشابه روشی که در پیمایش یک فایل‌سیستم از مسیر استفاده می‌کنیم. برای فراخوانی یک تابع، باید مسیر آن را بدانیم.

یک مسیر می‌تواند به یکی از دو شکل باشد:

- **مسیر مطلق (absolute path):** مسیر کامل که از ریشه جعبه شروع می‌شود؛ برای کد از یک جعبه خارجی، مسیر مطلق با نام جعبه شروع می‌شود، و برای کد از جعبه فعلی، با کلمه‌کلیدی `crate` آغاز می‌شود.
- **مسیر نسبی (relative path):** از ماژول فعلی شروع می‌شود و از `self`، `super`، یا یک شناسه در ماژول فعلی استفاده می‌کند.

هر دو مسیر مطلق و نسبی با یک یا چند شناسه که با دو نقطه (`::`) از هم جدا شده‌اند، ادامه می‌یابند.

برگردیم به لیست ۷-۱، فرض کنید می‌خواهیم تابع `add_to_waitlist` را فراخوانی کنیم. این مثل این است که بپرسیم: مسیر تابع `add_to_waitlist` چیست؟ لیست ۷-۳ نسخه‌ای از لیست ۷-۱ را با حذف برخی ماژول‌ها و توابع نشان می‌دهد.

ما دو روش برای فراخوانی تابع `add_to_waitlist` از یک تابع جدید به نام `eat_at_restaurant` که در ریشه جعبه تعریف شده، نشان خواهیم داد. این مسیرها درست هستند، اما مشکلی باقی مانده که باعث می‌شود این مثال همان‌طور که هست کامپایل نشود. کمی بعد توضیح می‌دهیم چرا.

تابع `eat_at_restaurant` بخشی از API عمومی جعبه کتابخانه‌ای ماست، بنابراین آن را با کلمه‌کلیدی `pub` علامت‌گذاری می‌کنیم. در بخش «آشکار کردن مسیرها با کلمه‌کلیدی `pub`»، جزئیات بیشتری درباره `pub` خواهیم گفت.

**نام فایل:** `src/lib.rs`

**این کد کامپایل نمی‌شود!**

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // مسیر مطلق
    crate::front_of_house::hosting::add_to_waitlist();

    // مسیر نسبی
    front_of_house::hosting::add_to_waitlist();
}
```

**لیست ۷-۳:** فراخوانی تابع `add_to_waitlist` با استفاده از مسیرهای مطلق و نسبی

اولین باری که تابع `add_to_waitlist` را در `eat_at_restaurant` فراخوانی می‌کنیم، از یک مسیر مطلق استفاده می‌کنیم. تابع `add_to_waitlist` در همان جعبه‌ای تعریف شده که `eat_at_restaurant` در آن است، به این معنی که می‌توانیم از کلمه‌کلیدی `crate` برای شروع یک مسیر مطلق استفاده کنیم. سپس هر یک از ماژول‌های متوالی را شامل می‌کنیم تا به `add_to_waitlist` برسیم. می‌توانید یک فایل‌سیستم با همین ساختار را تصور کنید: ما مسیر `/front_of_house/hosting/add_to_waitlist` را برای اجرای برنامه `add_to_waitlist` مشخص می‌کنیم؛ استفاده از نام جعبه برای شروع از ریشه جعبه مانند استفاده از `/` برای شروع از ریشه فایل‌سیستم در شل شما است.

دومین باری که `add_to_waitlist` را در `eat_at_restaurant` فراخوانی می‌کنیم، از یک مسیر نسبی استفاده می‌کنیم. مسیر با `front_of_house` شروع می‌شود، نامی که برای ماژولی تعریف‌شده در همان سطح درخت ماژول با `eat_at_restaurant` است. معادل فایل‌سیستم اینجا استفاده از مسیر `front_of_house/hosting/add_to_waitlist` خواهد بود. شروع با نام یک ماژول به این معناست که مسیر نسبی است.

انتخاب بین استفاده از مسیر نسبی یا مطلق تصمیمی است که بر اساس پروژه خود می‌گیرید و بستگی به این دارد که آیا احتمال دارد کد تعریف مورد را جدا از کد استفاده‌کننده از مورد جابه‌جا کنید یا با هم. برای مثال، اگر ماژول `front_of_house` و تابع `eat_at_restaurant` را به یک ماژول به نام `customer_experience` منتقل کنیم، باید مسیر مطلق به `add_to_waitlist` را به‌روزرسانی کنیم، اما مسیر نسبی همچنان معتبر خواهد بود. اما اگر تابع `eat_at_restaurant` را به‌تنهایی به ماژولی به نام `dining` منتقل کنیم، مسیر مطلق به فراخوانی `add_to_waitlist` همان می‌ماند، اما مسیر نسبی نیاز به به‌روزرسانی خواهد داشت. ترجیح کلی ما این است که از مسیرهای مطلق استفاده کنیم، زیرا احتمالاً می‌خواهیم تعریف‌های کد و فراخوانی‌های موارد را مستقل از یکدیگر جابه‌جا کنیم.

بیایید لیست ۷-۳ را کامپایل کنیم و ببینیم چرا هنوز کامپایل نمی‌شود! خطاهایی که دریافت می‌کنیم در لیست ۷-۴ نشان داده شده‌اند.

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: ماژول `hosting` خصوصی است
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- تابع `add_to_waitlist` به‌صورت عمومی بازصادر نشده است
  |                            |
  |                            ماژول خصوصی
  |
note: ماژول `hosting` اینجا تعریف شده است
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: ماژول `hosting` خصوصی است
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- تابع `add_to_waitlist` به‌صورت عمومی بازصادر نشده است
   |                     |
   |                     ماژول خصوصی
   |
note: ماژول `hosting` اینجا تعریف شده است
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

برای اطلاعات بیشتر درباره این خطا، `rustc --explain E0603` را امتحان کنید.
error: نتوانست جعبه `restaurant` (کتابخانه) را به دلیل 2 خطای قبلی کامپایل کند
```

**لیست ۷-۴:** خطاهای کامپایلر از ساخت کد در لیست ۷-۳

پیام‌های خطا می‌گویند که ماژول `hosting` خصوصی است. به عبارت دیگر، ما مسیرهای درستی برای ماژول `hosting` و تابع `add_to_waitlist` داریم، اما Rust به ما اجازه استفاده از آن‌ها را نمی‌دهد زیرا به بخش‌های خصوصی دسترسی ندارد. در Rust، همه موارد (توابع، متدها، ساختارها، شمارش‌ها، ماژول‌ها، و ثابت‌ها) به‌صورت پیش‌فرض نسبت به ماژول‌های والد خود خصوصی هستند. اگر بخواهید موردی مانند یک تابع یا ساختار را خصوصی کنید، آن را در یک ماژول قرار می‌دهید.

موارد در یک ماژول والد نمی‌توانند از موارد خصوصی داخل ماژول‌های فرزند استفاده کنند، اما موارد در ماژول‌های فرزند می‌توانند از موارد در ماژول‌های اجدادی خود استفاده کنند. این به این دلیل است که ماژول‌های فرزند جزئیات پیاده‌سازی خود را بسته‌بندی و پنهان می‌کنند، اما ماژول‌های فرزند می‌توانند زمینه‌ای که در آن تعریف شده‌اند را ببینند. برای ادامه دادن به استعاره‌مان، قوانین حریم خصوصی را مانند دفتر پشتی یک رستوران در نظر بگیرید: آنچه آنجا اتفاق می‌افتد برای مشتریان رستوران خصوصی است، اما مدیران دفتر می‌توانند همه چیز را در رستورانی که اداره می‌کنند ببینند و انجام دهند.

Rust تصمیم گرفته که سیستم ماژول به این شکل عمل کند تا پنهان کردن جزئیات پیاده‌سازی داخلی به‌صورت پیش‌فرض باشد. این‌گونه، شما می‌دانید که کدام بخش‌های کد داخلی را می‌توانید تغییر دهید بدون اینکه کد خارجی را خراب کنید. با این حال، Rust به شما گزینه‌ای می‌دهد تا با استفاده از کلمه‌کلیدی `pub`، بخش‌های داخلی کد ماژول‌های فرزند را برای ماژول‌های اجدادی خارجی آشکار کنید.

### آشکار کردن مسیرها با کلمه‌کلیدی `pub`

برگردیم به خطا در لیست ۷-۴ که به ما گفت ماژول `hosting` خصوصی است. ما می‌خواهیم تابع `eat_at_restaurant` در ماژول والد به تابع `add_to_waitlist` در ماژول فرزند دسترسی داشته باشد، بنابراین ماژول `hosting` را با کلمه‌کلیدی `pub` علامت‌گذاری می‌کنیم، همان‌طور که در لیست ۷-۵ نشان داده شده است.

**نام فایل:** `src/lib.rs`

**این کد کامپایل نمی‌شود!**

```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// --snip--
```

**لیست ۷-۵:** اعلان ماژول `hosting` به‌عنوان `pub` برای استفاده از آن در `eat_at_restaurant`

متأسفانه، کد در لیست ۷-۵ همچنان خطاهای کامپایلری تولید می‌کند، همان‌طور که در لیست ۷-۶ نشان داده شده است.

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: تابع `add_to_waitlist` خصوصی است
  --> src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ تابع خصوصی
   |
note: تابع `add_to_waitlist` اینجا تعریف شده است
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: تابع `add_to_waitlist` خصوصی است
  --> src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ تابع خصوصی
   |
note: تابع `add_to_waitlist` اینجا تعریف شده است
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

برای اطلاعات بیشتر درباره این خطا، `rustc --explain E0603` را امتحان کنید.
error: نتوانست جعبه `restaurant` (کتابخانه) را به دلیل 2 خطای قبلی کامپایل کند
```

**لیست ۷-۶:** خطاهای کامپایلر از ساخت کد در لیست ۷-۵

چه اتفاقی افتاد؟ افزودن کلمه‌کلیدی `pub` جلوی `mod hosting` ماژول را عمومی می‌کند. با این تغییر، اگر بتوانیم به `front_of_house` دسترسی پیدا کنیم، می‌توانیم به `hosting` هم دسترسی داشته باشیم. اما محتوای `hosting` همچنان خصوصی است؛ عمومی کردن ماژول محتوای آن را عمومی نمی‌کند. کلمه‌کلیدی `pub` روی یک ماژول فقط به کد در ماژول‌های اجدادی‌اش اجازه می‌دهد به آن ارجاع دهد، نه اینکه به کد داخلی آن دسترسی داشته باشد. چون ماژول‌ها ظرف هستند، عمومی کردن فقط ماژول کار زیادی انجام نمی‌دهد؛ باید پیش برویم و انتخاب کنیم که یک یا چند مورد داخل ماژول را هم عمومی کنیم.

خطاها در لیست ۷-۶ می‌گویند که تابع `add_to_waitlist` خصوصی است. قوانین حریم خصوصی برای ساختارها، شمارش‌ها، توابع، و متدها و همچنین ماژول‌ها اعمال می‌شوند.

بیایید تابع `add_to_waitlist` را هم با افزودن کلمه‌کلیدی `pub` قبل از تعریف آن عمومی کنیم، همان‌طور که در لیست ۷-۷ نشان داده شده است.

**نام فایل:** `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// --snip--
```

**لیست ۷-۷:** افزودن کلمه‌کلیدی `pub` به `mod hosting` و `fn add_to_waitlist` به ما اجازه می‌دهد تابع را از `eat_at_restaurant` فراخوانی کنیم

حالا کد کامپایل می‌شود! برای اینکه ببینیم چرا افزودن کلمه‌کلیدی `pub` به ما اجازه استفاده از این مسیرها در `eat_at_restaurant` را با توجه به قوانین حریم خصوصی می‌دهد، بیایید مسیرهای مطلق و نسبی را بررسی کنیم.

در مسیر مطلق، با `crate` شروع می‌کنیم، ریشه درخت ماژول جعبه‌مان. ماژول `front_of_house` در ریشه جعبه تعریف شده است. اگرچه `front_of_house` عمومی نیست، چون تابع `eat_at_restaurant` در همان ماژولی تعریف شده که `front_of_house` در آن است (یعنی `eat_at_restaurant` و `front_of_house` خواهر و برادر هستند)، می‌توانیم از `eat_at_restaurant` به `front_of_house` ارجاع دهیم. سپس ماژول `hosting` را داریم که با `pub` علامت‌گذاری شده است. ما می‌توانیم به ماژول والد `hosting` دسترسی پیدا کنیم، بنابراین می‌توانیم به `hosting` دسترسی داشته باشیم. در نهایت، تابع `add_to_waitlist` با `pub` علامت‌گذاری شده و ما می‌توانیم به ماژول والد آن دسترسی داشته باشیم، پس این فراخوانی تابع کار می‌کند!

در مسیر نسبی، منطق همان مسیر مطلق است جز در گام اول: به‌جای شروع از ریشه جعبه، مسیر از `front_of_house` شروع می‌شود. ماژول `front_of_house` در همان ماژولی تعریف شده که `eat_at_restaurant` در آن است، بنابراین مسیر نسبی که از ماژولی که `eat_at_restaurant` در آن تعریف شده شروع می‌شود، کار می‌کند. سپس، چون `hosting` و `add_to_waitlist` با `pub` علامت‌گذاری شده‌اند، بقیه مسیر کار می‌کند و این فراخوانی تابع معتبر است!

اگر قصد دارید جعبه کتابخانه‌ای خود را به اشتراک بگذارید تا پروژه‌های دیگر بتوانند از کد شما استفاده کنند، API عمومی شما قرارداد شما با کاربران جعبه‌تان است که تعیین می‌کند آن‌ها چگونه می‌توانند با کد شما تعامل داشته باشند. ملاحظات زیادی در مورد مدیریت تغییرات در API عمومی شما وجود دارد تا وابستگی به جعبه‌تان برای دیگران آسان‌تر شود. این ملاحظات خارج از محدوده این کتاب هستند؛ اگر به این موضوع علاقه‌مندید، به **دستورالعمل‌های API Rust** مراجعه کنید.

### بهترین روش‌ها برای بسته‌هایی با جعبه باینری و کتابخانه‌ای

ذکر کردیم که یک بسته می‌تواند هم شامل یک ریشه جعبه باینری `src/main.rs` و هم یک ریشه جعبه کتابخانه‌ای `src/lib.rs` باشد، و هر دو جعبه به‌صورت پیش‌فرض نام بسته را خواهند داشت. معمولاً، بسته‌هایی با این الگو که شامل هر دو جعبه کتابخانه‌ای و باینری هستند، فقط کد کافی در جعبه باینری دارند تا یک فایل اجرایی را شروع کنند که کد داخل جعبه کتابخانه‌ای را فراخوانی می‌کند. این اجازه می‌دهد پروژه‌های دیگر از اکثر قابلیت‌هایی که بسته فراهم می‌کند بهره‌مند شوند، زیرا کد جعبه کتابخانه‌ای می‌تواند به اشتراک گذاشته شود.

درخت ماژول باید در `src/lib.rs` تعریف شود. سپس، هر مورد عمومی می‌تواند در جعبه باینری با شروع مسیرها با نام بسته استفاده شود. جعبه باینری به یک کاربر از جعبه کتابخانه‌ای تبدیل می‌شود، درست مانند اینکه یک جعبه کاملاً خارجی از جعبه کتابخانه‌ای استفاده می‌کند: فقط می‌تواند از API عمومی استفاده کند. این به شما کمک می‌کند یک API خوب طراحی کنید؛ نه‌تنها شما نویسنده هستید، بلکه یک مشتری هم هستید!

در فصل دوازدهم، این روش سازمان‌دهی را با یک برنامه خط فرمان که شامل هر دو جعبه باینری و کتابخانه‌ای است، نشان خواهیم داد.

### شروع مسیرهای نسبی با `super`

می‌توانیم مسیرهای نسبی را بسازیم که از ماژول والد شروع می‌شوند، به‌جای ماژول فعلی یا ریشه جعبه، با استفاده از `super` در ابتدای مسیر. این مانند شروع یک مسیر فایل‌سیستم با سینتکس `..` است. استفاده از `super` به ما امکان می‌دهد به موردی ارجاع دهیم که می‌دانیم در ماژول والد است، که می‌تواند بازآرایی درخت ماژول را آسان‌تر کند وقتی ماژول به والد خود نزدیک است اما ممکن است والد روزی در جای دیگری از درخت ماژول منتقل شود.

کد در لیست ۷-۸ را در نظر بگیرید که موقعیتی را مدل می‌کند که یک سرآشپز یک سفارش نادرست را اصلاح می‌کند و شخصاً آن را به مشتری می‌آورد. تابع `fix_incorrect_order` که در ماژول `back_of_house` تعریف شده، تابع `deliver_order` را که در ماژول والد تعریف شده، با مشخص کردن مسیر به `deliver_order` که با `super` شروع می‌شود، فراخوانی می‌کند.

**نام فایل:** `src/lib.rs`

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
```

**لیست ۷-۸:** فراخوانی یک تابع با استفاده از مسیر نسبی که با `super` شروع می‌شود

تابع `fix_incorrect_order` در ماژول `back_of_house` است، بنابراین می‌توانیم از `super` برای رفتن به ماژول والد `back_of_house` استفاده کنیم، که در این مورد `crate`، ریشه است. از آنجا، به دنبال `deliver_order` می‌گردیم و آن را پیدا می‌کنیم. موفقیت! ما فکر می‌کنیم ماژول `back_of_house` و تابع `deliver_order` احتمالاً در همان رابطه با یکدیگر باقی می‌مانند و اگر تصمیم به بازآرایی درخت ماژول جعبه بگیریم، با هم منتقل می‌شوند. بنابراین، از `super` استفاده کردیم تا در آینده اگر این کد به ماژول دیگری منتقل شود، جاهای کمتری برای به‌روزرسانی کد داشته باشیم.

### عمومی کردن ساختارها و شمارش‌ها

می‌توانیم از `pubikker` برای عمومی کردن ساختارها و شمارش‌ها نیز استفاده کنیم، اما چند جزئیات اضافی در استفاده از `pub` با ساختارها و شمارش‌ها وجود دارد. اگر قبل از تعریف یک ساختار از `pub` استفاده کنیم، ساختار را عمومی می‌کنیم، اما فیلدهای ساختار همچنان خصوصی خواهند بود. می‌توانیم هر فیلد را به‌صورت موردی عمومی یا غیرعمومی کنیم. در لیست ۷-۹، یک ساختار عمومی `back_of_house::Breakfast` تعریف کرده‌ایم که یک فیلد عمومی `toast` و یک فیلد خصوصی `seasonal_fruit` دارد. این موقعیت را در یک رستوران مدل می‌کند که مشتری می‌تواند نوع نانی که با غذا می‌آید را انتخاب کند، اما سرآشپز تصمیم می‌گیرد کدام میوه همراه غذا باشد بر اساس آنچه در فصل و موجود است. میوه‌های موجود به‌سرعت تغییر می‌کنند، بنابراین مشتریان نمی‌توانند میوه را انتخاب کنند یا حتی ببینند چه میوه‌ای دریافت خواهند کرد.

**نام فایل:** `src/lib.rs**

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // سفارش یک صبحانه در تابستان با نان چاودار
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // تغییر نظرمان درباره نوع نان
    meal.toast = String::from("Wheat");
    println!("لطفاً نان {} می‌خوام", meal.toast);

    // خط بعدی اگر از حالت توضیح خارج شود، کامپایل نمی‌شود؛ ما اجازه نداریم
    // میوه فصلی که با غذا می‌آید را ببینیم یا تغییر دهیم
    // meal.seasonal_fruit = String::from("blueberries");
}
```

**لیست ۷-۹:** ساختاری با برخی فیلدهای عمومی و برخی فیلدهای خصوصی

چون فیلد `toast` در ساختار `back_of_house::Breakfast` عمومی است، در `eat_at_restaurant` می‌توانیم با استفاده از نماد نقطه به فیلد `toast` بنویسیم و بخوانیم. توجه کنید که نمی‌توانیم از فیلد `seasonal_fruit` در `eat_at_restaurant` استفاده کنیم، زیرا `seasonal_fruit` خصوصی است. سعی کنید خطی که مقدار فیلد `seasonal_fruit` را تغییر می‌دهد از حالت توضیح خارج کنید تا ببینید چه خطایی دریافت می‌کنید!

همچنین، توجه کنید که چون `back_of_house::Breakfast` یک فیلد خصوصی دارد، ساختار باید یک تابع مرتبط عمومی ارائه دهد که نمونه‌ای از `Breakfast` را بسازد (ما اینجا آن را `summer` نامیده‌ایم). اگر `Breakfast` چنین تابعی نداشت، نمی‌توانستیم نمونه‌ای از `Breakfast` در `eat_at_restaurant` ایجاد کنیم، زیرا نمی‌توانستیم مقدار فیلد خصوصی `seasonal_fruit` را در `eat_at_restaurant` تنظیم کنیم.

در مقابل، اگر یک شمارش را عمومی کنیم، همه انواع آن عمومی می‌شوند. فقط نیاز است قبل از کلمه‌کلیدی `enum` از `pub` استفاده کنیم، همان‌طور که در لیست ۷-۱۰ نشان داده شده است.

**نام فایل:** `src/lib.rs`

```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

**لیست ۷-۱۰:** عمومی کردن یک شمارش، همه انواع آن را عمومی می‌کند

چون شمارش `Appetizer` را عمومی کردیم، می‌توانیم از انواع `Soup` و `Salad` در `eat_at_restaurant` استفاده کنیم.

شمارش‌ها اگر انواعشان عمومی نباشند خیلی مفید نیستند؛ علامت‌گذاری همه انواع شمارش با `pub` در هر مورد آزاردهنده خواهد بود، بنابراین پیش‌فرض برای انواع شمارش عمومی بودن است. ساختارها اغلب بدون عمومی بودن فیلدهایشان مفید هستند، بنابراین فیلدهای ساختار از قانون کلی که همه چیز به‌صورت پیش‌فرض خصوصی است مگر اینکه با `pub` علامت‌گذاری شود، پیروی می‌کنند.

یک موقعیت دیگر مربوط به `pub` وجود دارد که هنوز پوشش نداده‌ایم، و آن آخرین ویژگی سیستم ماژول است: کلمه‌کلیدی `use`. ابتدا `use` را به‌تنهایی بررسی می‌کنیم و سپس نشان می‌دهیم چگونه `pub` و `use` را ترکیب کنیم.

## ذخیره متن رمزگذاری‌شده UTF-8 با رشته‌ها

در فصل چهارم درباره رشته‌ها صحبت کردیم، اما حالا آن‌ها را عمیق‌تر بررسی می‌کنیم. افراد تازه‌کار در Rust معمولاً به دلایل ترکیبی با رشته‌ها به مشکل برمی‌خورند: تمایل Rust به آشکار کردن خطاهای ممکن، پیچیدگی بیشتر ساختار داده‌ای رشته‌ها نسبت به آنچه بسیاری از برنامه‌نویسان تصور می‌کنند، و UTF-8. این عوامل به شکلی ترکیب می‌شوند که وقتی از زبان‌های برنامه‌نویسی دیگر می‌آیید، ممکن است دشوار به نظر برسد.

ما رشته‌ها را در زمینه مجموعه‌ها بحث می‌کنیم، زیرا رشته‌ها به‌عنوان مجموعه‌ای از بایت‌ها پیاده‌سازی شده‌اند، به علاوه برخی متدها برای ارائه قابلیت‌های مفید وقتی آن بایت‌ها به‌عنوان متن تفسیر می‌شوند. در این بخش، درباره عملیات‌هایی که روی `String` وجود دارد و هر نوع مجموعه‌ای آن‌ها را دارد، مانند ایجاد، به‌روزرسانی، و خواندن صحبت خواهیم کرد. همچنین درباره تفاوت‌های `String` با سایر مجموعه‌ها بحث می‌کنیم، به‌ویژه اینکه چگونه اندیس‌گذاری در یک `String` به دلیل تفاوت‌های بین نحوه تفسیر داده‌های `String` توسط انسان‌ها و کامپیوترها پیچیده است.

### رشته چیست؟

ابتدا تعریف می‌کنیم که منظورمان از اصطلاح **رشته (string)** چیست. Rust در زبان اصلی خود تنها یک نوع رشته دارد، که برش رشته‌ای `str` است و معمولاً به شکل قرض‌گرفته‌شده‌اش `&str` دیده می‌شود. در فصل چهارم، درباره برش‌های رشته‌ای صحبت کردیم، که ارجاع‌هایی به داده‌های رشته‌ای رمزگذاری‌شده UTF-8 هستند که در جای دیگری ذخیره شده‌اند. لفظ‌های رشته‌ای، برای مثال، در فایل باینری برنامه ذخیره می‌شوند و بنابراین برش‌های رشته‌ای هستند.

نوع `String`، که توسط کتابخانه استاندارد Rust ارائه شده و نه در زبان اصلی کدگذاری شده، یک نوع رشته‌ای قابل‌رشد، قابل‌تغییر، مالکیت‌دار، و رمزگذاری‌شده UTF-8 است. وقتی Rustaceanها در Rust به «رشته‌ها» اشاره می‌کنند، ممکن است به یکی از انواع `String` یا برش رشته‌ای `&str` اشاره داشته باشند، نه فقط یکی از این انواع. اگرچه این بخش عمدتاً درباره `String` است، هر دو نوع به شدت در کتابخانه استاندارد Rust استفاده می‌شوند، و هر دو `String` و برش‌های رشته‌ای رمزگذاری UTF-8 هستند.

### ایجاد یک رشته جدید

بسیاری از عملیات‌های مشابهی که با `Vec<T>` در دسترس هستند، با `String` نیز در دسترس‌اند، زیرا `String` در واقع به‌عنوان یک بسته‌بندی دور یک وکتور از بایت‌ها با برخی ضمانت‌ها، محدودیت‌ها، و قابلیت‌های اضافی پیاده‌سازی شده است. نمونه‌ای از تابعی که به همان شیوه با `Vec<T>` و `String` کار می‌کند، تابع `new` برای ایجاد یک نمونه است، که در لیست ۸-۱۱ نشان داده شده است.

```rust
let mut s = String::new();
```

**لیست ۸-۱۱:** ایجاد یک رشته خالی جدید

این خط یک رشته خالی جدید به نام `s` ایجاد می‌کند که می‌توانیم داده‌ها را در آن بارگذاری کنیم. اغلب، داده‌های اولیه‌ای داریم که می‌خواهیم رشته را با آن شروع کنیم. برای این کار، از متد `to_string` استفاده می‌کنیم، که در هر نوع که ویژگی‌ `Display` را پیاده‌سازی کند، مانند لفظ‌های رشته‌ای، در دسترس است. لیست ۸-۱۲ دو مثال را نشان می‌دهد.

```rust
let data = "initial contents";

let s = data.to_string();

// این متد مستقیماً روی یک لفظ نیز کار می‌کند:
let s = "initial contents".to_string();
```

**لیست ۸-۱۲:** استفاده از متد `to_string` برای ایجاد یک `String` از یک لفظ رشته‌ای

این کد یک رشته حاوی `initial contents` ایجاد می‌کند.

همچنین می‌توانیم از تابع `String::from` برای ایجاد یک `String` از یک لفظ رشته‌ای استفاده کنیم. کد در لیست ۸-۱۳ معادل کد در لیست ۸-۱۲ است که از `to_string` استفاده می‌کند.

```rust
let s = String::from("initial contents");
```

**لیست ۸-۱۳:** استفاده از تابع `String::from` برای ایجاد یک `String` از یک لفظ رشته‌ای

چون رشته‌ها برای چیزهای زیادی استفاده می‌شوند، می‌توانیم از APIهای Generic مختلفی برای رشته‌ها استفاده کنیم که گزینه‌های زیادی به ما می‌دهند. برخی از آن‌ها ممکن است زائد به نظر برسند، اما همه جای خود را دارند! در این مورد، `String::from` و `to_string` کار یکسانی انجام می‌دهند، بنابراین انتخاب شما به سبک و خوانایی بستگی دارد.

به یاد داشته باشید که رشته‌ها رمزگذاری UTF-8 هستند، بنابراین می‌توانیم هر داده‌ای که به‌درستی رمزگذاری شده باشد را در آن‌ها قرار دهیم، همان‌طور که در لیست ۸-۱۴ نشان داده شده است.

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שלום");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

**لیست ۸-۱۴:** ذخیره سلام‌های به زبان‌های مختلف در رشته‌ها

همه این‌ها مقادیر معتبر `String` هستند.

### به‌روزرسانی یک رشته

یک `String` می‌تواند در اندازه رشد کند و محتوای آن می‌تواند تغییر کند، درست مثل محتوای یک `Vec<T>`، اگر داده‌های بیشتری به آن فشار دهید. علاوه بر این، می‌توانید به‌راحتی از عملگر `+` یا ماکروی `format!` برای الحاق مقادیر `String` استفاده کنید.

#### الحاق به یک رشته با `push_str` و `push`

ما می‌توانیم یک `String` را با استفاده از متد `push_str` برای الحاق یک برش رشته‌ای رشد دهیم، همان‌طور که در لیست ۸-۱۵ نشان داده شده است.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

**لیست ۸-۱۵:** الحاق یک برش رشته‌ای به یک `String` با استفاده از متد `push_str`

پس از این دو خط، `s` حاوی `foobar` خواهد بود. متد `push_str` یک برش رشته‌ای می‌گیرد، زیرا ما لزوماً نمی‌خواهیم مالکیت پارامتر را بگیریم. برای مثال، در کد لیست ۸-۱۶، می‌خواهیم بتوانیم از `s2` پس از الحاق محتوای آن به `s1` استفاده کنیم.

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 برابر است با {s2}");
```

**لیست ۸-۱۶:** استفاده از یک برش رشته‌ای پس از الحاق محتوای آن به یک `String`

اگر متد `push_str` مالکیت `s2` را می‌گرفت، نمی‌توانستیم مقدار آن را در خط آخر چاپ کنیم. با این حال، این کد همان‌طور که انتظار داریم کار می‌کند!

متد `push` یک کاراکتر تکی را به‌عنوان پارامتر می‌گیرد و آن را به `String` اضافه می‌کند. لیست ۸-۱۷ حرف `l` را با استفاده از متد `push` به یک `String` اضافه می‌کند.

```rust
let mut s = String::from("lo");
s.push('l');
```

**لیست ۸-۱۷:** افزودن یک کاراکتر به مقدار یک `String` با استفاده از `push`

در نتیجه، `s` حاوی `lol` خواهد بود.

#### الحاق با عملگر `+` یا ماکروی `format!`

اغلب، می‌خواهید دو رشته موجود را ترکیب کنید. یکی از راه‌ها استفاده از عملگر `+` است، همان‌طور که در لیست ۸-۱۸ نشان داده شده است.

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // توجه کنید که s1 اینجا منتقل شده و دیگر نمی‌توان از آن استفاده کرد
```

**لیست ۸-۱۸:** استفاده از عملگر `+` برای ترکیب دو مقدار `String` در یک مقدار `String` جدید

رشته `s3` حاوی `Hello, world!` خواهد بود. دلیل اینکه `s1` پس از الحاق معتبر نیست، و دلیل اینکه از ارجاع به `s2` استفاده کردیم، به امضای متدی که وقتی از عملگر `+` استفاده می‌کنیم فراخوانی می‌شود، مربوط است. عملگر `+` از متد `add` استفاده می‌کند، که امضایش چیزی شبیه به این است:

```rust
fn add(self, s: &str) -> String {
```

در کتابخانه استاندارد، خواهید دید که `add` با استفاده از Generic‌ها و انواع مرتبط تعریف شده است. اینجا، ما انواع مشخص را جایگزین کرده‌ایم، که وقتی این متد را با مقادیر `String` فراخوانی می‌کنیم، اتفاق می‌افتد. در فصل دهم درباره Generic‌ها بحث خواهیم کرد. این امضا سرنخ‌هایی که برای درک بخش‌های پیچیده عملگر `+` نیاز داریم را به ما می‌دهد.

اول، `s2` یک `&` دارد، به این معنی که ما یک ارجاع از رشته دوم را به رشته اول اضافه می‌کنیم. این به دلیل پارامتر `s` در تابع `add` است: ما فقط می‌توانیم یک `&str` را به یک `String` اضافه کنیم؛ نمی‌توانیم دو مقدار `String` را با هم اضافه کنیم. اما صبر کنید—نوع `&s2` برابر `&String` است، نه `&str`، همان‌طور که در پارامتر دوم `add` مشخص شده است. پس چرا لیست ۸-۱۸ کامپایل می‌شود؟

دلیل اینکه می‌توانیم از `&s2` در فراخوانی `add` استفاده کنیم این است که کامپایلر می‌تواند آرگومان `&String` را به `&str` تبدیل کند. وقتی متد `add` را فراخوانی می‌کنیم، Rust از یک تبدیل دی‌رفرنس (deref coercion) استفاده می‌کند، که اینجا `&s2` را به `&s2[..]` تبدیل می‌کند. در فصل پانزدهم عمیق‌تر درباره تبدیل دی‌رفرنس صحبت خواهیم کرد. چون `add` مالکیت پارامتر `s` را نمی‌گیرد، `s2` پس از این عملیات همچنان یک `String` معتبر خواهد بود.

دوم، می‌توانیم در امضا ببینیم که `add` مالکیت `self` را می‌گیرد، زیرا `self` یک `&` ندارد. این یعنی `s1` در لیست ۸-۱۸ به فراخوانی `add` منتقل می‌شود و پس از آن دیگر معتبر نخواهد بود. بنابراین، اگرچه `let s3 = s1 + &s2;` به نظر می‌رسد که هر دو رشته را کپی می‌کند و یک رشته جدید ایجاد می‌کند، این عبارت در واقع مالکیت `s1` را می‌گیرد، یک کپی از محتوای `s2` را الحاق می‌کند، و سپس مالکیت نتیجه را برمی‌گرداند. به عبارت دیگر، به نظر می‌رسد که کپی‌های زیادی انجام می‌دهد، اما این‌طور نیست؛ پیاده‌سازی کارآمدتر از کپی کردن است.

اگر نیاز به الحاق چندین رشته داشته باشیم، رفتار عملگر `+` دست‌وپاگیر می‌شود:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

در این نقطه، `s` برابر `tic-tac-toe` خواهد بود. با همه `+`ها و کاراکترهای `"`، دیدن آنچه در جریان است دشوار است. برای ترکیب رشته‌ها به روش‌های پیچیده‌تر، می‌توانیم به‌جای آن از ماکروی `format!` استفاده کنیم:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

این کد همچنین `s` را به `tic-tac-toe` تنظیم می‌کند. ماکروی `format!` مانند `println!` کار می‌کند، اما به‌جای چاپ خروجی روی صفحه، یک `String` با محتوا برمی‌گرداند. نسخه کد با استفاده از `format!` بسیار خواناتر است، و کد تولیدشده توسط ماکروی `format!` از ارجاع‌ها استفاده می‌کند تا این فراخوانی مالکیت هیچ‌یک از پارامترهایش را نگیرد.

### اندیس‌گذاری در رشته‌ها

در بسیاری از زبان‌های برنامه‌نویسی دیگر، دسترسی به کاراکترهای جداگانه در یک رشته با ارجاع به آن‌ها از طریق اندیس یک عملیات معتبر و رایج است. با این حال، اگر در Rust سعی کنید با نحو اندیس‌گذاری به بخش‌هایی از یک `String` دسترسی پیدا کنید، خطا دریافت خواهید کرد. کد نامعتبر در لیست ۸-۱۹ را در نظر بگیرید.

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
let s1 = String::from("hi");
let h = s1[0];
```

**لیست ۸-۱۹:** تلاش برای استفاده از نحو اندیس‌گذاری با یک `String`

این کد منجر به خطای زیر خواهد شد:

```bash
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: نوع `str` نمی‌تواند با `{integer}` اندیس‌گذاری شود
 --> src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ اندیس‌های رشته محدوده‌هایی از `usize` هستند
  |
  = note: می‌توانید از `.chars().nth()` یا `.bytes().nth()` استفاده کنید
          برای اطلاعات بیشتر، به فصل هشتم در کتاب مراجعه کنید: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>
  = help: ویژگی‌ `SliceIndex<str>` برای `{integer}` پیاده‌سازی نشده است
          اما ویژگی‌ `SliceIndex<[_]>` برای `usize` پیاده‌سازی شده است
  = help: برای آن پیاده‌سازی ویژگی‌، انتظار `[_]` بود، اما `str` یافت شد
  = note: برای پیاده‌سازی `Index<{integer}>` توسط `String` لازم است

برای اطلاعات بیشتر درباره این خطا، `rustc --explain E0277` را امتحان کنید.
error: نتوانست جعبه `collections` (باینری "collections") را به دلیل 1 خطای قبلی کامپایل کند
```

خطا و یادداشت داستان را می‌گویند: رشته‌های Rust از اندیس‌گذاری پشتیبانی نمی‌کنند. اما چرا؟ برای پاسخ به این سؤال، باید درباره نحوه ذخیره رشته‌ها در حافظه توسط Rust بحث کنیم.

#### نمایش داخلی

یک `String` یک بسته‌بندی دور یک `Vec<u8>` است. بیایید به برخی از رشته‌های نمونه رمزگذاری‌شده UTF-8 درست از لیست ۸-۱۴ نگاه کنیم. ابتدا این یکی:

```rust
let hello = String::from("Hola");
```

در این مورد، `len` برابر ۴ خواهد بود، به این معنی که وکتوری که رشته `"Hola"` را ذخیره می‌کند، ۴ بایت طول دارد. هر یک از این حروف وقتی در UTF-8 رمزگذاری می‌شوند، یک بایت اشغال می‌کنند. اما خط زیر ممکن است شما را شگفت‌زده کند (توجه کنید که این رشته با حرف بزرگ سیریلیک Ze شروع می‌شود، نه عدد ۳):

```rust
let hello = String::from("Здравствуйте");
```

اگر از شما پرسیده شود که این رشته چقدر طول دارد، ممکن است بگویید ۱۲. در واقع، پاسخ Rust برابر ۲۴ است: این تعداد بایت‌هایی است که برای رمزگذاری `"Здравствуйте"` در UTF-8 لازم است، زیرا هر مقدار اسکالر یونیکد در آن رشته ۲ بایت فضا اشغال می‌کند. بنابراین، اندیس در بایت‌های رشته همیشه با یک مقدار اسکالر یونیکد معتبر هم‌خوانی ندارد. برای نشان دادن این موضوع، کد نامعتبر Rust زیر را در نظر بگیرید:

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

شما می‌دانید که `answer` برابر `З`، اولین حرف، نخواهد بود. وقتی در UTF-8 رمزگذاری می‌شود، اولین بایت `З` برابر ۲۰۸ و دومین بایت ۱۵۱ است، بنابراین به نظر می‌رسد که `answer` باید در واقع ۲۰۸ باشد، اما ۲۰۸ به‌تنهایی یک کاراکتر معتبر نیست. بازگرداندن ۲۰۸ احتمالاً چیزی نیست که کاربر اگر اولین حرف این رشته را بخواهد، انتظار دارد؛ با این حال، این تنها داده‌ای است که Rust در اندیس بایت ۰ دارد. کاربران عموماً نمی‌خواهند مقدار بایت برگردانده شود، حتی اگر رشته فقط شامل حروف لاتین باشد: اگر `&"hi"[0]` کد معتبری بود که مقدار بایت را برمی‌گرداند، ۱۰۴ را برمی‌گرداند، نه `h`.

پاسخ این است که برای جلوگیری از بازگرداندن یک مقدار غیرمنتظره و ایجاد اشکال‌هایی که ممکن است فوراً کشف نشوند، Rust این کد را اصلاً کامپایل نمی‌کند و از سوءتفاهم‌ها در مراحل اولیه فرآیند توسعه جلوگیری می‌کند.

#### بایت‌ها و مقادیر اسکالر و خوشه‌های گرافم! اوه، خدای من!

نکته دیگری درباره UTF-8 این است که در واقع سه راه مرتبط برای نگاه کردن به رشته‌ها از دیدگاه Rust وجود دارد: به‌عنوان بایت‌ها، مقادیر اسکالر، و خوشه‌های گرافم (نزدیک‌ترین چیز به آنچه ما حروف می‌نامیم).

اگر به کلمه هندی `"नमस्ते"` نوشته‌شده در خط دیواناگاری نگاه کنیم، به‌عنوان یک وکتور از مقادیر `u8` ذخیره می‌شود که به این شکل است:

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
```

این ۱۸ بایت است و این‌گونه است که کامپیوترها در نهایت این داده را ذخیره می‌کنند. اگر به آن‌ها به‌عنوان مقادیر اسکالر یونیکد نگاه کنیم، که نوع `char` در Rust است، این بایت‌ها به این شکل به نظر می‌رسند:

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

اینجا شش مقدار `char` وجود دارد، اما چهارمین و ششمین آن‌ها حروف نیستند: آن‌ها دیاکریتیک‌هایی هستند که به‌تنهایی معنی ندارند. در نهایت، اگر به آن‌ها به‌عنوان خوشه‌های گرافم نگاه کنیم، آنچه یک انسان چهار حرف تشکیل‌دهنده کلمه هندی می‌نامد را دریافت می‌کنیم:

```rust
["न", "म", "स्", "ते"]
```

Rust راه‌های مختلفی برای تفسیر داده‌های رشته‌ای خام که کامپیوترها ذخیره می‌کنند ارائه می‌دهد تا هر برنامه بتواند تفسیری که نیاز دارد را انتخاب کند، بدون توجه به اینکه داده به چه زبان انسانی است.

دلیل نهایی اینکه Rust به ما اجازه نمی‌دهد در یک `String` اندیس‌گذاری کنیم تا یک کاراکتر بگیریم این است که عملیات‌های اندیس‌گذاری انتظار می‌رود همیشه در زمان ثابت (O(1)) انجام شوند. اما تضمین این عملکرد با یک `String` ممکن نیست، زیرا Rust باید از ابتدا تا اندیس محتوای را بررسی کند تا تعداد کاراکترهای معتبر را تعیین کند.

### برش رشته‌ها

اندیس‌گذاری در یک رشته اغلب ایده بدی است، زیرا مشخص نیست که نوع بازگشتی عملیات اندیس‌گذاری رشته باید چه باشد: یک مقدار بایت، یک کاراکتر، یک خوشه گرافم، یا یک برش رشته‌ای. بنابراین، اگر واقعاً نیاز دارید از اندیس‌ها برای ایجاد برش‌های رشته‌ای استفاده کنید، Rust از شما می‌خواهد که مشخص‌تر باشید.

به‌جای اندیس‌گذاری با استفاده از `[]` با یک عدد تکی، می‌توانید از `[]` با یک محدوده برای ایجاد یک برش رشته‌ای حاوی بایت‌های خاص استفاده کنید:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

اینجا، `s` یک `&str` خواهد بود که چهار بایت اول رشته را شامل می‌شود. قبلاً ذکر کردیم که هر یک از این کاراکترها دو بایت است، به این معنی که `s` برابر `Зд` خواهد بود.

اگر سعی کنیم فقط بخشی از بایت‌های یک کاراکتر را با چیزی مثل `&hello[0..1]` برش دهیم، Rust در زمان اجرا به همان شیوه‌ای که اگر اندیس نامعتبری در یک وکتور دسترسی پیدا می‌کرد، پنیک می‌کند:

```bash
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
اندیس بایت 1 یک مرز کاراکتر نیست؛ داخل 'З' (بایت‌های 0..2) از `Здравствуйте` است
note: با متغیر محیطی `RUST_BACKTRACE=1` اجرا کنید تا یک بک‌تریس نمایش داده شود
```

باید هنگام ایجاد برش‌های رشته‌ای با محدوده‌ها احتیاط کنید، زیرا این کار می‌تواند باعث کرش برنامه‌تان شود.

### متدها برای پیمایش روی رشته‌ها

بهترین راه برای کار با تکه‌های رشته‌ها این است که صریحاً مشخص کنید آیا کاراکترها را می‌خواهید یا بایت‌ها. برای مقادیر اسکالر یونیکد جداگانه، از متد `chars` استفاده کنید. فراخوانی `chars` روی `"Зд"` دو مقدار از نوع `char` جدا می‌کند و برمی‌گرداند، و می‌توانید روی نتیجه پیمایش کنید تا به هر عنصر دسترسی پیدا کنید:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

این کد خروجی زیر را چاپ خواهد کرد:

```
З
д
```

به‌طور جایگزین، متد `bytes` هر بایت خام را برمی‌گرداند، که ممکن است برای حوزه شما مناسب باشد:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

این کد چهار بایتی که این رشته را تشکیل می‌دهند را چاپ خواهد کرد:

```
208
151
208
180
```

اما به یاد داشته باشید که مقادیر اسکالر یونیکد معتبر ممکن است از بیش از یک بایت تشکیل شده باشند.

گرفتن خوشه‌های گرافم از رشته‌ها، مانند خط دیواناگاری، پیچیده است، بنابراین این قابلیت توسط کتابخانه استاندارد ارائه نشده است. اگر به این قابلیت نیاز دارید، جعبه‌هایی در crates.io در دسترس هستند.

### رشته‌ها آن‌قدرها هم ساده نیستند

به‌طور خلاصه، رشته‌ها پیچیده هستند. زبان‌های برنامه‌نویسی مختلف انتخاب‌های متفاوتی درباره نحوه ارائه این پیچیدگی به برنامه‌نویس دارند. Rust انتخاب کرده است که مدیریت صحیح داده‌های `String` رفتار پیش‌فرض برای همه برنامه‌های Rust باشد، به این معنی که برنامه‌نویسان باید از ابتدا فکر بیشتری به مدیریت داده‌های UTF-8 اختصاص دهند. این مصالحه پیچیدگی رشته‌ها را بیشتر از آنچه در زبان‌های برنامه‌نویسی دیگر آشکار است، نشان می‌دهد، اما از مدیریت خطاهای مربوط به کاراکترهای غیر-ASCII در مراحل بعدی چرخه توسعه شما جلوگیری می‌کند.

خبر خوب این است که کتابخانه استاندارد قابلیت‌های زیادی را بر اساس انواع `String` و `&str` ارائه می‌دهد تا به مدیریت صحیح این موقعیت‌های پیچیده کمک کند. حتماً مستندات را برای متدهای مفیدی مانند `contains` برای جستجو در یک رشته و `replace` برای جایگزینی بخش‌هایی از یک رشته با رشته دیگر بررسی کنید.

بیایید به چیزی کمی کمتر پیچیده برویم: نقشه‌های هش!

# انواع پیشرفته

سیستم نوع Rust دارای برخی ویژگی‌هایی است که تاکنون به آن‌ها اشاره کرده‌ایم اما هنوز بحث نکرده‌ایم. ابتدا با بحث درباره **نوع جدید (newtype)** به‌طور کلی شروع می‌کنیم و بررسی می‌کنیم که چرا این نوع‌ها به‌عنوان نوع مفید هستند. سپس به **نام‌های مستعار نوع (type aliases)** می‌پردازیم، که ویژگی‌ای مشابه نوع جدید است اما با معناشناسی کمی متفاوت. همچنین نوع `!` و انواع با اندازه پویا را بررسی خواهیم کرد.

## استفاده از الگوی نوع جدید برای ایمنی نوع و انتزاع

این بخش فرض می‌کند که شما بخش قبلی «استفاده از الگوی نوع جدید برای پیاده‌سازی ویژگی‌های خارجی روی انواع خارجی» را خوانده‌اید. الگوی نوع جدید برای وظایفی فراتر از آنچه تاکنون بحث کرده‌ایم نیز مفید است، از جمله اطمینان استاتیک از اینکه مقادیر هرگز با هم اشتباه گرفته نمی‌شوند و نشان دادن واحدهای یک مقدار. شما مثالی از استفاده از نوع‌های جدید برای نشان دادن واحدها را در Listing 20-16 دیدید: به یاد بیاورید که ساختارهای `Millimeters` و `Meters` مقادیر `u32` را در یک نوع جدید بسته‌بندی کردند. اگر تابعی با پارامتری از نوع `Millimeters` نوشتیم، نمی‌توانستیم برنامه‌ای را که به‌طور تصادفی سعی می‌کند آن تابع را با مقداری از نوع `Meters` یا یک `u32` ساده فراخوانی کند، کامپایل کنیم.

همچنین می‌توان از الگوی نوع جدید برای انتزاع برخی جزئیات پیاده‌سازی یک نوع استفاده کرد: نوع جدید می‌تواند یک API عمومی را ارائه دهد که با API نوع داخلی خصوصی متفاوت است.

نوع‌های جدید همچنین می‌توانند پیاده‌سازی داخلی را مخفی کنند. برای مثال، می‌توانیم یک نوع `People` ارائه دهیم که یک `HashMap<i32, String>` را بسته‌بندی کند و شناسه یک شخص را با نام او مرتبط کند. کدی که از `People` استفاده می‌کند، فقط با API عمومی که ما ارائه می‌دهیم تعامل خواهد داشت، مانند متدی برای افزودن یک رشته نام به مجموعه `People`؛ این کد نیازی به دانستن این ندارد که ما در داخل به نام‌ها یک شناسه `i32` اختصاص می‌دهیم. الگوی نوع جدید یک روش سبک برای دستیابی به کپسوله‌سازی برای مخفی کردن جزئیات پیاده‌سازی است، که در بخش «کپسوله‌سازی که جزئیات پیاده‌سازی را مخفی می‌کند» در فصل هجدهم بحث کردیم.

## ایجاد مترادف‌های نوع با نام‌های مستعار نوع

Rust امکان اعلان یک **نام مستعار نوع (type alias)** را فراهم می‌کند تا به یک نوع موجود نامی دیگر بدهد. برای این کار از کلمه کلیدی `type` استفاده می‌کنیم. برای مثال، می‌توانیم نام مستعار `Kilometers` را برای `i32` به این صورت ایجاد کنیم:

```rust
type Kilometers = i32;
```

اکنون، نام مستعار `Kilometers` مترادفی برای `i32` است؛ برخلاف نوع‌های `Millimeters` و `Meters` که در Listing 20-16 ایجاد کردیم، `Kilometers` یک نوع جدید و جداگانه نیست. مقادیر با نوع `Kilometers` همانند مقادیر با نوع `i32` رفتار خواهند شد:

```rust
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!("x + y = {}", x + y);
```

چون `Kilometers` و `i32` یک نوع هستند، می‌توانیم مقادیر هر دو نوع را جمع کنیم و می‌توانیم مقادیر `Kilometers` را به توابعی که پارامترهای `i32` می‌گیرند پاس دهیم. با این حال، با استفاده از این روش، مزایای بررسی نوع که از الگوی نوع جدید دریافت می‌کنیم را به دست نمی‌آوریم. به عبارت دیگر، اگر جایی مقادیر `Kilometers` و `i32` را اشتباه کنیم، کامپایلر خطایی به ما نخواهد داد.

مورد استفاده اصلی برای مترادف‌های نوع کاهش تکرار است. برای مثال، ممکن است نوع طولانی‌ای مانند این داشته باشیم:

```rust
Box<dyn Fn() + Send + 'static>
```

نوشتن این نوع طولانی در امضاهای تابع و به‌عنوان حاشیه‌نویسی نوع در سراسر کد می‌تواند خسته‌کننده و مستعد خطا باشد. تصور کنید پروژه‌ای پر از کدی مانند آنچه در Listing 20-25 نشان داده شده است.

```rust
let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("hi"));

fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
    // --snip--
}

fn returns_long_type() -> Box<dyn Fn() + Send + 'static> {
    // --snip--
}
```

**Listing 20-25: استفاده از یک نوع طولانی در بسیاری از مکان‌ها**

یک نام مستعار نوع این کد را با کاهش تکرار قابل‌مدیریت‌تر می‌کند. در Listing 20-26، ما یک نام مستعار به نام `Thunk` برای نوع طولانی معرفی کرده‌ایم و می‌توانیم همه استفاده‌های نوع را با نام مستعار کوتاه‌تر `Thunk` جایگزین کنیم.

```rust
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -> Thunk {
    // --snip--
}
```

**Listing 20-26: معرفی یک نام مستعار نوع Thunk برای کاهش تکرار**

این کد بسیار خواناتر و نوشتن آن آسان‌تر است! انتخاب یک نام معنادار برای یک نام مستعار نوع همچنین می‌تواند به انتقال نیت شما کمک کند (thunk واژه‌ای است برای کدی که قرار است بعداً ارزیابی شود، بنابراین نام مناسبی برای یک کلوژر که ذخیره می‌شود است).

نام‌های مستعار نوع همچنین معمولاً با نوع `Result<T, E>` برای کاهش تکرار استفاده می‌شوند. ماژول `std::io` در کتابخانه استاندارد را در نظر بگیرید. عملیات ورودی/خروجی اغلب یک `Result<T, E>` برمی‌گردانند تا موقعیت‌هایی که عملیات کار نمی‌کنند را مدیریت کنند. این کتابخانه دارای یک ساختار `std::io::Error` است که تمام خطاهای ممکن ورودی/خروجی را نشان می‌دهد. بسیاری از توابع در `std::io` یک `Result<T, E>` برمی‌گردانند که در آن `E` برابر `std::io::Error` است، مانند این توابع در ویژگی `Write`:

```rust
use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}
```

`Result<..., Error>` بسیار تکرار شده است. به همین دلیل، `std::io` این اعلان نام مستعار نوع را دارد:

```rust
type Result<T> = std::result::Result<T, std::io::Error>;
```

چون این اعلان در ماژول `std::io` است، می‌توانیم از نام مستعار کاملاً مشخص `std::io::Result<T>` استفاده کنیم؛ یعنی یک `Result<T, E>` که `E` آن با `std::io::Error` پر شده است. امضاهای تابع ویژگی `Write` به این شکل می‌شوند:

```rust
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```

نام مستعار نوع به دو روش کمک می‌کند: نوشتن کد را آسان‌تر می‌کند و یک رابط ثابت در سراسر `std::io` به ما می‌دهد. چون این یک نام مستعار است، فقط یک `Result<T, E>` دیگر است، به این معنا که می‌توانیم هر متدی که روی `Result<T, E>` کار می‌کند را با آن استفاده کنیم، همچنین نحو خاصی مانند عملگر `?`.

## نوع Never که هرگز بازنمی‌گردد

Rust دارای یک نوع خاص به نام `!` است که در اصطلاح تئوری نوع به‌عنوان **نوع خالی (empty type)** شناخته می‌شود زیرا هیچ مقداری ندارد. ما ترجیح می‌دهیم آن را **نوع never** بنامیم زیرا در جای نوع بازگشتی قرار می‌گیرد وقتی یک تابع هرگز بازنمی‌گردد. این یک مثال است:

```rust
fn bar() -> ! {
    // --snip--
}
```

این کد به این صورت خوانده می‌شود: «تابع `bar` هرگز بازنمی‌گردد.» توابعی که نوع never را برمی‌گردانند، توابع **واگرا (diverging functions)** نامیده می‌شوند. ما نمی‌توانیم مقادیری از نوع `!` ایجاد کنیم، بنابراین `bar` هرگز نمی‌تواند بازگردد.

اما چه فایده‌ای دارد نوعی که هرگز نمی‌توانید مقادیری برای آن ایجاد کنید؟ کد از Listing 2-5، بخشی از بازی حدس عدد، را به یاد بیاورید؛ ما بخشی از آن را اینجا در Listing 20-27 بازتولید کرده‌ایم.

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

**Listing 20-27: یک match با یک بازو که به continue ختم می‌شود**

در آن زمان، برخی جزئیات این کد را نادیده گرفتیم. در بخش «عملگر جریان کنترلی match» در فصل ششم، بحث کردیم که بازوهای match باید همه یک نوع را برگردانند. بنابراین، برای مثال، کد زیر کار نمی‌کند:

```rust
// این کد کامپایل نمی‌شود!
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
};
```

نوع `guess` در این کد باید هم یک عدد صحیح باشد و هم یک رشته، و Rust要求 می‌کند که `guess` فقط یک نوع داشته باشد. پس `continue` چه چیزی برمی‌گرداند؟ چگونه در Listing 20-27 توانستیم از یک بازو یک `u32` برگردانیم و بازوی دیگری که با `continue` ختم می‌شود داشته باشیم؟

همان‌طور که ممکن است حدس زده باشید، `continue` دارای مقدار `!` است. یعنی وقتی Rust نوع `guess` را محاسبه می‌کند، به هر دو بازوی match نگاه می‌کند، اولی با مقدار `u32` و دومی با مقدار `!`. چون `!` هرگز نمی‌تواند مقداری داشته باشد، Rust تصمیم می‌گیرد که نوع `guess` برابر `u32` است.

روش رسمی برای توصیف این رفتار این است که عبارات از نوع `!` می‌توانند به هر نوع دیگری تبدیل شوند. ما اجازه داریم این بازوی match را با `continue` ختم کنیم زیرا `continue` مقداری برنمی‌گرداند؛ در عوض، کنترل را به بالای حلقه بازمی‌گرداند، بنابراین در مورد `Err`، هرگز مقداری به `guess` اختصاص نمی‌دهیم.

نوع never همچنین با ماکروی `panic!` مفید است. تابع `unwrap` را که روی مقادیر `Option<T>` فراخوانی می‌کنیم تا مقداری تولید کند یا با این تعریف پنیک کند، به یاد بیاورید:

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```

در این کد، همان چیزی که در match در Listing 20-27 اتفاق می‌افتد رخ می‌دهد: Rust می‌بیند که `val` نوع `T` دارد و `panic!` نوع `!` دارد، بنابراین نتیجه عبارت match کلی `T` است. این کد کار می‌کند زیرا `panic!` مقداری تولید نمی‌کند؛ برنامه را خاتمه می‌دهد. در مورد `None`، ما مقداری از `unwrap` برنمی‌گردانیم، بنابراین این کد معتبر است.

یک عبارت نهایی که نوع `!` دارد، یک حلقه است:

```rust
print!("forever ");

loop {
    print!("and ever ");
}
```

در اینجا، حلقه هرگز پایان نمی‌یابد، بنابراین `!` مقدار عبارت است. با این حال، اگر یک `break` اضافه کنیم، این درست نخواهد بود، زیرا حلقه وقتی به `break` برسد خاتمه می‌یابد.

## انواع با اندازه پویا و ویژگی Sized

Rust نیاز دارد که جزئیات خاصی درباره انواع خود بداند، مانند اینکه چه مقدار فضا برای یک مقدار از یک نوع خاص تخصیص دهد. این موضوع گوشه‌ای از سیستم نوع آن را در ابتدا کمی گیج‌کننده می‌کند: مفهوم **انواع با اندازه پویا (dynamically sized types)**. گاهی اوقات به‌عنوان DSTها یا انواع بدون اندازه (unsized types) شناخته می‌شوند، این انواع به ما امکان می‌دهند کدی بنویسیم که از مقادیری استفاده می‌کند که اندازه آن‌ها را فقط در زمان اجرا می‌توانیم بدانیم.

بیایید به جزئیات یک نوع با اندازه پویا به نام `str` بپردازیم، که در سراسر کتاب از آن استفاده کرده‌ایم. درست است، نه `&str`، بلکه `str` به‌تنهایی، یک DST است. ما نمی‌توانیم تا زمان اجرا بدانیم رشته چقدر طول دارد، به این معنا که نمی‌توانیم یک متغیر از نوع `str` ایجاد کنیم، و نمی‌توانیم آرگومانی از نوع `str` بگیریم. کد زیر کار نمی‌کند:

```rust
// این کد کامپایل نمی‌شود!
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust نیاز دارد بداند که چه مقدار حافظه برای هر مقدار از یک نوع خاص تخصیص دهد، و همه مقادیر یک نوع باید مقدار یکسانی از حافظه را استفاده کنند. اگر Rust به ما اجازه می‌داد این کد را بنویسیم، این دو مقدار `str` باید فضای یکسانی را اشغال می‌کردند. اما آن‌ها طول‌های متفاوتی دارند: `s1` به 12 بایت فضای ذخیره‌سازی نیاز دارد و `s2` به 15 بایت نیاز دارد. به همین دلیل امکان ایجاد یک متغیر که یک نوع با اندازه پویا را نگه دارد وجود ندارد.

پس چه کار کنیم؟ در این مورد، شما قبلاً جواب را می‌دانید: انواع `s1` و `s2` را به‌جای `str` به صورت `&str` می‌کنیم. از بخش «برش‌های رشته‌ای» در فصل چهارم به یاد بیاورید که ساختار داده برش فقط موقعیت شروع و طول برش را ذخیره می‌کند. بنابراین، اگرچه یک `&T` یک مقدار واحد است که آدرس حافظه‌ای که `T` در آن قرار دارد را ذخیره می‌کند، یک `&str` دو مقدار است: آدرس `str` و طول آن. به این ترتیب، ما می‌توانیم اندازه یک مقدار `&str` را در زمان کامپایل بدانیم: این دو برابر طول یک `usize` است. یعنی ما همیشه اندازه یک `&str` را می‌دانیم، مهم نیست رشته‌ای که به آن اشاره می‌کند چقدر طولانی باشد. به‌طور کلی، این روشی است که انواع با اندازه پویا در Rust استفاده می‌شوند: آن‌ها یک قطعه اضافی از متاداده دارند که اندازه اطلاعات پویا را ذخیره می‌کند. قانون طلایی انواع با اندازه پویا این است که همیشه باید مقادیر انواع با اندازه پویا را پشت نوعی اشاره‌گر قرار دهیم.

ما می‌توانیم `str` را با انواع مختلف اشاره‌گرها ترکیب کنیم: برای مثال، `Box<str>` یا `Rc<str>`. در واقع، شما این را قبلاً دیده‌اید اما با یک نوع با اندازه پویای دیگر: ویژگی‌ها. هر ویژگی یک نوع با اندازه پویا است که می‌توانیم با استفاده از نام ویژگی به آن اشاره کنیم. در بخش «استفاده از اشیاء ویژگی که امکان مقادیر از انواع مختلف را فراهم می‌کنند» در فصل هجدهم، ذکر کردیم که برای استفاده از ویژگی‌ها به‌عنوان اشیاء ویژگی، باید آن‌ها را پشت یک اشاره‌گر قرار دهیم، مانند `&dyn Trait` یا `Box<dyn Trait>` (همچنین `Rc<dyn Trait>` نیز کار می‌کند).

برای کار با DSTها، Rust ویژگی `Sized` را ارائه می‌دهد تا مشخص کند که آیا اندازه یک نوع در زمان کامپایل شناخته شده است یا خیر. این ویژگی به‌صورت خودکار برای هر چیزی که اندازه آن در زمان کامپایل شناخته شده است پیاده‌سازی می‌شود. علاوه بر این، Rust به‌طور ضمنی یک قید روی `Sized` به هر تابع Generic اضافه می‌کند. یعنی، یک تعریف تابع Generic مانند این:

```rust
fn generic<T>(t: T) {
    // --snip--
}
```

در واقع به این صورت در نظر گرفته می‌شود که انگار این را نوشته‌ایم:

```rust
fn generic<T: Sized>(t: T) {
    // --snip--
}
```

به‌طور پیش‌فرض، توابع Generic فقط روی انواعی کار می‌کنند که اندازه شناخته‌شده‌ای در زمان کامپایل دارند. با این حال، می‌توانید از نحو خاص زیر برای کاهش این محدودیت استفاده کنید:

```rust
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```

یک قید ویژگی روی `?Sized` به این معناست که «`T` ممکن است `Sized` باشد یا نباشد» و این نشانه‌گذاری پیش‌فرض را که انواع Generic باید اندازه شناخته‌شده‌ای در زمان کامپایل داشته باشند، لغو می‌کند. نحو `?Trait` با این معنا فقط برای `Sized` در دسترس است، نه برای هیچ ویژگی دیگری.

همچنین توجه کنید که ما نوع پارامتر `t` را از `T` به `&T` تغییر دادیم. چون نوع ممکن است `Sized` نباشد، باید از آن پشت نوعی اشاره‌گر استفاده کنیم. در این مورد، ما یک ارجاع را انتخاب کرده‌ایم.

در ادامه، درباره توابع و کلوژرها صحبت خواهیم کرد!
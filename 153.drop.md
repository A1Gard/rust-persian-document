# اجرای کد در زمان پاکسازی با ویژگی‌ `Drop`

دومین ویژگی‌ مهم در الگوی اشاره‌گر هوشمند، ویژگی‌ `Drop` است که به شما امکان می‌دهد مشخص کنید وقتی یک مقدار در حال خارج شدن از حوزه است، چه اتفاقی بیفتد. شما می‌توانید پیاده‌سازی ویژگی‌ `Drop` را برای هر نوع ارائه دهید، و این کد می‌تواند برای آزادسازی منابعی مانند فایل‌ها یا اتصالات شبکه استفاده شود.

ما ویژگی‌ `Drop` را در زمینه اشاره‌گرهای هوشمند معرفی می‌کنیم زیرا قابلیت ویژگی‌ `Drop` تقریباً همیشه هنگام پیاده‌سازی یک اشاره‌گر هوشمند استفاده می‌شود. به عنوان مثال، وقتی یک `Box<T>` آزاد می‌شود، فضای تخصیص‌یافته در هیپ که باکس به آن اشاره می‌کند را آزاد می‌کند.

در برخی زبان‌ها، برای برخی انواع، برنامه‌نویس باید هر بار که استفاده از یک نمونه از آن انواع را تمام کرد، کدی را برای آزاد کردن حافظه یا منابع فراخوانی کند. مثال‌هایی شامل دسته‌های فایل، سوکت‌ها و قفل‌ها هستند. اگر فراموش کنند، سیستم ممکن است بیش از حد بارگذاری شود و خراب شود. در **Rust**، می‌توانید مشخص کنید که هر زمان یک مقدار از حوزه خارج می‌شود، بخش خاصی از کد اجرا شود، و کامپایلر این کد را به‌صورت خودکار وارد می‌کند. در نتیجه، نیازی نیست مراقب باشید که کد پاکسازی را در هر جایی از برنامه که یک نمونه از نوع خاصی استفاده‌اش تمام شده قرار دهید—و همچنان منابع نشت نخواهید داد!

شما کد مورد نظر برای اجرا وقتی یک مقدار از حوزه خارج می‌شود را با پیاده‌سازی ویژگی‌ `Drop` مشخص می‌کنید. ویژگی‌ `Drop` از شما می‌خواهد یک متد به نام `drop` را پیاده‌سازی کنید که یک ارجاع قابل‌تغییر به `self` می‌گیرد. برای دیدن اینکه **Rust** چه زمانی `drop` را فراخوانی می‌کند، بیایید فعلاً `drop` را با دستورات `println!` پیاده‌سازی کنیم.

**جدول 15-14** یک ساختار `CustomSmartPointer` را نشان می‌دهد که تنها قابلیت سفارشی آن این است که وقتی نمونه از حوزه خارج می‌شود، عبارت `Dropping CustomSmartPointer!` را چاپ می‌کند، تا نشان دهد **Rust** چه زمانی متد `drop` را اجرا می‌کند.

**فایل: src/main.rs**

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
```

**جدول 15-14**: یک ساختار `CustomSmartPointer` که ویژگی‌ `Drop` را پیاده‌سازی می‌کند و جایی است که کد پاکسازی خود را قرار می‌دهیم

ویژگی‌ `Drop` در پیش‌نیازها (prelude) گنجانده شده است، بنابراین نیازی به آوردن آن به حوزه نداریم. ما ویژگی‌ `Drop` را روی `CustomSmartPointer` پیاده‌سازی می‌کنیم و یک پیاده‌سازی برای متد `drop` ارائه می‌دهیم که `println!` را فراخوانی می‌کند. بدنه متد `drop` جایی است که هر منطقی که می‌خواهید هنگام خارج شدن یک نمونه از نوع شما از حوزه اجرا شود را قرار می‌دهید. ما در اینجا متنی را چاپ می‌کنیم تا به‌صورت بصری نشان دهیم **Rust** چه زمانی `drop` را فراخوانی می‌کند.

در `main`، دو نمونه از `CustomSmartPointer` ایجاد می‌کنیم و سپس `CustomSmartPointers created.` را چاپ می‌کنیم. در انتهای `main`، نمونه‌های `CustomSmartPointer` ما از حوزه خارج می‌شوند، و **Rust** کدی را که در متد `drop` قرار دادیم فراخوانی می‌کند و پیام نهایی ما را چاپ می‌کند. توجه کنید که نیازی به فراخوانی صریح متد `drop` نداشتیم.

وقتی این برنامه را اجرا کنیم، خروجی زیر را خواهیم دید:

```bash
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
```

**Rust** به‌صورت خودکار `drop` را برای ما وقتی نمونه‌هایمان از حوزه خارج شدند فراخوانی کرد و کدی که مشخص کردیم را اجرا کرد. متغیرها به ترتیب معکوس ایجادشان آزاد می‌شوند، بنابراین `d` قبل از `c` آزاد شد. هدف این مثال این است که راهنمای بصری از نحوه عملکرد متد `drop` به شما بدهد؛ معمولاً شما کد پاکسازی مورد نیاز نوع خود را به جای پیام چاپ مشخص می‌کنید.

## غیرفعال کردن عملکرد خودکار `Drop`

متأسفانه، غیرفعال کردن عملکرد خودکار `drop` ساده نیست. غیرفعال کردن `drop` معمولاً لازم نیست؛ کل هدف ویژگی‌ `Drop` این است که به‌صورت خودکار مدیریت شود. با این حال، گاهی اوقات ممکن است بخواهید یک مقدار را زودتر پاکسازی کنید. یک مثال وقتی است که از اشاره‌گرهای هوشمندی استفاده می‌کنید که قفل‌ها را مدیریت می‌کنند: ممکن است بخواهید متد `drop` که قفل را آزاد می‌کند را مجبور کنید اجرا شود تا کدهای دیگر در همان حوزه بتوانند قفل را به دست آورند. **Rust** به شما اجازه نمی‌دهد متد `drop` ویژگی‌ `Drop` را به‌صورت دستی فراخوانی کنید؛ در عوض، اگر بخواهید مقداری را قبل از پایان حوزه‌اش مجبور به آزاد شدن کنید، باید تابع `std::mem::drop` ارائه‌شده توسط کتابخانه استاندارد را فراخوانی کنید.

اگر سعی کنیم متد `drop` ویژگی‌ `Drop` را به‌صورت دستی با تغییر تابع `main` از **جدول 15-14**، همان‌طور که در **جدول 15-15** نشان داده شده است، فراخوانی کنیم، یک خطای کامپایل دریافت خواهیم کرد.

**فایل: src/main.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```

**جدول 15-15**: تلاش برای فراخوانی دستی متد `drop` از ویژگی‌ `Drop` برای پاکسازی زودهنگام

وقتی سعی کنیم این کد را کامپایل کنیم، این خطا را دریافت خواهیم کرد:

```bash
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --> src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
```

این پیام خطا بیان می‌کند که ما اجازه نداریم `drop` را به‌صورت صریح فراخوانی کنیم. پیام خطا از اصطلاح **destructor** استفاده می‌کند، که اصطلاح عمومی برنامه‌نویسی برای تابعی است که یک نمونه را پاکسازی می‌کند. یک **destructor** مشابه یک **constructor** است که یک نمونه را ایجاد می‌کند. تابع `drop` در **Rust** یکی از **destructor**های خاص است.

**Rust** به ما اجازه نمی‌دهد `drop` را به‌صورت صریح فراخوانی کنیم زیرا **Rust** همچنان به‌صورت خودکار `drop` را در انتهای `main` روی مقدار فراخوانی می‌کند. این باعث یک خطای **double free** می‌شود زیرا **Rust** سعی می‌کند همان مقدار را دو بار پاکسازی کند.

ما نمی‌توانیم درج خودکار `drop` را وقتی یک مقدار از حوزه خارج می‌شود غیرفعال کنیم، و نمی‌توانیم متد `drop` را به‌صورت صریح فراخوانی کنیم. بنابراین، اگر نیاز به اجبار یک مقدار به پاکسازی زودهنگام داشته باشیم، از تابع `std::mem::drop` استفاده می‌کنیم.

تابع `std::mem::drop` با متد `drop` در ویژگی‌ `Drop` متفاوت است. ما آن را با پاس دادن مقداری که می‌خواهیم به‌صورت اجباری آزاد شود به‌عنوان آرگومان فراخوانی می‌کنیم. این تابع در پیش‌نیازها (prelude) قرار دارد، بنابراین می‌توانیم `main` را در **جدول 15-15** تغییر دهیم تا تابع `drop` را فراخوانی کند، همان‌طور که در **جدول 15-16** نشان داده شده است.

**فایل: src/main.rs**

```rust
fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```

**جدول 15-16**: فراخوانی `std::mem::drop` برای آزاد کردن صریح یک مقدار قبل از اینکه از حوزه خارج شود

اجرای این کد خروجی زیر را چاپ خواهد کرد:

```bash
$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
```

متن `Dropping CustomSmartPointer with data `some data`!` بین متن‌های `CustomSmartPointer created.` و `CustomSmartPointer dropped before the end of main.` چاپ شده است، که نشان می‌دهد کد متد `drop` در آن نقطه برای آزاد کردن `c` فراخوانی شده است.

## موارد استفاده از ویژگی‌ `Drop`

می‌توانید از کد مشخص‌شده در پیاده‌سازی ویژگی‌ `Drop` به روش‌های مختلفی برای راحت و ایمن کردن پاکسازی استفاده کنید: به عنوان مثال، می‌توانید از آن برای ایجاد تخصیص‌دهنده حافظه خودتان استفاده کنید! با ویژگی‌ `Drop` و سیستم مالکیت **Rust**، نیازی به یادآوری برای پاکسازی ندارید زیرا **Rust** آن را به‌صورت خودکار انجام می‌دهد.

همچنین نیازی به نگرانی درباره مشکلاتی ناشی از پاکسازی تصادفی مقادیری که هنوز در حال استفاده هستند ندارید: سیستم مالکیتی که اطمینان می‌دهد ارجاعات همیشه معتبر هستند، همچنین تضمین می‌کند که `drop` فقط یک‌بار وقتی مقدار دیگر استفاده نمی‌شود فراخوانی می‌شود.

## مثال عملی: مدیریت منابع با `Drop`

برای نشان دادن کاربرد عملی ویژگی‌ `Drop`، بیایید یک مثال از یک نوع سفارشی را در نظر بگیریم که یک دسته فایل را مدیریت می‌کند. ما می‌خواهیم اطمینان حاصل کنیم که فایل وقتی نمونه از حوزه خارج می‌شود به‌صورت خودکار بسته می‌شود.

```rust
use std::fs::File;
use std::io::Write;

struct FileWrapper {
    file: File,
    path: String,
}

impl FileWrapper {
    fn new(path: &str) -> FileWrapper {
        let file = File::create(path).expect("Failed to create file");
        FileWrapper {
            file,
            path: path.to_string(),
        }
    }

    fn write(&mut self, content: &str) {
        self.file
            .write_all(content.as_bytes())
            .expect("Failed to write to file");
    }
}

impl Drop for FileWrapper {
    fn drop(&mut self) {
        println!("Closing file: {}", self.path);
        // فایل به‌صورت خودکار بسته می‌شود وقتی از حوزه خارج شود،
        // اما ما می‌توانیم برای وضوح، یک پیام چاپ کنیم.
    }
}

fn main() {
    let mut file_wrapper = FileWrapper::new("example.txt");
    file_wrapper.write("Hello, world!");
    println!("File written successfully.");
    // وقتی file_wrapper از حوزه خارج می‌شود، Drop فراخوانی می‌شود
}
```

در این مثال:

- `FileWrapper` یک ساختار است که یک دسته فایل (`File`) و مسیر فایل را نگه می‌دارد.
- متد `new` یک فایل جدید ایجاد می‌کند و یک نمونه `FileWrapper` برمی‌گرداند.
- متد `write` به ما امکان می‌دهد داده‌ها را در فایل بنویسیم.
- پیاده‌سازی `Drop` یک پیام چاپ می‌کند که نشان می‌دهد فایل در حال بسته شدن است. خود دسته فایل به‌صورت خودکار وقتی از حوزه خارج می‌شود بسته می‌شود (به دلیل پیاده‌سازی `Drop` در `File`)، اما ما می‌توانیم منطق اضافی را در صورت نیاز اضافه کنیم.

وقتی برنامه اجرا می‌شود، خروجی شبیه این خواهد بود:

```bash
File written successfully.
Closing file: example.txt
```

این تضمین می‌کند که فایل به‌درستی بسته می‌شود، حتی اگر یک استثنا رخ دهد یا برنامه به‌طور غیرمنتظره خاتمه یابد، که از نشت منابع جلوگیری می‌کند.

## نکات اضافی درباره `Drop`

1. **ترتیب آزادسازی**: همان‌طور که در خروجی **جدول 15-14** دیدیم، متغیرها به ترتیب معکوس ایجادشان آزاد می‌شوند. این مهم است وقتی با منابعی کار می‌کنید که به ترتیب خاصی برای آزادسازی وابسته هستند.

2. **استفاده از `std::mem::drop` برای پاکسازی زودهنگام**: همان‌طور که در **جدول 15-16** نشان داده شد، تابع `std::mem::drop` برای آزاد کردن صریح یک مقدار قبل از پایان حوزه‌اش مفید است. این به‌ویژه در سناریوهایی مانند مدیریت قفل‌ها یا آزادسازی منابع برای استفاده توسط کد دیگر در همان حوزه مفید است.

3. **محدودیت‌های `Drop`**: شما نمی‌توانید متد `drop` را به‌صورت دستی فراخوانی کنید یا رفتار خودکار **Rust** را برای فراخوانی `drop` در پایان حوزه غیرفعال کنید. این طراحی برای جلوگیری از خطاهایی مانند **double free** است و ایمنی حافظه را تضمین می‌کند.

4. **ترکیب با اشاره‌گرهای هوشمند**: ویژگی‌ `Drop` برای اشاره‌گرهای هوشمند مانند `Box<T>`، `Rc<T>`، و `Arc<T>` بسیار مهم است، زیرا تضمین می‌کند که حافظه هیپ تخصیص‌یافته وقتی دیگر نیازی به آن نیست آزاد می‌شود. برای مثال، وقتی یک `Box<T>` از حوزه خارج می‌شود، داده‌های هیپ آن به‌طور خودکار آزاد می‌شود.

## نتیجه‌گیری

ویژگی‌ `Drop` یک ابزار قدرتمند در **Rust** است که به شما امکان می‌دهد منطق پاکسازی را برای انواع سفارشی تعریف کنید، و آن را به‌ویژه برای اشاره‌گرهای هوشمند و مدیریت منابع مفید می‌کند. با پیاده‌سازی متد `drop`، می‌توانید اطمینان حاصل کنید که منابعی مانند فایل‌ها، سوکت‌ها یا قفل‌ها به‌طور ایمن آزاد می‌شوند وقتی دیگر نیازی به آن‌ها نیست، بدون نیاز به مداخله دستی. سیستم مالکیت **Rust** و درج خودکار فراخوانی‌های `drop` خطر نشت منابع یا پاکسازی‌های تصادفی مقادیر در حال استفاده را از بین می‌برد.

تابع `std::mem::drop` انعطاف‌پذیری را برای آزادسازی زودهنگام مقادیر در صورت نیاز فراهم می‌کند، در حالی که محدودیت‌های **Rust** در فراخوانی دستی متد `drop` ایمنی را تضمین می‌کند. درک ویژگی‌ `Drop` هنگام کار با اشاره‌گرهای هوشمند یا طراحی انواع سفارشی که منابع را مدیریت می‌کنند ضروری است.

حالا که `Box<T>` و برخی از ویژگی‌های اشاره‌گرهای هوشمند را بررسی کردیم، در بخش‌های بعدی به بررسی اشاره‌گرهای هوشمند دیگر تعریف‌شده در کتابخانه استاندارد، مانند `Rc<T>` برای شمارش ارجاعات و `RefCell<T>` برای تغییرپذیری داخلی، خواهیم پرداخت. این انواع قابلیت‌های پیشرفته‌تری را ارائه می‌دهند که در کنار `Drop` و `Deref` برای ساخت برنامه‌های قوی و ایمن در **Rust** استفاده می‌شوند.
# اعمال هم‌زمانی با ناهمگام

در این بخش، ناهمگام را به برخی از همان چالش‌های هم‌زمانی که در فصل شانزدهم با نخ‌ها حل کردیم اعمال خواهیم کرد. چون قبلاً درباره بسیاری از ایده‌های کلیدی آنجا صحبت کردیم، در این بخش روی آنچه بین نخ‌ها و آینده‌ها متفاوت است تمرکز خواهیم کرد.

در بسیاری از موارد، APIها برای کار با هم‌زمانی با استفاده از ناهمگام بسیار مشابه APIها برای استفاده از نخ‌ها هستند. در موارد دیگر، آن‌ها کاملاً متفاوت می‌شوند. حتی وقتی APIها بین نخ‌ها و ناهمگام مشابه به نظر می‌رسند، اغلب رفتار متفاوتی دارند—و تقریباً همیشه ویژگی‌های عملکردی متفاوتی دارند.

## ایجاد یک وظیفه جدید با `spawn_task`

اولین عملیاتی که در بخش "ایجاد یک نخ جدید با `spawn`" در فصل شانزدهم حل کردیم، شمارش روی دو نخ جداگانه بود. بیایید همان کار را با استفاده از ناهمگام انجام دهیم. کریت `trpl` یک تابع `spawn_task` ارائه می‌دهد که بسیار مشابه API `thread::spawn` به نظر می‌رسد، و یک تابع `sleep` که نسخه ناهمگام از API `thread::sleep` است. ما می‌توانیم از این‌ها با هم برای پیاده‌سازی مثال شمارش استفاده کنیم، همان‌طور که در **فهرست کد 17-6** نشان داده شده است.

**فایل: src/main.rs**

```rust
use std::time::Duration;

fn main() {
    trpl::block_on(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}
```

**فهرست کد 17-6**: ایجاد یک وظیفه جدید برای چاپ یک چیز در حالی که وظیفه اصلی چیز دیگری را چاپ می‌کند

به‌عنوان نقطه شروع، تابع `main` خود را با `trpl::block_on` تنظیم می‌کنیم تا تابع سطح بالای ما بتواند ناهمگام باشد.

**توجه**: از این نقطه به بعد در فصل، هر مثالی شامل همین کد پوششی با `trpl::block_on` در `main` خواهد بود، بنابراین اغلب آن را صرف‌نظر می‌کنیم همان‌طور که `main` را انجام می‌دهیم. به یاد داشته باشید که آن را در کد خود بگنجانید!

سپس دو حلقه درون آن بلوک می‌نویسیم، هر کدام شامل یک فراخوانی `trpl::sleep` که نیم ثانیه (۵۰۰ میلی‌ثانیه) منتظر می‌ماند قبل از ارسال پیام بعدی. ما یکی از حلقه‌ها را در بدنه یک `trpl::spawn_task` قرار می‌دهیم و دیگری را در یک حلقه `for` سطح بالا. همچنین پس از فراخوانی‌های `sleep` یک `await` اضافه می‌کنیم.

این کد رفتاری مشابه پیاده‌سازی مبتنی بر نخ دارد—از جمله اینکه ممکن است پیام‌ها را در ترمینال خودتان هنگام اجرا در ترتیب متفاوتی ببینید:

```
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
```

این نسخه به محض پایان حلقه `for` در بدنه بلوک `async` اصلی متوقف می‌شود، زیرا وظیفه ایجادشده توسط `spawn_task` وقتی تابع `main` پایان می‌یابد خاموش می‌شود. اگر بخواهید تا پایان وظیفه اجرا شود، نیاز به یک دسته اتصال دارید تا منتظر تکمیل وظیفه اول بمانید. با نخ‌ها، از متد `join` برای "بلاک" کردن تا پایان نخ استفاده کردیم. در **فهرست کد 17-7**، می‌توانیم از `await` برای انجام همان کار استفاده کنیم، زیرا دسته وظیفه خودش یک آینده است. نوع `Output` آن یک `Result` است، بنابراین همچنین پس از انتظار روی آن، آن را `unwrap` می‌کنیم.

**فایل: src/main.rs**

```rust
        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
```

**فهرست کد 17-7**: استفاده از `await` با یک دسته اتصال برای اجرای یک وظیفه تا پایان

این نسخه به‌روزرسانی‌شده تا پایان هر دو حلقه اجرا می‌شود:

```
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

حالا، برای ساختن این کار، نیازی به ایجاد یک نخ سیستم‌عامل دیگر نداشتیم. در واقع، حتی نیازی به ایجاد یک وظیفه اینجا نداریم. چون بلوک‌های `async` به آینده‌های ناشناس کامپایل می‌شوند، می‌توانیم هر حلقه را در یک بلوک `async` قرار دهیم و زمان‌اجرا آن‌ها را تا پایان با تابع `trpl::join` اجرا کنیم.

در بخش "انتظار برای پایان تمام نخ‌ها" در فصل شانزدهم، نشان دادیم که چگونه از متد `join` روی نوع `JoinHandle` برگردانده‌شده هنگام فراخوانی `std::thread::spawn` استفاده کنیم. تابع `trpl::join` مشابه است، اما برای آینده‌ها. وقتی دو آینده را به آن می‌دهید، یک آینده جدید تولید می‌کند که خروجی آن یک تاپل شامل خروجی هر آینده‌ای است که پاس دادید وقتی هر دو کامل شوند. بنابراین، در **فهرست کد 17-8**، از `trpl::join` برای انتظار تا پایان هر دو `fut1` و `fut2` استفاده می‌کنیم. خروجی را نادیده می‌گیریم، زیرا فقط یک تاپل شامل دو مقدار واحد است.

**فایل: src/main.rs**

```rust
        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
```

**فهرست کد 17-8**: ساخت دو آینده ناشناس و انتظار روی آن‌ها با `trpl::join`

وقتی این را اجرا می‌کنیم، هر دو آینده تا پایان اجرا می‌شوند:

```
hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

حالا ترتیب دقیقاً هر بار یکسان است، که بسیار متفاوت از آنچه با نخ‌ها و با `trpl::spawn_task` در **فهرست کد 17-7** دیدیم. این به این دلیل است که تابع `trpl::join` **عادلانه (fair)** است، به این معنا که هر آینده را به همان اندازه اغلب بررسی می‌کند، بین آن‌ها جابه‌جا می‌شود، و هرگز اجازه نمی‌دهد یکی اگر دیگری آماده باشد پیشی بگیرد. با نخ‌ها، سیستم‌عامل تصمیم می‌گیرد کدام نخ را بررسی کند و چقدر اجازه دهد اجرا شود. با **Rust** ناهمگام، زمان‌اجرا تصمیم می‌گیرد کدام وظیفه را بررسی کند. (در عمل، جزئیات پیچیده می‌شوند زیرا یک زمان‌اجرا ناهمگام ممکن است از نخ‌های سیستم‌عامل در پشت صحنه به‌عنوان بخشی از نحوه مدیریت هم‌زمانی استفاده کند، بنابراین تضمین عدالت می‌تواند کار بیشتری برای یک زمان‌اجرا باشد—اما همچنان ممکن است!) زمان‌اجراها نیازی به تضمین عدالت برای هیچ عملیات داده‌شده ندارند، و اغلب APIهای متفاوتی ارائه می‌دهند تا به شما اجازه دهند انتخاب کنید که آیا عدالت می‌خواهید یا نه.

برخی از این تغییرات روی آینده‌ها و انتظار روی آن‌ها را بررسی کردیم. در ادامه، به بررسی انتقال داده بین آینده‌ها با استفاده از ارسال پیام می‌پردازیم.

## ارسال داده بین دو وظیفه با استفاده از ارسال پیام

اشتراک‌گذاری داده بین آینده‌ها نیز آشنا خواهد بود: دوباره از ارسال پیام استفاده خواهیم کرد، اما این بار با نسخه‌های ناهمگام از انواع و توابع. ما مسیری کمی متفاوت از آنچه در بخش "انتقال داده بین نخ‌ها با ارسال پیام" در فصل شانزدهم انجام دادیم طی خواهیم کرد تا برخی از تفاوت‌های کلیدی بین هم‌زمانی مبتنی بر نخ و مبتنی بر آینده را نشان دهیم. در **فهرست کد 17-9**، فقط با یک بلوک ناهمگام شروع خواهیم کرد—نه ایجاد یک نخ جداگانه همان‌طور که یک نخ جداگانه ایجاد کردیم.

**فایل: src/main.rs**

```rust
        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("received '{received}'");
```

**فهرست کد 17-9**: ایجاد یک کانال ناهمگام و اختصاص دو نیمه به `tx` و `rx`

در اینجا، از `trpl::channel` استفاده می‌کنیم، نسخه ناهمگام از API کانال چندتولیدکننده، تک‌مصرف‌کننده که با نخ‌ها در فصل شانزدهم استفاده کردیم. نسخه ناهمگام API فقط کمی متفاوت از نسخه مبتنی بر نخ است: از یک دریافت‌کننده قابل‌تغییر به جای یک دریافت‌کننده غیرقابل‌تغییر `rx` استفاده می‌کند، و متد `recv` آن آینده‌ای تولید می‌کند که ما باید انتظار کنیم نه اینکه مقدار را مستقیماً تولید کند. حالا می‌توانیم پیام‌ها را از فرستنده به دریافت‌کننده ارسال کنیم. توجه کنید که نیازی به ایجاد یک نخ جداگانه یا حتی یک وظیفه نداریم؛ ما فقط نیاز به انتظار روی فراخوانی `rx.recv` داریم.

متد `Receiver::recv` هم‌زمان در `std::mpsc::channel` تا دریافت یک پیام بلاک می‌کند. متد `trpl::Receiver::recv` این کار را انجام نمی‌دهد، زیرا ناهمگام است. به جای بلاک کردن، کنترل را به زمان‌اجرا برمی‌گرداند تا وقتی که یک پیام دریافت شود یا سمت ارسال کانال بسته شود. در مقابل، نیازی به انتظار روی فراخوانی `send` نداریم، زیرا بلاک نمی‌کند. نیازی به آن ندارد، زیرا کانالی که به آن ارسال می‌کنیم نامحدود است.

**توجه**: چون تمام این کد ناهمگام در یک بلوک ناهمگام در یک فراخوانی `trpl::block_on` اجرا می‌شود، همه چیز درون آن می‌تواند از بلاک کردن اجتناب کند. با این حال، کد خارج از آن روی بازگشت تابع `block_on` بلاک خواهد شد. این کل هدف تابع `trpl::block_on` است: به شما امکان می‌دهد انتخاب کنید کجا روی مجموعه‌ای از کد ناهمگام بلاک کنید، و بنابراین کجا بین کد هم‌زمان و ناهمگام جابه‌جا شوید.

دو چیز درباره این مثال توجه کنید. اول، پیام بلافاصله می‌رسد. دوم، اگرچه از یک آینده اینجا استفاده می‌کنیم، هنوز هیچ هم‌زمانی وجود ندارد. همه چیز در لیست به ترتیب اتفاق می‌افتد، درست همان‌طور که اگر هیچ آینده‌ای درگیر نبود.

بیایید با ارسال یک سری پیام و خوابیدن بین آن‌ها، اول بخشی را حل کنیم، همان‌طور که در **فهرست کد 17-10** نشان داده شده است.

**فایل: src/main.rs**

```rust
        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
```

**فهرست کد 17-10**: ارسال و دریافت چندین پیام روی کانال ناهمگام و خوابیدن با یک انتظار بین هر پیام

علاوه بر ارسال پیام‌ها، باید آن‌ها را دریافت کنیم. در این مورد، چون می‌دانیم چند پیام در راه است، می‌توانستیم این کار را به‌صورت دستی با فراخوانی `rx.recv().await` چهار بار انجام دهیم. در جهان واقعی، با این حال، معمولاً روی تعداد نامعلومی از پیام‌ها منتظر خواهیم بود، بنابراین نیاز به ادامه انتظار تا تعیین اینکه پیام‌های بیشتری وجود ندارد داریم.

در **فهرست کد 16-10**، از یک حلقه `for` برای پردازش تمام آیتم‌های دریافت‌شده از یک کانال هم‌زمان استفاده کردیم. **Rust** هنوز روشی برای استفاده از یک حلقه `for` با یک سری آیتم تولیدشده به‌صورت ناهمگام ندارد، بنابراین نیاز به ادامه انتظار تا پایان داریم.

در **فهرست کد 17-9**، از یک حلقه `while let` شرطی استفاده کردیم که نسخه حلقه‌ای از ساختار `if let` است که در بخش "جریان کنترل با `if let` و `let else`" در فصل ششم دیدیم. حلقه تا زمانی که الگویی که مشخص می‌کند با مقدار مطابقت داشته باشد ادامه خواهد یافت.

فراخوانی `rx.recv` یک آینده تولید می‌کند که ما انتظار می‌کنیم. زمان‌اجرا آینده را تا آماده شدن متوقف خواهد کرد. وقتی یک پیام می‌رسد، آینده به `Some(message)` حل خواهد شد به تعداد دفعاتی که یک پیام می‌رسد. وقتی کانال بسته می‌شود، صرف‌نظر از اینکه آیا پیام‌هایی رسیده‌اند یا نه، آینده به جای آن به `None` حل خواهد شد تا نشان دهد که مقادیر بیشتری وجود ندارد و بنابراین باید polling را متوقف کنیم—یعنی انتظار را متوقف کنیم.

حلقه `while let` تمام این را کنار هم می‌گذارد. اگر نتیجه فراخوانی `rx.recv().await` برابر با `Some(message)` باشد، به پیام دسترسی پیدا می‌کنیم و می‌توانیم از آن در بدنه حلقه استفاده کنیم، درست همان‌طور که می‌توانستیم با `if let`. اگر نتیجه `None` باشد، حلقه پایان می‌یابد. هر بار که حلقه کامل می‌شود، دوباره به نقطه انتظار می‌رسد، بنابراین زمان‌اجرا دوباره آن را متوقف می‌کند تا پیام بعدی برسد.

کد حالا با موفقیت تمام پیام‌ها را ارسال و دریافت می‌کند. متأسفانه، هنوز چند مشکل وجود دارد. برای یکی، پیام‌ها در فواصل نیم‌ثانیه نمی‌رسند. آن‌ها همه با هم، ۲ ثانیه (۲۰۰۰ میلی‌ثانیه) پس از شروع برنامه می‌رسند. برای دیگری، این برنامه هرگز خارج نمی‌شود! در عوض، برای پیام‌های جدید برای همیشه منتظر می‌ماند. باید با استفاده از `ctrl-C` آن را خاموش کنید.

بیایید اول مشکل پیام‌ها را بررسی کنیم که چرا همه با هم پس از تأخیر کامل می‌رسند، نه با تأخیر بین هر کدام. درون یک بلوک `async` داده‌شده، ترتیب ظاهر شدن کلمات کلیدی `await` در کد همچنین ترتیب اجرای آن‌ها وقتی برنامه اجرا می‌شود است.

فقط یک بلوک `async` در **فهرست کد 17-10** وجود دارد، بنابراین همه چیز درون آن به‌صورت خطی اجرا می‌شود. هنوز هیچ هم‌زمانی وجود ندارد. تمام فراخوانی‌های `tx.send` اتفاق می‌افتد، در میان تمام فراخوانی‌های `trpl::sleep` و نقاط انتظار مرتبط با آن‌ها. تنها پس از آن حلقه `while let` می‌تواند هر یک از نقاط انتظار روی فراخوانی‌های `recv` را طی کند.

برای دریافت رفتاری که می‌خواهیم، جایی که تأخیر خواب بین هر پیام اتفاق می‌افتد، نیاز به قرار دادن عملیات `tx` و `rx` در بلوک‌های `async` خودشان داریم، همان‌طور که در **فهرست کد 17-11** نشان داده شده است. سپس زمان‌اجرا می‌تواند هر کدام را جداگانه با استفاده از `trpl::join` تا پایان اجرا کند، درست همان‌طور که در **فهرست کد 17-8** انجام دادیم. دوباره، نتیجه فراخوانی `trpl::join` را انتظار می‌کنیم، نه آینده‌های جداگانه. اگر آینده‌های جداگانه را به ترتیب انتظار می‌کردیم، فقط دوباره به جریان ترتیبی برمی‌گشتیم—دقیقاً آنچه سعی داریم انجام ندهیم.

**فایل: src/main.rs**

```rust
        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
```

**فهرست کد 17-11**: جداسازی `send` و `recv` در بلوک‌های `async` خودشان و انتظار روی آینده‌های آن بلوک‌ها

با کد به‌روزرسانی‌شده در **فهرست کد 17-11**، پیام‌ها در فواصل ۵۰۰ میلی‌ثانیه چاپ می‌شوند، نه همه در یک بار پس از ۲ ثانیه.

برای نسخه‌های بعدی، از `trpl::join!` برای مدیریت آینده اضافی استفاده می‌کنیم: ماکرو `join!` یک تعداد دلخواه آینده را انتظار می‌کند جایی که تعداد آینده‌ها را در زمان کامپایل می‌دانیم. ما در ادامه این فصل درباره انتظار روی مجموعه‌ای از تعداد نامعلوم آینده بحث خواهیم کرد.

این کانال ناهمگام همچنین یک کانال چندتولیدکننده است، بنابراین اگر بخواهیم پیام‌ها را از چندین آینده ارسال کنیم، می‌توانیم `tx` را کلون کنیم، همان‌طور که در **فهرست کد 17-12** نشان داده شده است.

**فایل: src/main.rs**

```rust
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join!(tx1_fut, tx_fut, rx_fut);
```

**فهرست کد 17-12**: استفاده از چندین تولیدکننده با بلوک‌های `async`

ابتدا، `tx` را کلون می‌کنیم و `tx1` را خارج از اولین بلوک `async` ایجاد می‌کنیم. ما `tx1` را به آن بلوک `move` می‌کنیم درست همان‌طور که قبلاً با `tx` انجام دادیم. سپس، بعداً، `tx` اصلی را به یک بلوک `async` جدید `move` می‌کنیم، جایی که پیام‌های بیشتری را با تأخیر کمی کندتر ارسال می‌کنیم. ما اتفاقاً این بلوک `async` جدید را پس از بلوک `async` برای دریافت پیام‌ها قرار دادیم، اما می‌توانست قبل از آن هم باشد. کلید ترتیب انتظار روی آینده‌هاست، نه ترتیب ایجاد آن‌ها.

هر دو بلوک `async` برای ارسال پیام‌ها باید بلوک‌های `async move` باشند تا هم `tx` و هم `tx1` وقتی آن بلوک‌ها پایان می‌یابند آزاد شوند. در غیر این صورت، دوباره به همان حلقه بی‌نهایت که از آن شروع کردیم برمی‌گردیم.

حالا تمام پیام‌ها را از هر دو آینده ارسال‌کننده می‌بینیم، و چون آینده‌های ارسال‌کننده از تأخیرهای کمی متفاوت پس از ارسال استفاده می‌کنند، پیام‌ها نیز در آن فواصل متفاوت دریافت می‌شوند:

```
received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
```

ما بررسی کردیم که چگونه از ارسال پیام برای انتقال داده بین آینده‌ها استفاده کنیم، چگونه کد درون یک بلوک `async` به‌صورت ترتیبی اجرا می‌شود، چگونه مالکیت را به یک بلوک `async` منتقل کنیم، و چگونه چندین آینده را با `join!` جوین کنیم. در ادامه، بحث خواهیم کرد که چگونه و چرا به زمان‌اجرا بگوییم که می‌تواند به وظیفه دیگری جابه‌جا شود.
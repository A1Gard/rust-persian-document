# استفاده از نخ‌ها برای اجرای همزمان کد

در اکثر سیستم‌عامل‌های امروزی، کد یک برنامه اجرا شده در یک **پروسه** (process) اجرا می‌شود و سیستم‌عامل چندین پروسه را به‌صورت همزمان مدیریت می‌کند. در داخل یک برنامه، می‌توانید بخش‌های مستقلی داشته باشید که به‌صورت همزمان اجرا شوند. این بخش‌های مستقل که این اجرای همزمان را انجام می‌دهند، **نخ‌ها** (threads) نامیده می‌شوند. برای مثال، یک سرور وب می‌تواند چندین نخ داشته باشد تا بتواند به بیش از یک درخواست به‌صورت همزمان پاسخ دهد.

تقسیم محاسبات برنامه‌تان به چندین نخ برای اجرای همزمان چندین کار می‌تواند عملکرد را بهبود ببخشد، اما در عین حال پیچیدگی را نیز افزایش می‌دهد. از آنجا که نخ‌ها می‌توانند به‌صورت همزمان اجرا شوند، هیچ تضمینی درباره ترتیب اجرای بخش‌های مختلف کد در نخ‌های مختلف وجود ندارد. این می‌تواند منجر به مشکلاتی مانند موارد زیر شود:

- **شرایط رقابتی** (Race Conditions): زمانی که نخ‌ها به داده‌ها یا منابع به ترتیب ناسازگار دسترسی پیدا می‌کنند.
- **بن‌بست** (Deadlocks): زمانی که دو نخ منتظر یکدیگر هستند و هیچ‌کدام نمی‌توانند ادامه دهند.
- **باگ‌هایی که فقط در شرایط خاص رخ می‌دهند**: این باگ‌ها به سختی قابل تولید مجدد و رفع هستند.

Rust تلاش می‌کند اثرات منفی استفاده از نخ‌ها را کاهش دهد، اما برنامه‌نویسی در محیط چندنخی همچنان نیاز به تفکر دقیق و ساختار کدی متفاوت از برنامه‌هایی دارد که در یک نخ اجرا می‌شوند.

زبان‌های برنامه‌نویسی نخ‌ها را به روش‌های مختلفی پیاده‌سازی می‌کنند و بسیاری از سیستم‌عامل‌ها یک API ارائه می‌دهند که زبان می‌تواند برای ایجاد نخ‌های جدید از آن استفاده کند. کتابخانه استاندارد Rust از مدل پیاده‌سازی نخ **1:1** استفاده می‌کند، به این معنا که هر نخ زبانی به یک نخ سیستم‌عامل نگاشت می‌شود. کریت‌هایی (crates) وجود دارند که مدل‌های دیگری از نخ‌ها را پیاده‌سازی می‌کنند و تعادل‌های متفاوتی نسبت به مدل 1:1 ارائه می‌دهند. (سیستم غیرهمزمان Rust، که در فصل بعدی بررسی خواهیم کرد، رویکرد دیگری برای همزمانی ارائه می‌دهد.)

## ایجاد یک نخ جدید با `spawn`

برای ایجاد یک نخ جدید، تابع `thread::spawn` را فراخوانی می‌کنیم و یک **کلوژر** (closure) به آن پاس می‌دهیم (در فصل سیزدهم درباره کلوژرها صحبت کردیم) که شامل کدی است که می‌خواهیم در نخ جدید اجرا شود. مثال در Listing 16-1 متنی را از نخ اصلی و متنی دیگر را از یک نخ جدید چاپ می‌کند:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از نخ تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("سلام، شماره {i} از نخ اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }
}
```

> **توجه**: وقتی نخ اصلی یک برنامه Rust به پایان می‌رسد، تمام نخ‌های تولیدشده خاموش می‌شوند، چه کارشان تمام شده باشد یا نه.

**خروجی نمونه** (ممکن است هر بار کمی متفاوت باشد):

```
سلام، شماره 1 از نخ اصلی!
سلام، شماره 1 از نخ تولیدشده!
سلام، شماره 2 از نخ اصلی!
سلام، شماره 2 از نخ تولیدشده!
سلام، شماره 3 از نخ اصلی!
سلام، شماره 3 از نخ تولیدشده!
سلام، شماره 4 از نخ اصلی!
سلام، شماره 4 از نخ تولیدشده!
سلام، شماره 5 از نخ تولیدشده!
```

**توضیح**:
- فراخوانی‌های `thread::sleep` باعث می‌شوند یک نخ اجرای خود را برای مدت کوتاهی متوقف کند و به نخ دیگری اجازه اجرا دهد. نخ‌ها احتمالاً به نوبت اجرا می‌شوند، اما این تضمین‌شده نیست و بستگی به نحوه زمان‌بندی نخ‌ها توسط سیستم‌عامل دارد.
- در این اجرا، نخ اصلی ابتدا چاپ کرده، اگرچه دستور چاپ از نخ تولیدشده در کد زودتر ظاهر شده است.
- با وجود اینکه به نخ تولیدشده گفتیم تا `i` برابر 9 چاپ کند، فقط تا 5 پیش رفت، زیرا نخ اصلی زودتر خاموش شد.

**نکته**: اگر این کد را اجرا کنید و فقط خروجی از نخ اصلی ببینید یا هیچ همپوشانی مشاهده نکنید، سعی کنید اعداد در محدوده‌ها را افزایش دهید تا فرصت‌های بیشتری برای جابه‌جایی بین نخ‌ها توسط سیستم‌عامل ایجاد شود.

## انتظار برای اتمام تمام نخ‌ها با استفاده از دسته‌های `join`

کد در Listing 16-1 نه‌تنها اغلب نخ تولیدشده را به دلیل پایان یافتن نخ اصلی زودتر متوقف می‌کند، بلکه چون هیچ تضمینی درباره ترتیب اجرای نخ‌ها وجود ندارد، نمی‌توانیم مطمئن باشیم که نخ تولیدشده اصلاً اجرا خواهد شد!

می‌توانیم این مشکل را با ذخیره مقدار بازگشتی `thread::spawn` در یک متغیر برطرف کنیم. نوع بازگشتی `thread::spawn` یک `JoinHandle<T>` است. یک `JoinHandle<T>` یک مقدار مالکیتی است که وقتی متد `join` را روی آن فراخوانی می‌کنیم، منتظر می‌ماند تا نخ آن به پایان برسد. Listing 16-2 نشان می‌دهد چگونه از `JoinHandle<T>` برای نخی که در Listing 16-1 ایجاد کردیم استفاده کنیم و با فراخوانی `join` اطمینان حاصل کنیم که نخ تولیدشده قبل از خروج `main` به پایان می‌رسد:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از نخ تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("سلام، شماره {i} از نخ اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

**خروجی نمونه**:

```
سلام، شماره 1 از نخ اصلی!
سلام، شماره 2 از نخ اصلی!
سلام، شماره 1 از نخ تولیدشده!
سلام، شماره 3 از نخ اصلی!
سلام، شماره 2 از نخ تولیدشده!
سلام، شماره 4 از نخ اصلی!
سلام، شماره 3 از نخ تولیدشده!
سلام، شماره 4 از نخ تولیدشده!
سلام، شماره 5 از نخ تولیدشده!
سلام، شماره 6 از نخ تولیدشده!
سلام، شماره 7 از نخ تولیدشده!
سلام، شماره 8 از نخ تولیدشده!
سلام، شماره 9 از نخ تولیدشده!
```

**توضیح**:
- فراخوانی `join` روی دسته (`handle`) نخ فعلی را تا زمانی که نخی که دسته نشان‌دهنده آن است پایان یابد، مسدود (block) می‌کند. مسدود کردن یک نخ به این معناست که آن نخ از انجام کار یا خروج جلوگیری می‌شود.
- چون فراخوانی `join` را بعد از حلقه `for` نخ اصلی قرار دادیم، دو نخ به‌صورت متناوب ادامه می‌دهند، اما نخ اصلی به دلیل فراخوانی `handle.join()` منتظر می‌ماند و تا زمانی که نخ تولیدشده به پایان نرسد، پایان نمی‌یابد.

اما بیایید ببینیم اگر به جای این، `handle.join()` را قبل از حلقه `for` در `main` قرار دهیم چه اتفاقی می‌افتد:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از نخ تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("سلام، شماره {i} از نخ اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }
}
```

**خروجی**:

```
سلام، شماره 1 از نخ تولیدشده!
سلام، شماره 2 از نخ تولیدشده!
سلام، شماره 3 از نخ تولیدشده!
سلام، شماره 4 از نخ تولیدشده!
سلام، شماره 5 از نخ تولیدشده!
سلام، شماره 6 از نخ تولیدشده!
سلام، شماره 7 از نخ تولیدشده!
سلام، شماره 8 از نخ تولیدشده!
سلام، شماره 9 از نخ تولیدشده!
سلام، شماره 1 از نخ اصلی!
سلام، شماره 2 از نخ اصلی!
سلام، شماره 3 از نخ اصلی!
سلام، شماره 4 از نخ اصلی!
```

**توضیح**:
- نخ اصلی منتظر می‌ماند تا نخ تولیدشده به پایان برسد و سپس حلقه `for` خود را اجرا می‌کند، بنابراین خروجی دیگر به‌صورت متناوب نخواهد بود.
- جزئیات کوچک، مانند محل فراخوانی `join`، می‌تواند روی اینکه آیا نخ‌های شما به‌صورت همزمان اجرا می‌شوند یا نه تأثیر بگذارد.

## استفاده از کلوژرهای `move` با نخ‌ها

اغلب از کلمه‌کلید `move` با کلوژرهایی که به `thread::spawn` پاس می‌دهیم استفاده می‌کنیم، زیرا کلوژر در این حالت مالکیت مقادیری که از محیط استفاده می‌کند را می‌گیرد و این مالکیت را از یک نخ به نخ دیگر منتقل می‌کند. در بخش «ضبط محیط با کلوژرها» در فصل سیزدهم، درباره `move` در زمینه کلوژرها صحبت کردیم. حالا تمرکز بیشتری روی تعامل بین `move` و `thread::spawn` خواهیم داشت.

در Listing 16-1 متوجه شدید که کلوژری که به `thread::spawn` پاس دادیم هیچ آرگومانی نمی‌گیرد: ما از هیچ داده‌ای از نخ اصلی در کد نخ تولیدشده استفاده نکردیم. برای استفاده از داده‌های نخ اصلی در نخ تولیدشده، کلوژر نخ تولیدشده باید مقادیری که نیاز دارد را ضبط کند. Listing 16-3 تلاشی برای ایجاد یک وکتور در نخ اصلی و استفاده از آن در نخ تولیدشده را نشان می‌دهد. اما این هنوز کار نمی‌کند، همان‌طور که در ادامه خواهید دید:

```rust
// این کد کامپایل نمی‌شود!
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    handle.join().unwrap();
}
```

**خطای کامپایل**:

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
  |                                        - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

**توضیح خطا**:
- کلوژر از `v` استفاده می‌کند، بنابراین `v` را ضبط می‌کند و آن را بخشی از محیط کلوژر می‌سازد. چون `thread::spawn` این کلوژر را در یک نخ جدید اجرا می‌کند، باید بتوانیم در آن نخ جدید به `v` دسترسی داشته باشیم.
- Rust نحوه ضبط `v` را استنباط می‌کند و چون `println!` فقط به یک ارجاع به `v` نیاز دارد، کلوژر سعی می‌کند `v` را قرض (borrow) کند.
- مشکل اینجاست که Rust نمی‌تواند بگوید نخ تولیدشده تا چه زمانی اجرا خواهد شد، بنابراین نمی‌داند آیا ارجاع به `v` همیشه معتبر خواهد بود یا نه.

Listing 16-4 سناریویی را نشان می‌دهد که احتمال بیشتری دارد ارجاع به `v` معتبر نباشد:

```rust
// این کد کامپایل نمی‌شود!
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    drop(v); // اوه نه!

    handle.join().unwrap();
}
```

**توضیح**:
- اگر Rust به ما اجازه اجرای این کد را می‌داد، این احتمال وجود داشت که نخ تولیدشده بلافاصله به پس‌زمینه منتقل شود بدون اینکه اصلاً اجرا شود. نخ تولیدشده یک ارجاع به `v` در داخل خود دارد، اما نخ اصلی بلافاصله `v` را حذف (drop) می‌کند (با استفاده از تابع `drop` که در فصل پانزدهم بحث کردیم).
- وقتی نخ تولیدشده شروع به اجرا می‌کند، `v` دیگر معتبر نیست، بنابراین ارجاع به آن نیز نامعتبر است. اوه نه!

برای رفع خطای کامپایل در Listing 16-3، می‌توانیم از توصیه پیام خطا استفاده کنیم:

```
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

با افزودن کلمه‌کلید `move` قبل از کلوژر، کلوژر را مجبور می‌کنیم مالکیت مقادیری که استفاده می‌کند را بگیرد، به جای اینکه اجازه دهد Rust استنباط کند که باید مقادیر را قرض کند. تغییر Listing 16-3 که در Listing 16-5 نشان داده شده است، کامپایل می‌شود و همان‌طور که انتظار داریم اجرا می‌شود:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    handle.join().unwrap();
}
```

**توضیح**:
- با استفاده از کلمه‌کلید `move`، ما به Rust تضمین می‌دهیم که نخ اصلی دیگر از `v` استفاده نخواهد کرد، بنابراین نخ تولیدشده می‌تواند به‌طور امن مالکیت `v` را داشته باشد.

ممکن است وسوسه شویم که همین روش را برای رفع کد در Listing 16-4 که نخ اصلی `drop` را فراخوانی می‌کند امتحان کنیم. اما این رفع کار نخواهد کرد، زیرا چیزی که Listing 16-4 سعی در انجام آن دارد به دلیلی متفاوت ممنوع است. اگر `move` را به کلوژر اضافه کنیم، `v` به محیط کلوژر منتقل می‌شود و دیگر نمی‌توانیم در نخ اصلی روی آن `drop` فراخوانی کنیم. در این صورت، خطای کامپایل زیر را دریافت می‌کنیم:

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
   |                                        - variable moved due to use in closure
...
10 |     drop(v); // اوه نه!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

**توضیح**:
- قوانین مالکیت Rust再一次 ما را نجات داده‌اند! خطای Listing 16-3 به این دلیل رخ داد که Rust محافظه‌کارانه عمل کرد و فقط `v` را برای نخ قرض کرد، که به این معنا بود که نخ اصلی به‌طور نظری می‌توانست ارجاع نخ تولیدشده را نامعتبر کند.
- با گفتن به Rust که مالکیت `v` را به نخ تولیدشده منتقل کند، به Rust تضمین می‌دهیم که نخ اصلی دیگر از `v` استفاده نخواهد کرد.
- اگر Listing 16-4 را به همین روش تغییر دهیم، وقتی سعی می‌کنیم از `v` در نخ اصلی استفاده کنیم، قوانین مالکیت را نقض می‌کنیم. کلمه‌کلید `move` پیش‌فرض محافظه‌کارانه قرض‌گیری Rust را لغو می‌کند، اما اجازه نمی‌دهد قوانین مالکیت را نقض کنیم.

حالا که نخ‌ها و متدهای ارائه‌شده توسط API نخ‌ها را پوشش دادیم، بیایید به موقعیت‌هایی نگاه کنیم که می‌توانیم از نخ‌ها در آن‌ها استفاده کنیم.
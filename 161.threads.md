# استفاده از رسیمان‌ها برای اجرای همزمان کد

در اکثر سیستم‌عامل‌های امروزی، کد یک برنامه اجرا شده در یک **پروسه** (process) اجرا می‌شود و سیستم‌عامل چندین پروسه را به‌صورت همزمان مدیریت می‌کند. در داخل یک برنامه، می‌توانید بخش‌های مستقلی داشته باشید که به‌صورت همزمان اجرا شوند. این بخش‌های مستقل که این اجرای همزمان را انجام می‌دهند، **رسیمان‌ها** (threads) نامیده می‌شوند. برای مثال، یک سرور وب می‌تواند چندین رسیمان داشته باشد تا بتواند به بیش از یک درخواست به‌صورت همزمان پاسخ دهد.

تقسیم محاسبات برنامه‌تان به چندین رسیمان برای اجرای همزمان چندین کار می‌تواند عملکرد را بهبود ببخشد، اما در عین حال پیچیدگی را نیز افزایش می‌دهد. از آنجا که رسیمان‌ها می‌توانند به‌صورت همزمان اجرا شوند، هیچ تضمینی درباره ترتیب اجرای بخش‌های مختلف کد در رسیمان‌های مختلف وجود ندارد. این می‌تواند منجر به مشکلاتی مانند موارد زیر شود:

- **شرایط رقابتی** (Race Conditions): زمانی که رسیمان‌ها به داده‌ها یا منابع به ترتیب ناسازگار دسترسی پیدا می‌کنند.
- **بن‌بست** (Deadlocks): زمانی که دو ریسمان منتظر یکدیگر هستند و هیچ‌کدام نمی‌توانند ادامه دهند.
- **باگ‌هایی که فقط در شرایط خاص رخ می‌دهند**: این باگ‌ها به سختی قابل تولید مجدد و رفع هستند.

Rust تلاش می‌کند اثرات منفی استفاده از رسیمان‌ها را کاهش دهد، اما برنامه‌نویسی در محیط چند ریسمانی همچنان نیاز به تفکر دقیق و ساختار کدی متفاوت از برنامه‌هایی دارد که در یک رسیمان اجرا می‌شوند.

زبان‌های برنامه‌نویسی رسیمان‌ها را به روش‌های مختلفی پیاده‌سازی می‌کنند و بسیاری از سیستم‌عامل‌ها یک API ارائه می‌دهند که زبان می‌تواند برای ایجاد رسیمان‌های جدید از آن استفاده کند. کتابخانه استاندارد Rust از مدل پیاده‌سازی رسیمان **1:1** استفاده می‌کند، به این معنا که هر رسیمان زبانی به یک رسیمان سیستم‌عامل نگاشت می‌شود. کریت‌هایی (crates) وجود دارند که مدل‌های دیگری از رسیمان‌ها را پیاده‌سازی می‌کنند و تعادل‌های متفاوتی نسبت به مدل 1:1 ارائه می‌دهند. (سیستم غیرهمزمان Rust، که در فصل بعدی بررسی خواهیم کرد، رویکرد دیگری برای همزمانی ارائه می‌دهد.)

## ایجاد یک رسیمان جدید با `spawn`

برای ایجاد یک رسیمان جدید، تابع `thread::spawn` را فراخوانی می‌کنیم و یک **بسته‌** (closure) به آن پاس می‌دهیم (در فصل سیزدهم درباره بسته‌ها صحبت کردیم) که شامل کدی است که می‌خواهیم در رسیمان جدید اجرا شود. مثال در فهرست کد 16-1 متنی را از رسیمان اصلی و متنی دیگر را از یک رسیمان جدید چاپ می‌کند:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از رسیمان تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("سلام، شماره {i} از رسیمان اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }
}
```

> **توجه**: وقتی رسیمان اصلی یک برنامه Rust به پایان می‌رسد، تمام رسیمان‌های تولیدشده خاموش می‌شوند، چه کارشان تمام شده باشد یا نه.

**خروجی نمونه** (ممکن است هر بار کمی متفاوت باشد):

```
سلام، شماره 1 از رسیمان اصلی!
سلام، شماره 1 از رسیمان تولیدشده!
سلام، شماره 2 از رسیمان اصلی!
سلام، شماره 2 از رسیمان تولیدشده!
سلام، شماره 3 از رسیمان اصلی!
سلام، شماره 3 از رسیمان تولیدشده!
سلام، شماره 4 از رسیمان اصلی!
سلام، شماره 4 از رسیمان تولیدشده!
سلام، شماره 5 از رسیمان تولیدشده!
```

**توضیح**:
- فراخوانی‌های `thread::sleep` باعث می‌شوند یک رسیمان اجرای خود را برای مدت کوتاهی متوقف کند و به ریسمان دیگری اجازه اجرا دهد. رسیمان‌ها احتمالاً به نوبت اجرا می‌شوند، اما این تضمین‌شده نیست و بستگی به نحوه زمان‌بندی رسیمان‌ها توسط سیستم‌عامل دارد.
- در این اجرا،رسیمان اصلی ابتدا چاپ کرده، اگرچه دستور چاپ از رسیمان تولیدشده در کد زودتر ظاهر شده است.
- با وجود اینکه به ریسمان تولیدشده گفتیم تا `i` برابر 9 چاپ کند، فقط تا 5 پیش رفت، زیرا رسیمان اصلی زودتر خاموش شد.

**نکته**: اگر این کد را اجرا کنید و فقط خروجی از رسیمان اصلی ببینید یا هیچ همپوشانی مشاهده نکنید، سعی کنید اعداد در محدوده‌ها را افزایش دهید تا فرصت‌های بیشتری برای جابه‌جایی بین رسیمان‌ها توسط سیستم‌عامل ایجاد شود.

## انتظار برای اتمام تمام رسیمان‌ها با استفاده از دسته‌های `join`

کد در فهرست کد 16-1 نه‌تنها اغلب رسیمان تولیدشده را به دلیل پایان یافتن رسیمان اصلی زودتر متوقف می‌کند، بلکه چون هیچ تضمینی درباره ترتیب اجرای رسیمان‌ها وجود ندارد، نمی‌توانیم مطمئن باشیم کهر رسیمان تولیدشده اصلاً اجرا خواهد شد!

می‌توانیم این مشکل را با ذخیره مقدار بازگشتی `thread::spawn` در یک متغیر برطرف کنیم. نوع بازگشتی `thread::spawn` یک `JoinHandle<T>` است. یک `JoinHandle<T>` یک مقدار مالکیتی است که وقتی متد `join` را روی آن فراخوانی می‌کنیم، منتظر می‌ماند تا رسیمان آن به پایان برسد. فهرست کد 16-2 نشان می‌دهد چگونه از `JoinHandle<T>` برای رسیمانی که در فهرست کد 16-1 ایجاد کردیم استفاده کنیم و با فراخوانی `join` اطمینان حاصل کنیم کهر رسیمان تولیدشده قبل از خروج `main` به پایان می‌رسد:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از رسیمان تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("سلام، شماره {i} از رسیمان اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

**خروجی نمونه**:

```
سلام، شماره 1 از رسیمان اصلی!
سلام، شماره 2 از رسیمان اصلی!
سلام، شماره 1 از رسیمان تولیدشده!
سلام، شماره 3 از رسیمان اصلی!
سلام، شماره 2 از رسیمان تولیدشده!
سلام، شماره 4 از رسیمان اصلی!
سلام، شماره 3 از رسیمان تولیدشده!
سلام، شماره 4 از رسیمان تولیدشده!
سلام، شماره 5 از رسیمان تولیدشده!
سلام، شماره 6 از رسیمان تولیدشده!
سلام، شماره 7 از رسیمان تولیدشده!
سلام، شماره 8 از رسیمان تولیدشده!
سلام، شماره 9 از رسیمان تولیدشده!
```

**توضیح**:
- فراخوانی `join` روی دسته (`handle`)رسیمان فعلی را تا زمانی که رسیمانی که دسته نشان‌دهنده آن است پایان یابد، مسدود (block) می‌کند. مسدود کردن یک رسیمان به این معناست که آن رسیمان از انجام کار یا خروج جلوگیری می‌شود.
- چون فراخوانی `join` را بعد از حلقه `for`رسیمان اصلی قرار دادیم، دو ریسمان به‌صورت متناوب ادامه می‌دهند، اما رسیمان اصلی به دلیل فراخوانی `handle.join()` منتظر می‌ماند و تا زمانی کهر رسیمان تولیدشده به پایان نرسد، پایان نمی‌یابد.

اما بیایید ببینیم اگر به جای این، `handle.join()` را قبل از حلقه `for` در `main` قرار دهیم چه اتفاقی می‌افتد:

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("سلام، شماره {i} از رسیمان تولیدشده!"); // hi number {i} from the spawned thread!
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("سلام، شماره {i} از رسیمان اصلی!"); // hi number {i} from the main thread!
        thread::sleep(Duration::from_millis(1));
    }
}
```

**خروجی**:

```
سلام، شماره 1 از رسیمان تولیدشده!
سلام، شماره 2 از رسیمان تولیدشده!
سلام، شماره 3 از رسیمان تولیدشده!
سلام، شماره 4 از رسیمان تولیدشده!
سلام، شماره 5 از رسیمان تولیدشده!
سلام، شماره 6 از رسیمان تولیدشده!
سلام، شماره 7 از رسیمان تولیدشده!
سلام، شماره 8 از رسیمان تولیدشده!
سلام، شماره 9 از رسیمان تولیدشده!
سلام، شماره 1 از رسیمان اصلی!
سلام، شماره 2 از رسیمان اصلی!
سلام، شماره 3 از رسیمان اصلی!
سلام، شماره 4 از رسیمان اصلی!
```

**توضیح**:
-رسیمان اصلی منتظر می‌ماند تا رسیمان تولیدشده به پایان برسد و سپس حلقه `for` خود را اجرا می‌کند، بنابراین خروجی دیگر به‌صورت متناوب نخواهد بود.
- جزئیات کوچک، مانند محل فراخوانی `join`، می‌تواند روی اینکه آیا رسیمان‌های شما به‌صورت همزمان اجرا می‌شوند یا نه تأثیر بگذارد.

## استفاده از بسته‌های `move` با رسیمان‌ها

اغلب از کلمه‌کلید `move` با بسته‌هایی که به `thread::spawn` پاس می‌دهیم استفاده می‌کنیم، زیرا بسته‌ در این حالت مالکیت مقادیری که از محیط استفاده می‌کند را می‌گیرد و این مالکیت را از یک رسیمان به ریسمان دیگر منتقل می‌کند. در بخش «ضبط محیط با بسته‌ها» در فصل سیزدهم، درباره `move` در زمینه بسته‌ها صحبت کردیم. حالا تمرکز بیشتری روی تعامل بین `move` و `thread::spawn` خواهیم داشت.

در فهرست کد 16-1 متوجه شدید که بسته‌ی که به `thread::spawn` پاس دادیم هیچ آرگومانی نمی‌گیرد: ما از هیچ داده‌ای از رسیمان اصلی در کد ریسمان تولیدشده استفاده نکردیم. برای استفاده از داده‌های رسیمان اصلی در رسیمان تولیدشده، بسته‌رسیمان تولیدشده باید مقادیری که نیاز دارد را ضبط کند. فهرست کد 16-3 تلاشی برای ایجاد یک وکتور در رسیمان اصلی و استفاده از آن در رسیمان تولیدشده را نشان می‌دهد. اما این هنوز کار نمی‌کند، همان‌طور که در ادامه خواهید دید:


<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    handle.join().unwrap();
}
```

**خطای کامپایل**:

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
  |                                        - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

**توضیح خطا**:
- بسته‌ از `v` استفاده می‌کند، بنابراین `v` را ضبط می‌کند و آن را بخشی از محیط بسته‌ می‌سازد. چون `thread::spawn` این بسته‌ را در یک رسیمان جدید اجرا می‌کند، باید بتوانیم در آن رسیمان جدید به `v` دسترسی داشته باشیم.
- Rust نحوه ضبط `v` را استنباط می‌کند و چون `println!` فقط به یک ارجاع به `v` نیاز دارد، بسته‌ سعی می‌کند `v` را قرض (borrow) کند.
- مشکل اینجاست که Rust نمی‌تواند بگوید ریسمان تولیدشده تا چه زمانی اجرا خواهد شد، بنابراین نمی‌داند آیا ارجاع به `v` همیشه معتبر خواهد بود یا نه.

فهرست کد 16-4 سناریویی را نشان می‌دهد که احتمال بیشتری دارد ارجاع به `v` معتبر نباشد:


<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    drop(v); // اوه نه!

    handle.join().unwrap();
}
```

**توضیح**:
- اگر Rust به ما اجازه اجرای این کد را می‌داد، این احتمال وجود داشت کهر رسیمان تولیدشده بلافاصله به پس‌زمینه منتقل شود بدون اینکه اصلاً اجرا شود.رسیمان تولیدشده یک ارجاع به `v` در داخل خود دارد، اما رسیمان اصلی بلافاصله `v` را حذف (drop) می‌کند (با استفاده از تابع `drop` که در فصل پانزدهم بحث کردیم).
- وقتی رسیمان تولیدشده شروع به اجرا می‌کند، `v` دیگر معتبر نیست، بنابراین ارجاع به آن نیز نامعتبر است. اوه نه!

برای رفع خطای کامپایل در فهرست کد 16-3، می‌توانیم از توصیه پیام خطا استفاده کنیم:

```
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

با افزودن کلمه‌کلید `move` قبل از بسته‌، بسته‌ را مجبور می‌کنیم مالکیت مقادیری که استفاده می‌کند را بگیرد، به جای اینکه اجازه دهد Rust استنباط کند که باید مقادیر را قرض کند. تغییر فهرست کد 16-3 که در فهرست کد 16-5 نشان داده شده است، کامپایل می‌شود و همان‌طور که انتظار داریم اجرا می‌شود:

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
    });

    handle.join().unwrap();
}
```

**توضیح**:
- با استفاده از کلمه‌کلید `move`، ما به Rust تضمین می‌دهیم کهر رسیمان اصلی دیگر از `v` استفاده نخواهد کرد، بنابراین رسیمان تولیدشده می‌تواند به‌طور امن مالکیت `v` را داشته باشد.

ممکن است وسوسه شویم که همین روش را برای رفع کد در فهرست کد 16-4 کهر رسیمان اصلی `drop` را فراخوانی می‌کند امتحان کنیم. اما این رفع کار نخواهد کرد، زیرا چیزی که فهرست کد 16-4 سعی در انجام آن دارد به دلیلی متفاوت ممنوع است. اگر `move` را به بسته‌ اضافه کنیم، `v` به محیط بسته‌ منتقل می‌شود و دیگر نمی‌توانیم در رسیمان اصلی روی آن `drop` فراخوانی کنیم. در این صورت، خطای کامپایل زیر را دریافت می‌کنیم:

```
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("این یک وکتور است: {v:?}"); // Here's a vector: {v:?}
   |                                        - variable moved due to use in closure
...
10 |     drop(v); // اوه نه!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

**توضیح**:
- قوانین مالکیت Rust再一次 ما را نجات داده‌اند! خطای فهرست کد 16-3 به این دلیل رخ داد که Rust محافظه‌کارانه عمل کرد و فقط `v` را برای رسیمان قرض کرد، که به این معنا بود کهر رسیمان اصلی به‌طور نظری می‌توانست ارجاع رسیمان تولیدشده را نامعتبر کند.
- با گفتن به Rust که مالکیت `v` را به ریسمان تولیدشده منتقل کند، به Rust تضمین می‌دهیم کهر رسیمان اصلی دیگر از `v` استفاده نخواهد کرد.
- اگر فهرست کد 16-4 را به همین روش تغییر دهیم، وقتی سعی می‌کنیم از `v` در رسیمان اصلی استفاده کنیم، قوانین مالکیت را نقض می‌کنیم. کلمه‌کلید `move` پیش‌فرض محافظه‌کارانه قرض‌گیری Rust را لغو می‌کند، اما اجازه نمی‌دهد قوانین مالکیت را نقض کنیم.

حالا که رسیمان‌ها و متدهای ارائه‌شده توسط API رسیمان‌ها را پوشش دادیم، بیایید به موقعیت‌هایی نگاه کنیم که می‌توانیم از رسیمان‌ها در آن‌ها استفاده کنیم.
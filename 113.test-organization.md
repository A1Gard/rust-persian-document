# سازماندهی تست‌ها

همان‌طور که در ابتدای این فصل ذکر شد، تست کردن یک رشته پیچیده است و افراد مختلف از اصطلاحات و سازماندهی‌های متفاوتی استفاده می‌کنند. جامعه **Rust** تست‌ها را به دو دسته اصلی تقسیم می‌کند: **تست‌های واحدی** (Unit Tests) و **تست‌های یکپارچه‌سازی** (Integration Tests). تست‌های واحدی کوچک و متمرکز هستند، یک ماژول را به‌صورت جداگانه در هر زمان تست می‌کنند و می‌توانند رابط‌های خصوصی را تست کنند. تست‌های یکپارچه‌سازی کاملاً خارجی نسبت به کتابخانه شما هستند و کد شما را به همان روشی که هر کد خارجی دیگری استفاده می‌کند، استفاده می‌کنند، فقط از رابط عمومی استفاده می‌کنند و ممکن است در هر تست چندین ماژول را تمرین کنند.

نوشتن هر دو نوع تست مهم است تا اطمینان حاصل شود که قطعات کتابخانه شما به‌صورت جداگانه و با هم آن‌طور که انتظار دارید عمل می‌کنند.

## تست‌های واحدی

هدف تست‌های واحدی این است که هر واحد کد را به‌صورت جدا از بقیه کد تست کند تا به‌سرعت مشخص شود کجا کد به‌درستی کار می‌کند یا نمی‌کند. شما تست‌های واحدی را در دایرکتوری `src` در هر فایل همراه با کدی که تست می‌کنند قرار می‌دهید. قرارداد این است که یک ماژول به نام `tests` در هر فایل ایجاد کنید تا توابع تست را در خود جای دهد و این ماژول را با `#[cfg(test)]` حاشیه‌نویسی کنید.

### ماژول تست‌ها و `#[cfg(test)]`

حاشیه‌نویسی `#[cfg(test)]` روی ماژول `tests` به **Rust** می‌گوید که کد تست را فقط وقتی `cargo test` را اجرا می‌کنید کامپایل و اجرا کند، نه وقتی `cargo build` را اجرا می‌کنید. این کار زمان کامپایل را وقتی فقط می‌خواهید کتابخانه را بسازید صرفه‌جویی می‌کند و فضای آرتیفکت کامپایل‌شده را کاهش می‌دهد چون تست‌ها شامل نمی‌شوند. خواهید دید که چون تست‌های یکپارچه‌سازی در یک دایرکتوری متفاوت قرار می‌گیرند، نیازی به حاشیه‌نویسی `#[cfg(test)]` ندارند. با این حال، چون تست‌های واحدی در همان فایل‌های کد قرار می‌گیرند، از `#[cfg(test)]` استفاده خواهید کرد تا مشخص کنید که نباید در نتیجه کامپایل‌شده گنجانده شوند.

به یاد بیاورید که وقتی در بخش اول این فصل پروژه جدید `adder` را تولید کردیم، **Cargo** این کد را برای ما تولید کرد:

**فایل: src/lib.rs**

```rust
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

در ماژول تست‌های تولیدشده به‌صورت خودکار، ویژگی `cfg` مخفف configuration است و به **Rust** می‌گوید که آیتم بعدی فقط در صورت وجود یک گزینه پیکربندی خاص باید گنجانده شود. در این مورد، گزینه پیکربندی `test` است که توسط **Rust** برای کامپایل و اجرای تست‌ها ارائه شده است. با استفاده از ویژگی `cfg`، **Cargo** کد تست ما را فقط اگر ما به‌فعالیت تست‌ها را با `cargo test` اجرا کنیم کامپایل می‌کند. این شامل هر تابع کمکی که ممکن است در این ماژول باشد، علاوه بر توابعی که با `#[test]` حاشیه‌نویسی شده‌اند.

### تست توابع خصوصی

در جامعه تست بحثی وجود دارد درباره اینکه آیا توابع خصوصی باید مستقیماً تست شوند یا خیر، و زبان‌های دیگر تست توابع خصوصی را دشوار یا غیرممکن می‌کنند. صرف‌نظر از اینکه به کدام ایدئولوژی تست پایبند هستید، قوانین حریم خصوصی **Rust** به شما اجازه می‌دهند توابع خصوصی را تست کنید. کد در **جدول 11-12** با تابع خصوصی `internal_adder` را در نظر بگیرید.

**فایل: src/lib.rs**

```rust
pub fn add_two(a: usize) -> usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}
```

**جدول 11-12**: تست یک تابع خصوصی

توجه کنید که تابع `internal_adder` با `pub` علامت‌گذاری نشده است. تست‌ها فقط کد **Rust** هستند، و ماژول `tests` فقط یک ماژول دیگر است. همان‌طور که در بخش «مسیرها برای ارجاع به یک آیتم در درخت ماژول» بحث کردیم، آیتم‌ها در ماژول‌های فرزند می‌توانند از آیتم‌های ماژول‌های والد خود استفاده کنند. در این تست، ما همه آیتم‌های والد ماژول `tests` را با `use super::*` به حوزه می‌آوریم، و سپس تست می‌تواند `internal_adder` را فراخوانی کند. اگر فکر می‌کنید توابع خصوصی نباید تست شوند، هیچ چیزی در **Rust** شما را مجبور به انجام این کار نمی‌کند.

## تست‌های یکپارچه‌سازی

در **Rust**، تست‌های یکپارچه‌سازی کاملاً خارجی نسبت به کتابخانه شما هستند. آن‌ها کتابخانه شما را به همان روشی که هر کد دیگری استفاده می‌کند، استفاده می‌کنند، به این معنی که فقط می‌توانند توابعی را فراخوانی کنند که بخشی از API عمومی کتابخانه شما هستند. هدف آن‌ها این است که تست کنند آیا بسیاری از بخش‌های کتابخانه شما به‌درستی با هم کار می‌کنند. واحدهای کدی که به‌تنهایی به‌درستی کار می‌کنند ممکن است وقتی یکپارچه شوند مشکلاتی داشته باشند، بنابراین پوشش تست کد یکپارچه‌شده نیز مهم است. برای ایجاد تست‌های یکپارچه‌سازی، ابتدا به یک دایرکتوری `tests` نیاز دارید.

### دایرکتوری `tests`

ما یک دایرکتوری `tests` در سطح بالای دایرکتوری پروژه‌مان، کنار `src`، ایجاد می‌کنیم. **Cargo** می‌داند که باید فایل‌های تست یکپارچه‌سازی را در این دایرکتوری جستجو کند. سپس می‌توانیم هر تعداد فایل تست که می‌خواهیم بسازیم، و **Cargo** هر یک از فایل‌ها را به‌عنوان یک crate جداگانه کامپایل خواهد کرد.

بیایید یک تست یکپارچه‌سازی ایجاد کنیم. با کد موجود در **جدول 11-12** که هنوز در فایل `src/lib.rs` است، یک دایرکتوری `tests` بسازید و یک فایل جدید به نام `tests/integration_test.rs` ایجاد کنید. ساختار دایرکتوری شما باید شبیه این باشد:

```
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

کد موجود در **جدول 11-13** را در فایل `tests/integration_test.rs` وارد کنید.

**فایل: tests/integration_test.rs**

```rust
use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}
```

**جدول 11-13**: یک تست یکپارچه‌سازی از یک تابع در crate `adder`

هر فایل در دایرکتوری `tests` یک crate جداگانه است، بنابراین باید کتابخانه‌مان را به حوزه هر crate تست بیاوریم. به همین دلیل، در بالای کد `use adder::add_two;` را اضافه می‌کنیم، که در تست‌های واحدی نیازی به آن نداشتیم.

نیازی به حاشیه‌نویسی هیچ کدی در `tests/integration_test.rs` با `#[cfg(test)]` نیست. **Cargo** دایرکتوری `tests` را به‌صورت ویژه درمان می‌کند و فایل‌های این دایرکتوری را فقط وقتی `cargo test` را اجرا کنیم کامپایل می‌کند. حالا `cargo test` را اجرا کنید:

```bash
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

سه بخش خروجی شامل تست‌های واحدی، تست یکپارچه‌سازی، و تست‌های مستندات است. توجه کنید که اگر هر تستی در یک بخش شکست بخورد، بخش‌های بعدی اجرا نخواهند شد. برای مثال، اگر یک تست واحدی شکست بخورد، خروجی برای تست‌های یکپارچه‌سازی و مستندات وجود نخواهد داشت چون این تست‌ها فقط در صورتی اجرا می‌شوند که همه تست‌های واحدی موفق شوند.

بخش اول برای تست‌های واحدی همان چیزی است که قبلاً دیده‌ایم: یک خط برای هر تست واحدی (یکی به نام `internal` که در **جدول 11-12** اضافه کردیم) و سپس یک خط خلاصه برای تست‌های واحدی.

بخش تست‌های یکپارچه‌سازی با خط `Running tests/integration_test.rs` شروع می‌شود. سپس، یک خط برای هر تابع تست در آن تست یکپارچه‌سازی و یک خط خلاصه برای نتایج تست یکپارچه‌سازی درست قبل از شروع بخش `Doc-tests adder` وجود دارد.

هر فایل تست یکپارچه‌سازی بخش خاص خود را دارد، بنابراین اگر فایل‌های بیشتری در دایرکتوری `tests` اضافه کنیم، بخش‌های تست یکپارچه‌سازی بیشتری خواهیم داشت.

ما همچنان می‌توانیم یک تابع تست یکپارچه‌سازی خاص را با مشخص کردن نام تابع تست به‌عنوان آرگومان به `cargo test` اجرا کنیم. برای اجرای همه تست‌ها در یک فایل تست یکپارچه‌سازی خاص، از آرگومان `--test` در `cargo test` به‌دنبال نام فایل استفاده کنید:

```bash
$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

این دستور فقط تست‌ها در فایل `tests/integration_test.rs` را اجرا می‌کند.

### زیرماژول‌ها در تست‌های یکپارچه‌سازی

با اضافه کردن تست‌های یکپارچه‌سازی بیشتر، ممکن است بخواهید فایل‌های بیشتری در دایرکتوری `tests` بسازید تا به سازماندهی آن‌ها کمک کنید؛ برای مثال، می‌توانید توابع تست را بر اساس عملکردی که تست می‌کنند گروه‌بندی کنید. همان‌طور که قبلاً ذکر شد، هر فایل در دایرکتوری `tests` به‌عنوان crate جداگانه خود کامپایل می‌شود، که برای ایجاد حوزه‌های جداگانه مفید است تا به‌طور نزدیک‌تر نحوه استفاده کاربران نهایی از crate شما را تقلید کند. با این حال، این به این معنی است که فایل‌های دایرکتوری `tests` همان رفتار فایل‌های `src` را ندارند، همان‌طور که در فصل هفتم درباره نحوه جداسازی کد به ماژول‌ها و فایل‌ها آموختید.

رفتار متفاوت فایل‌های دایرکتوری `tests` بیشتر وقتی قابل‌توجه است که مجموعه‌ای از توابع کمکی برای استفاده در چندین فایل تست یکپارچه‌سازی دارید و سعی می‌کنید مراحل بخش «جداسازی ماژول‌ها به فایل‌های مختلف» در فصل هفتم را دنبال کنید تا آن‌ها را به یک ماژول مشترک استخراج کنید. برای مثال، اگر `tests/common.rs` را ایجاد کنیم و یک تابع به نام `setup` در آن قرار دهیم، می‌توانیم مقداری کد به `setup` اضافه کنیم که بخواهیم از چندین تابع تست در چندین فایل تست فراخوانی کنیم:

**فایل: tests/common.rs**

```rust
pub fn setup() {
    // کد تنظیم خاص تست‌های کتابخانه شما اینجا قرار می‌گیرد
}
```

وقتی دوباره تست‌ها را اجرا کنیم، یک بخش جدید در خروجی تست برای فایل `common.rs` خواهیم دید، حتی اگر این فایل هیچ تابع تستی نداشته باشد و ما تابع `setup` را از جایی فراخوانی نکرده باشیم:

```bash
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

ظاهر شدن `common` در نتایج تست با نمایش `running 0 tests` برای آن چیزی نیست که ما می‌خواستیم. ما فقط می‌خواستیم مقداری کد با دیگر فایل‌های تست یکپارچه‌سازی به اشتراک بگذاریم. برای جلوگیری از ظاهر شدن `common` در خروجی تست، به‌جای ایجاد `tests/common.rs`، ما `tests/common/mod.rs` را ایجاد خواهیم کرد. دایرکتوری پروژه اکنون شبیه این است:

```
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

این قرارداد نام‌گذاری قدیمی‌تری است که **Rust** نیز آن را درک می‌کند و در بخش «مسیرهای فایل جایگزین» در فصل هفتم ذکر کردیم. نام‌گذاری فایل به این روش به **Rust** می‌گوید که ماژول `common` را به‌عنوان یک فایل تست یکپارچه‌سازی در نظر نگیرد. وقتی کد تابع `setup` را به `tests/common/mod.rs` منتقل کنیم و فایل `tests/common.rs` را حذف کنیم، بخش مربوط به آن در خروجی تست دیگر ظاهر نخواهد شد. فایل‌های موجود در زیرپوشه‌های دایرکتوری `tests` به‌عنوان crate‌های جداگانه کامپایل نمی‌شوند یا بخش‌هایی در خروجی تست ندارند.

بعد از اینکه `tests/common/mod.rs` را ایجاد کردیم، می‌توانیم از آن به‌عنوان یک ماژول از هر یک از فایل‌های تست یکپارچه‌سازی استفاده کنیم. در اینجا مثالی از فراخوانی تابع `setup` از تست `it_adds_two` در `tests/integration_test.rs` آورده شده است:

**فایل: tests/integration_test.rs**

```rust
use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}
```

توجه کنید که اعلان `mod common;` همان اعلان ماژولی است که در **جدول 7-21** نشان دادیم. سپس، در تابع تست، می‌توانیم تابع `common::setup()` را فراخوانی کنیم.

### تست‌های یکپارچه‌سازی برای Crate‌های باینری

اگر پروژه ما یک crate باینری باشد که فقط شامل یک فایل `src/main.rs` است و فایل `src/lib.rs` ندارد، نمی‌توانیم تست‌های یکپارچه‌سازی را در دایرکتوری `tests` ایجاد کنیم و توابعی که در فایل `src/main.rs` تعریف شده‌اند را با دستور `use` به حوزه بیاوریم. فقط crate‌های کتابخانه‌ای توابعی را افشا می‌کنند که crate‌های دیگر می‌توانند استفاده کنند؛ crate‌های باینری برای اجرا به‌صورت مستقل طراحی شده‌اند.

این یکی از دلایلی است که پروژه‌های **Rust** که یک باینری ارائه می‌دهند، یک فایل `src/main.rs` ساده دارند که منطقی را فراخوانی می‌کند که در فایل `src/lib.rs` قرار دارد. با استفاده از این ساختار، تست‌های یکپارچه‌سازی می‌توانند crate کتابخانه را با `use` تست کنند تا عملکرد مهم را در دسترس قرار دهند. اگر عملکرد مهم کار کند، مقدار کمی کد در فایل `src/main.rs` نیز کار خواهد کرد، و آن مقدار کمی کد نیازی به تست شدن ندارد.

## خلاصه

ویژگی‌های تست **Rust** راهی برای مشخص کردن نحوه عملکرد کد ارائه می‌دهند تا اطمینان حاصل شود که حتی با ایجاد تغییرات، همچنان به همان روشی که انتظار دارید کار می‌کند. تست‌های واحدی بخش‌های مختلف یک کتابخانه را جداگانه تمرین می‌دهند و می‌توانند جزئیات پیاده‌سازی خصوصی را تست کنند. تست‌های یکپارچه‌سازی بررسی می‌کنند که بسیاری از بخش‌های کتابخانه به‌درستی با هم کار می‌کنند، و آن‌ها از API عمومی کتابخانه برای تست کد به همان روشی که کد خارجی از آن استفاده خواهد کرد، استفاده می‌کنند. اگرچه سیستم نوع و قوانین مالکیت **Rust** به جلوگیری از برخی انواع باگ‌ها کمک می‌کنند، تست‌ها همچنان برای کاهش باگ‌های منطقی مرتبط با نحوه رفتار مورد انتظار کد شما مهم هستند.

بیایید دانشی که در این فصل و فصل‌های قبلی آموختید را ترکیب کنیم تا روی یک پروژه کار کنیم!
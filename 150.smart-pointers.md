# اشاره‌گرهای هوشمند

یک اشاره‌گر یک مفهوم عمومی برای یک متغیر است که شامل یک آدرس در حافظه می‌باشد. این آدرس به داده‌های دیگری اشاره می‌کند یا "به آن‌ها اشاره می‌کند". رایج‌ترین نوع اشاره‌گر در Rust، مرجع (reference) است که در فصل ۴ درباره آن یاد گرفتید. مراجع با نماد `&` نشان داده می‌شوند و مقدار مورد اشاره را قرض می‌گیرند. آن‌ها هیچ قابلیت خاصی به جز اشاره به داده‌ها ندارند و هیچ بار اضافی نیز ندارند.

از طرف دیگر، اشاره‌گرهای هوشمند (smart pointers) ساختارهای داده‌ای هستند که مانند یک اشاره‌گر عمل می‌کنند اما همچنین دارای متاداده و قابلیت‌های اضافی هستند. مفهوم اشاره‌گرهای هوشمند منحصر به Rust نیست: اشاره‌گرهای هوشمند در C++ به وجود آمدند و در زبان‌های دیگر نیز وجود دارند. Rust انواع مختلفی از اشاره‌گرهای هوشمند را در کتابخانه استاندارد خود تعریف کرده است که عملکردی فراتر از آنچه که مراجع ارائه می‌دهند، فراهم می‌کنند. برای بررسی مفهوم کلی، به چند مثال مختلف از اشاره‌گرهای هوشمند، از جمله یک نوع اشاره‌گر هوشمند با برشمارش مرجع (reference counting) خواهیم پرداخت. این اشاره‌گر به شما این امکان را می‌دهد که داده‌ها دارای چندین مالک باشند با نگهداری تعداد مالکان و زمانی که هیچ مالک باقی نمانده باشد، داده‌ها را پاک‌سازی کند.

Rust با مفهوم مالکیت و قرض‌گیری خود، تفاوت اضافی بین مراجع و اشاره‌گرهای هوشمند دارد: در حالی که مراجع فقط داده‌ها را قرض می‌گیرند، در بسیاری از موارد اشاره‌گرهای هوشمند مالک داده‌هایی هستند که به آن‌ها اشاره می‌کنند.

اگرچه در آن زمان به آن‌ها اشاره نکردیم، اما ما در این کتاب چند اشاره‌گر هوشمند را از قبل ملاقات کرده‌ایم، از جمله `String` و `Vec<T>` در فصل ۸. هر دو این نوع‌ها به عنوان اشاره‌گرهای هوشمند محسوب می‌شوند زیرا مقداری از حافظه را مالک هستند و به شما اجازه می‌دهند آن را دستکاری کنید. آن‌ها همچنین دارای متاداده و قابلیت‌ها یا تضمین‌های اضافی هستند. به عنوان مثال، `String` ظرفیت خود را به عنوان متاداده ذخیره می‌کند و قابلیت اضافی برای اطمینان از اینکه داده‌های آن همیشه UTF-8 معتبر خواهند بود، دارد.

اشاره‌گرهای هوشمند معمولاً با استفاده از ساختارها (structs) پیاده‌سازی می‌شوند. برخلاف یک ساختار عادی، اشاره‌گرهای هوشمند ویژگی‌های `Deref` و `Drop` را پیاده‌سازی می‌کنند. ویژگی `Deref` به یک نمونه از ساختار اشاره‌گر هوشمند اجازه می‌دهد که مانند یک مرجع عمل کند، بنابراین می‌توانید کد خود را به گونه‌ای بنویسید که با مراجع یا اشاره‌گرهای هوشمند کار کند. ویژگی `Drop` به شما این امکان را می‌دهد که کدی را که هنگام خروج یک نمونه از اشاره‌گر هوشمند از دامنه اجرا می‌شود، سفارشی کنید. در این فصل، هر دو این ویژگی‌ها را بررسی خواهیم کرد و نشان خواهیم داد که چرا آن‌ها برای اشاره‌گرهای هوشمند مهم هستند.

با توجه به اینکه الگوی اشاره‌گر هوشمند یک الگوی طراحی عمومی است که به طور مکرر در Rust استفاده می‌شود، این فصل به بررسی هر اشاره‌گر هوشمند موجود نخواهد پرداخت. بسیاری از کتابخانه‌ها دارای اشاره‌گرهای هوشمند خود هستند و شما حتی می‌توانید اشاره‌گرهای هوشمند خود را بنویسید. ما رایج‌ترین اشاره‌گرهای هوشمند در کتابخانه استاندارد را پوشش خواهیم داد:

- **Box<T>**: برای تخصیص مقادیر در heap
- **Rc<T>**: یک نوع برشمارش مرجع که مالکیت چندگانه را امکان‌پذیر می‌سازد
- **Ref<T>** و **RefMut<T>**: که از طریق `RefCell<T>`، نوعی که قوانین قرض‌گیری را در زمان اجرا به جای زمان کامپایل اعمال می‌کند، دسترسی پیدا می‌کنند

علاوه بر این، ما الگوی تغییر درونی (interior mutability) را بررسی خواهیم کرد که در آن یک نوع غیرقابل تغییر یک API برای تغییر یک مقدار داخلی ارائه می‌دهد. همچنین درباره چرخه‌های مرجع (reference cycles) بحث خواهیم کرد: اینکه چگونه می‌توانند حافظه را نشت دهند و چگونه می‌توان از آن‌ها جلوگیری کرد.

بیایید شروع کنیم
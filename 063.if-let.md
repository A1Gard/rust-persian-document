## کنترل جریان مختصر با `if let` و `let else`

سینتکس `if let` به شما امکان می‌دهد `if` و `let` را به روشی کمتر پرحجم ترکیب کنید تا مقادیر منطبق با یک الگو را مدیریت کنید و بقیه را نادیده بگیرید. برنامه‌ای در لیست ۶-۶ را در نظر بگیرید که روی یک مقدار `Option<u8>` در متغیر `config_max` تطبیق انجام می‌دهد اما فقط می‌خواهد کدی را اجرا کند اگر مقدار نوع `Some` باشد.

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("حداکثر مقدار تنظیم شده است به {max}"),
    _ => (),
}
```

**لیست ۶-۶:** یک `match` که فقط به اجرای کد وقتی مقدار `Some` است اهمیت می‌دهد

اگر مقدار `Some` باشد، مقدار داخل نوع `Some` را با اتصال مقدار به متغیر `max` در الگو چاپ می‌کنیم. ما نمی‌خواهیم با مقدار `None` کاری انجام دهیم. برای رضایت عبارت `match`، باید `_ => ()` را پس از پردازش فقط یک نوع اضافه کنیم، که افزودن این کد اضافی آزاردهنده است.

در عوض، می‌توانیم این را به روشی کوتاه‌تر با استفاده از `if let` بنویسیم. کد زیر همان رفتار `match` در لیست ۶-۶ را دارد:

```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("حداکثر مقدار تنظیم شده است به {max}");
}
```

سینتکس `if let` یک الگو و یک عبارت را که با علامت برابر جدا شده‌اند، می‌گیرد. این به همان روش `match` کار می‌کند، که در آن عبارت به `match` داده می‌شود و الگو اولین بازوی آن است. در این مورد، الگو `Some(max)` است، و `max` به مقدار داخل `Some` متصل می‌شود. سپس می‌توانیم از `max` در بدنه بلوک `if let` به همان روشی که در بازوی `match` مربوطه استفاده کردیم، استفاده کنیم. کد در بلوک `if let` فقط اگر مقدار با الگو مطابقت داشته باشد اجرا می‌شود.

استفاده از `if let` به معنای تایپ کمتر، تورفتگی کمتر، و کد اضافی کمتر است. با این حال، شما بررسی جامع (exhaustive checking) که `match` اعمال می‌کند را از دست می‌دهید. انتخاب بین `match` و `if let` بستگی به کاری که در موقعیت خاص خود انجام می‌دهید و این دارد که آیا کسب مختصر بودن، معامله مناسبی برای از دست دادن بررسی جامع است یا خیر.

به عبارت دیگر، می‌توانید `if let` را به‌عنوان یک شکر سینتکسی (syntax sugar) برای یک `match` در نظر بگیرید که وقتی مقدار با یک الگو مطابقت دارد کد را اجرا می‌کند و سپس همه مقادیر دیگر را نادیده می‌گیرد.

می‌توانیم یک `else` را با `if let` شامل کنیم. بلوک کدی که با `else` می‌آید، همان بلوک کدی است که با مورد `_` در عبارت `match` معادل با `if let` و `else` می‌رود. شمارش `Coin` تعریف‌شده در لیست ۶-۴ را به خاطر بیاورید، جایی که نوع `Quarter` همچنین یک مقدار `UsState` را نگه می‌داشت. اگر بخواهیم همه سکه‌های غیر ربع‌دلاری را که می‌بینیم بشماریم و در عین حال ایالت ربع‌دلارها را اعلام کنیم، می‌توانیم این کار را با یک عبارت `match` به این صورت انجام دهیم:

```rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("ربع‌دلار ایالتی از {state:?}!"),
    _ => count += 1,
}
```

یا می‌توانیم از یک عبارت `if let` و `else` استفاده کنیم، مانند این:

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("ربع‌دلار ایالتی از {state:?}!");
} else {
    count += 1;
}
```

### در مسیر خوشحال با `let...else`

یک الگوی رایج این است که وقتی مقداری وجود دارد، محاسباتی انجام دهیم و در غیر این صورت یک مقدار پیش‌فرض برگردانیم. با ادامه مثال سکه‌ها با مقدار `UsState`، اگر بخواهیم بسته به سن ایالت روی ربع‌دلار چیزی بامزه بگوییم، ممکن است متدی روی `UsState` معرفی کنیم تا سن ایالت را بررسی کند، مانند زیر:

```rust
impl UsState {
    fn existed_in(&self, year: u16) -> bool {
        match self {
            UsState::Alabama => year >= 1819,
            UsState::Alaska => year >= 1959,
            // --snip--
        }
    }
}
```

سپس ممکن است از `if let` برای تطبیق با نوع سکه استفاده کنیم و یک متغیر `state` را در بدنه شرط معرفی کنیم، همان‌طور که در لیست ۶-۷ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} خیلی قدیمی است، برای آمریکا!"))
        } else {
            Some(format!("{state:?} نسبتاً جدید است."))
        }
    } else {
        None
    }
}
```

**لیست ۶-۷:** بررسی اینکه آیا ایالتی در سال ۱۹۰۰ وجود داشته با استفاده از شرط‌های تو در تو داخل یک `if let`.

این کار را انجام می‌دهد، اما کار را به بدنه عبارت `if let` منتقل کرده است، و اگر کاری که باید انجام شود پیچیده‌تر باشد، ممکن است دنبال کردن دقیق رابطه شاخه‌های سطح بالا دشوار باشد. همچنین می‌توانیم از این واقعیت استفاده کنیم که عبارات یک مقدار تولید می‌کنند تا یا ایالت را از `if let` تولید کنیم یا زود برگردیم، همان‌طور که در لیست ۶-۸ نشان داده شده است. (می‌توانید مشابه این را با یک `match` نیز انجام دهید.)

**نام فایل:** `src/main.rs`

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} خیلی قدیمی است، برای آمریکا!"))
    } else {
        Some(format!("{state:?} نسبتاً جدید است."))
    }
}
```

**لیست ۶-۸:** استفاده از `if let` برای تولید یک مقدار یا بازگشت زودهنگام.

این به‌نوعی خودش دنبال کردنش آزاردهنده است! یک شاخه از `if let` یک مقدار تولید می‌کند، و دیگری کاملاً از تابع برمی‌گردد.

برای اینکه این الگوی رایج زیباتر بیان شود، Rust `let...else` را دارد. سینتکس `let...else` یک الگو در سمت چپ و یک عبارت در سمت راست می‌گیرد، بسیار شبیه به `if let`، اما شاخه `if` ندارد، فقط یک شاخه `else`. اگر الگو مطابقت داشته باشد، مقدار از الگو را در حوزه بیرونی متصل می‌کند. اگر الگو مطابقت نداشته باشد، برنامه به بازوی `else` می‌رود، که باید از تابع برگردد.

در لیست ۶-۹، می‌توانید ببینید که لیست ۶-۸ وقتی از `let...else` به‌جای `if let` استفاده می‌کند، چگونه به نظر می‌رسد. توجه کنید که این‌گونه در بدنه اصلی تابع در «مسیر خوشحال» باقی می‌ماند، بدون اینکه جریان کنترلی به‌طور قابل‌توجهی متفاوت برای دو شاخه باشد، برخلاف `if let`.

**نام فایل:** `src/main.rs`

```rust
fn describe_state_quarter(coin: Coin) -> Option<String> {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} خیلی قدیمی است، برای آمریکا!"))
    } else {
        Some(format!("{state:?} نسبتاً جدید است."))
    }
}
```

**لیست ۶-۹:** استفاده از `let...else` برای شفاف‌سازی جریان از طریق تابع.

اگر موقعیتی دارید که منطق برنامه‌تان برای بیان با `match` بیش از حد پرحجم است، به خاطر داشته باشید که `if let` و `let...else` نیز در جعبه‌ابزار Rust شما هستند.

### خلاصه

ما حالا پوشش دادیم که چگونه از شمارش‌ها برای ایجاد نوع‌های سفارشی استفاده کنیم که می‌توانند یکی از مجموعه‌ای از مقادیر برشمرده باشند. نشان دادیم که چگونه نوع `Option<T>` کتابخانه استاندارد به شما کمک می‌کند از سیستم نوع برای جلوگیری از خطاها استفاده کنید. وقتی مقادیر شمارش داده‌ای در داخل خود دارند، می‌توانید از `match` یا `if let` برای استخراج و استفاده از آن مقادیر استفاده کنید، بسته به اینکه چند مورد نیاز به مدیریت دارید.

برنامه‌های Rust شما حالا می‌توانند مفاهیم حوزه خود را با استفاده از ساختارها و شمارش‌ها بیان کنند. ایجاد نوع‌های سفارشی برای استفاده در API شما ایمنی نوع را تضمین می‌کند: کامپایلر اطمینان می‌دهد که توابع شما فقط مقادیر از نوعی که هر تابع انتظار دارد دریافت می‌کنند.

برای ارائه یک API سازمان‌یافته به کاربرانتان که استفاده از آن ساده باشد و دقیقاً آنچه کاربرانتان نیاز دارند را آشکار کند، حالا به ماژول‌های Rust می‌پردازیم.

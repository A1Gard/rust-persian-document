# ذخیره کلیدها با مقادیر مرتبط در HashMap‌ها

آخرین نوع از مجموعه‌های معمول ما، **HashMap** است. نوع `HashMap<K, V>` یک نگاشت از کلیدهای نوع `K` به مقادیر نوع `V` را با استفاده از یک تابع هش ذخیره می‌کند که تعیین می‌کند چگونه این کلیدها و مقادیر را در حافظه قرار دهد. بسیاری از زبان‌های برنامه‌نویسی از این ساختار داده پشتیبانی می‌کنند، اما اغلب با نام‌های مختلفی مانند hash، map، object، hash table، dictionary یا associative array شناخته می‌شود.

## کاربردهای HashMap

HashMap‌ها زمانی مفید هستند که بخواهید داده‌ها را نه با استفاده از ایندکس (مانند بردارها)، بلکه با استفاده از کلیدی از هر نوع جستجو کنید. به عنوان مثال، در یک بازی می‌توانید امتیاز هر تیم را در یک HashMap نگهداری کنید که در آن هر کلید نام یک تیم و مقادیر امتیاز هر تیم هستند. با دادن نام تیم، می‌توانید امتیاز آن را بازیابی کنید.

در این بخش به API پایه‌ای HashMap می‌پردازیم، اما توابع بیشتری در `HashMap<K, V>` در کتابخانه استاندارد وجود دارد. همیشه می‌توانید برای اطلاعات بیشتر به مستندات کتابخانه استاندارد مراجعه کنید.

## ایجاد یک HashMap جدید

یکی از راه‌های ایجاد یک HashMap خالی، استفاده از `new` و افزودن عناصر با `insert` است. در لیست ۸-۲۰، ما امتیازات دو تیم با نام‌های "Blue" و "Yellow" را پیگیری می‌کنیم. تیم Blue با ۱۰ امتیاز و تیم Yellow با ۵۰ امتیاز شروع می‌کنند.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

**لیست ۸-۲۰**: ایجاد یک HashMap جدید و درج برخی کلیدها و مقادیر

توجه کنید که ابتدا باید `HashMap` را از بخش collections کتابخانه استاندارد استفاده کنیم. از بین سه مجموعه معمول، این یکی کمترین استفاده را دارد، بنابراین به طور پیش‌فرض در prelude قرار نمی‌گیرد. HashMap‌ها همچنین پشتیبانی کمتری از کتابخانه استاندارد دارند؛ برای مثال، هیچ ماکروی داخلی برای ساخت آن‌ها وجود ندارد.

همانند بردارها، HashMap‌ها داده‌های خود را در heap ذخیره می‌کنند. این `HashMap` کلیدهایی از نوع `String` و مقادیری از نوع `i32` دارد. مانند بردارها، HashMap‌ها همگن هستند: همه کلیدها باید از یک نوع و همه مقادیر باید از یک نوع باشند.

## دسترسی به مقادیر در HashMap

می‌توانیم با ارائه کلید به متد `get`، مقدار را از HashMap استخراج کنیم، همانطور که در لیست ۸-۲۱ نشان داده شده است.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

**لیست ۸-۲۱**: دسترسی به امتیاز تیم Blue ذخیره شده در HashMap

در اینجا، `score` مقداری را که با تیم Blue مرتبط است، خواهد داشت و نتیجه ۱۰ خواهد بود. متد `get` یک `Option<&V>` برمی‌گرداند؛ اگر هیچ مقداری برای آن کلید در HashMap وجود نداشته باشد، `get` مقدار `None` را برمی‌گرداند. این برنامه با فراخوانی `copied` برای دریافت `Option<i32>` به جای `Option<&i32>` و سپس `unwrap_or` برای تنظیم `score` به صفر در صورتی که `scores` هیچ ورودی برای کلید نداشته باشد، `Option` را مدیریت می‌کند.

می‌توانیم با استفاده از حلقه `for` روی هر جفت کلید-مقدار در HashMap تکرار کنیم:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
```

این کد هر جفت را به ترتیب دلخواه چاپ می‌کند:

```
Yellow: 50
Blue: 10
```

## HashMap و مالکیت

برای انواعی که ویژگی `Copy` را پیاده‌سازی می‌کنند (مانند `i32`)، مقادیر در HashMap کپی می‌شوند. برای مقادیر دارای مالکیت مانند `String`، مقادیر منتقل می‌شوند و HashMap مالک آن مقادیر خواهد بود، همانطور که در لیست ۸-۲۲ نشان داده شده است.

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name و field_value در این نقطه نامعتبر هستند، سعی کنید از آن‌ها استفاده کنید و ببینید چه خطای کامپایلری دریافت می‌کنید!
```

**لیست ۸-۲۲**: نشان می‌دهد که کلیدها و مقادیر پس از درج، متعلق به HashMap هستند

پس از انتقال `field_name` و `field_value` به HashMap با فراخوانی `insert`، نمی‌توانیم از این متغیرها استفاده کنیم.

اگر به جای مقادیر، ارجاع به آن‌ها را در HashMap قرار دهیم، مقادیر به HashMap منتقل نمی‌شوند. مقادیری که ارجاع به آن‌ها اشاره می‌کنند باید حداقل تا زمانی که HashMap معتبر است، معتبر باشند. در فصل ۱۰ در بخش "اعتبارسنجی ارجاع‌ها با طول عمر" بیشتر در این مورد صحبت خواهیم کرد.

## به‌روزرسانی یک HashMap

اگرچه تعداد جفت‌های کلید و مقدار قابل افزایش است، اما هر کلید منحصربه‌فرد فقط می‌تواند یک مقدار مرتبط با آن داشته باشد (اما برعکس آن صادق نیست: برای مثال، هر دو تیم Blue و Yellow می‌توانند مقدار ۱۰ را در HashMap scores ذخیره کنند).

وقتی می‌خواهید داده‌های یک HashMap را تغییر دهید، باید تصمیم بگیرید که چگونه موردی را که یک کلید از قبل مقداری دارد، مدیریت کنید. می‌توانید مقدار قدیمی را با مقدار جدید جایگزین کنید، کاملاً از مقدار قدیمی چشم‌پوشی کنید. می‌توانید مقدار قدیمی را نگه دارید و مقدار جدید را نادیده بگیرید، فقط در صورتی که کلید از قبل مقداری نداشته باشد، مقدار جدید را اضافه کنید. یا می‌توانید مقدار قدیمی و جدید را ترکیب کنید. بیایید نحوه انجام هر یک از این موارد را بررسی کنیم!

### جایگزینی یک مقدار

اگر یک کلید و مقدار را در HashMap درج کنیم و سپس همان کلید را با مقدار متفاوتی درج کنیم، مقدار مرتبط با آن کلید جایگزین می‌شود. حتی اگر کد در لیست ۸-۲۳ دو بار `insert` را فراخوانی کند، HashMap فقط شامل یک جفت کلید-مقدار خواهد بود زیرا هر دو بار مقدار را برای کلید تیم Blue درج می‌کنیم.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{scores:?}");
```

**لیست ۸-۲۳**: جایگزینی یک مقدار ذخیره شده با یک کلید خاص

این کد `{"Blue": 25}` را چاپ می‌کند. مقدار اصلی ۱۰ جایگزین شده است.

### افزودن یک کلید و مقدار فقط در صورت عدم وجود کلید

معمول است که بررسی کنید آیا یک کلید خاص از قبل در HashMap وجود دارد یا خیر و سپس اقدامات زیر را انجام دهید: اگر کلید وجود دارد، مقدار موجود باید همان‌طور باقی بماند؛ اگر کلید وجود ندارد، آن و یک مقدار برای آن درج کنید.

HashMap‌ها یک API ویژه برای این کار به نام `entry` دارند که کلیدی را که می‌خواهید بررسی کنید به عنوان پارامتر می‌گیرد. مقدار بازگشتی متد `entry` یک enum به نام `Entry` است که نشان‌دهنده مقداری است که ممکن است وجود داشته باشد یا نداشته باشد. فرض کنید می‌خواهیم بررسی کنیم که آیا کلید تیم Yellow مقداری مرتبط با آن دارد یا خیر. اگر ندارد، می‌خواهیم مقدار ۵۰ را درج کنیم و همین کار را برای تیم Blue انجام دهیم. با استفاده از API `entry`، کد به صورت لیست ۸-۲۴ خواهد بود.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{scores:?}");
```

**لیست ۸-۲۴**: استفاده از متد entry برای درج فقط در صورتی که کلید از قبل مقداری نداشته باشد

متد `or_insert` روی `Entry` طوری تعریف شده است که اگر کلید وجود داشته باشد، یک ارجاع تغییرپذیر به مقدار مربوط به کلید `Entry` برمی‌گرداند و اگر وجود نداشته باشد، پارامتر را به عنوان مقدار جدید برای این کلید درج می‌کند و یک ارجاع تغییرپذیر به مقدار جدید برمی‌گرداند. این تکنیک بسیار تمیزتر از نوشتن منطق توسط خودمان است و علاوه بر این، با borrow checker سازگاری بهتری دارد.

اجرای کد در لیست ۸-۲۴ `{"Yellow": 50, "Blue": 10}` را چاپ می‌کند. اولین فراخوانی `entry` کلید تیم Yellow را با مقدار ۵۰ درج می‌کند زیرا تیم Yellow از قبل مقداری ندارد. دومین فراخوانی `entry` HashMap را تغییر نمی‌دهد زیرا تیم Blue از قبل مقدار ۱۰ را دارد.

### به‌روزرسانی یک مقدار بر اساس مقدار قدیمی

یکی دیگر از موارد استفاده معمول برای HashMap‌ها، جستجوی مقدار یک کلید و سپس به‌روزرسانی آن بر اساس مقدار قدیمی است. به عنوان مثال، لیست ۸-۲۵ کدی را نشان می‌دهد که تعداد دفعات ظاهر شدن هر کلمه را در یک متن می‌شمارد. ما از یک HashMap با کلمات به عنوان کلیدها استفاده می‌کنیم و مقدار را افزایش می‌دهیم تا تعداد دفعات دیدن آن کلمه را پیگیری کنیم. اگر اولین بار است که کلمه را می‌بینیم، ابتدا مقدار ۰ را درج می‌کنیم.

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{map:?}");
```

**لیست ۸-۲۵**: شمارش وقوع کلمات با استفاده از HashMap که کلمات و تعداد را ذخیره می‌کند

این کد `{"world": 2, "hello": 1, "wonderful": 1}` را چاپ می‌کند. ممکن است همان جفت‌های کلید-مقدار را به ترتیب متفاوتی ببینید: به یاد بیاورید از بخش "دسترسی به مقادیر در HashMap" که تکرار روی یک HashMap به ترتیب دلخواه انجام می‌شود.

متد `split_whitespace` یک iterator روی زیررشته‌های `text` که با فاصله سفید جدا شده‌اند، برمی‌گرداند. متد `or_insert` یک ارجاع تغییرپذیر (`&mut V`) به مقدار برای کلید مشخص شده برمی‌گرداند. در اینجا، ما آن ارجاع تغییرپذیر را در متغیر `count` ذخیره می‌کنیم، بنابراین برای انتساب به آن مقدار، ابتدا باید `count` را با استفاده از ستاره (`*`) ارجاع‌زدایی کنیم. ارجاع تغییرپذیر در پایان حلقه `for` از محدوده خارج می‌شود، بنابراین همه این تغییرات ایمن هستند و توسط قوانین borrow مجاز هستند.

## توابع هش

به طور پیش‌فرض، HashMap از یک تابع هش به نام **SipHash** استفاده می‌کند که می‌تواند در برابر حملات denial-of-service (DoS) مربوط به جداول هش مقاومت کند. این سریع‌ترین الگوریتم هش موجود نیست، اما مصالحه بین امنیت بهتر و کاهش عملکرد ارزشش را دارد. اگر کد خود را پروفایل کنید و متوجه شوید که تابع هش پیش‌فرض برای اهداف شما بسیار کند است، می‌توانید با مشخص کردن یک hasher متفاوت، به تابع دیگری تغییر دهید. یک hasher نوعی است که ویژگی `BuildHasher` را پیاده‌سازی می‌کند. در فصل ۱۰ در مورد ویژگی‌ها و نحوه پیاده‌سازی آن‌ها صحبت خواهیم کرد. لازم نیست حتماً hasher خود را از ابتدا پیاده‌سازی کنید؛ crates.io کتابخانه‌هایی دارد که توسط دیگر کاربران Rust به اشتراک گذاشته شده‌اند و hasherهایی را ارائه می‌دهند که بسیاری از الگوریتم‌های هش رایج را پیاده‌سازی می‌کنند.

## خلاصه

بردارها، رشته‌ها و HashMap‌ها مقدار زیادی از عملکردهای لازم را در برنامه‌هایی که نیاز به ذخیره، دسترسی و تغییر داده دارند، ارائه می‌دهند. در اینجا چند تمرین وجود دارد که اکنون باید بتوانید حل کنید:

۱. با توجه به لیستی از اعداد صحیح، از یک بردار استفاده کنید و میانه (هنگام مرتب‌سازی، مقدار در موقعیت میانی) و مد (مقداری که بیشترین تکرار را دارد؛ یک HashMap در اینجا مفید خواهد بود) لیست را برگردانید.
۲. رشته‌ها را به pig latin تبدیل کنید. اولین صامت هر کلمه به انتهای کلمه منتقل می‌شود و "ay" اضافه می‌شود، بنابراین "first" به "irst-fay" تبدیل می‌شود. کلماتی که با حرف صدادار شروع می‌شوند، "hay" به انتهای آن‌ها اضافه می‌شود (مثلاً "apple" به "apple-hay" تبدیل می‌شود). جزئیات مربوط به کدگذاری UTF-8 را در نظر داشته باشید!
۳. با استفاده از یک HashMap و بردارها، یک رابط متنی ایجاد کنید تا کاربر بتواند نام کارمندان را به یک بخش در شرکت اضافه کند؛ برای مثال، "Add Sally to Engineering" یا "Add Amir to Sales". سپس به کاربر اجازه دهید لیست تمام افراد در یک بخش یا تمام افراد در شرکت را به تفکیک بخش، به ترتیب الفبایی بازیابی کند.

مستندات API کتابخانه استاندارد، متدهایی را که بردارها، رشته‌ها و HashMap‌ها دارند و برای این تمرینات مفید خواهند بود، توصیف می‌کند!

ما در حال ورود به برنامه‌های پیچیده‌تری هستیم که در آن عملیات می‌تواند با شکست مواجه شود، بنابراین زمان مناسبی برای بحث در مورد مدیریت خطا است. این موضوع را بعداً بررسی خواهیم کرد!
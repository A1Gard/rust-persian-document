# استفاده از انتقال پیام برای جابجایی داده‌ها بین نخ‌ها

یکی از روش‌های روزافزون برای تضمین همزمانی ایمن، **انتقال پیام** (message passing) است، که در آن نخ‌ها یا بازیگران (actors) با ارسال پیام‌هایی حاوی داده به یکدیگر ارتباط برقرار می‌کنند. شعاری از مستندات زبان Go این ایده را به خوبی بیان می‌کند: «با به اشتراک گذاشتن حافظه ارتباط برقرار نکنید؛ در عوض، حافظه را با ارتباط به اشتراک بگذارید.»

برای پیاده‌سازی همزمانی مبتنی بر ارسال پیام، کتابخانه استاندارد Rust پیاده‌سازی‌ای از **کانال‌ها** (channels) ارائه می‌دهد. کانال یک مفهوم عمومی برنامه‌نویسی است که از طریق آن داده‌ها از یک نخ به نخ دیگر ارسال می‌شوند.

می‌توانید یک کانال در برنامه‌نویسی را مانند یک جریان جهت‌دار آب، مانند یک جوی یا رودخانه، تصور کنید. اگر چیزی مانند یک اردک پلاستیکی را در رودخانه قرار دهید، به سمت پایین جریان می‌رود و به انتهای مسیر آب می‌رسد.

یک کانال از دو بخش تشکیل شده است: **فرستنده** (transmitter) و **گیرنده** (receiver). بخش فرستنده مانند محل بالادست رودخانه است که اردک پلاستیکی را در آن قرار می‌دهید، و بخش گیرنده جایی است که اردک در پایین‌دست به آن می‌رسد. بخشی از کد شما متدهایی را روی فرستنده با داده‌هایی که می‌خواهید ارسال کنید فراخوانی می‌کند، و بخش دیگر انتهای گیرنده را برای پیام‌های دریافتی بررسی می‌کند. گفته می‌شود یک کانال **بسته** (closed) است اگر یکی از نیمه‌های فرستنده یا گیرنده حذف (dropped) شود.

در اینجا، برنامه‌ای می‌سازیم که یک نخ مقادیر را تولید کرده و از طریق یک کانال ارسال می‌کند، و نخ دیگری این مقادیر را دریافت کرده و چاپ می‌کند. ما مقادیر ساده‌ای را بین نخ‌ها با استفاده از یک کانال ارسال می‌کنیم تا این ویژگی را نشان دهیم. وقتی با این تکنیک آشنا شدید، می‌توانید از کانال‌ها برای هر نخ‌هایی که نیاز به ارتباط با یکدیگر دارند استفاده کنید، مانند یک سیستم چت یا سیستمی که در آن چندین نخ بخش‌هایی از یک محاسبه را انجام داده و بخش‌ها را به یک نخ ارسال می‌کنند که نتایج را تجمیع می‌کند.

## ایجاد یک کانال

ابتدا، در Listing 16-6، یک کانال ایجاد می‌کنیم اما هنوز کاری با آن انجام نمی‌دهیم. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود، زیرا Rust نمی‌داند چه نوع مقادیری می‌خواهیم از طریق کانال ارسال کنیم:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

**توضیح**:
- ما با استفاده از تابع `mpsc::channel` یک کانال جدید ایجاد می‌کنیم؛ `mpsc` مخفف **multiple producer, single consumer** (تولیدکننده چندگانه، مصرف‌کننده واحد) است.
- به طور خلاصه، نحوه پیاده‌سازی کانال‌ها در کتابخانه استاندارد Rust به این معناست که یک کانال می‌تواند چندین انتهای ارسال‌کننده داشته باشد که مقادیر را تولید می‌کنند، اما فقط یک انتهای گیرنده که آن مقادیر را مصرف می‌کند.
- مانند چندین جوی که به یک رودخانه بزرگ می‌ریزند: هر چیزی که از هر یک از جوی‌ها ارسال شود، در نهایت به یک رودخانه در انتها می‌رسد.
- تابع `mpsc::channel` یک تاپل برمی‌گرداند که عنصر اول آن انتهای ارسال‌کننده (فرستنده) و عنصر دوم آن انتهای گیرنده است. مخفف‌های `tx` و `rx` به ترتیب برای فرستنده (transmitter) و گیرنده (receiver) در بسیاری از حوزه‌ها به طور سنتی استفاده می‌شوند، بنابراین متغیرهایمان را به این صورت نام‌گذاری می‌کنیم.
- ما از یک دستور `let` با یک الگو استفاده می‌کنیم که تاپل را تجزیه (destructure) می‌کند؛ در فصل نوزدهم درباره استفاده از الگوها در دستورات `let` و تجزیه بیشتر بحث خواهیم کرد. فعلاً بدانید که استفاده از دستور `let` به این روش یک روش مناسب برای استخراج بخش‌های تاپل بازگشتی توسط `mpsc::channel` است.

## ارسال پیام از یک نخ تولیدشده

بیایید انتهای فرستنده را به یک نخ تولیدشده منتقل کنیم و آن را وادار کنیم یک رشته را ارسال کند تا نخ تولیدشده با نخ اصلی ارتباط برقرار کند، همان‌طور که در Listing 16-7 نشان داده شده است. این مانند قرار دادن یک اردک پلاستیکی در رودخانه در بالادست یا ارسال یک پیام چت از یک نخ به نخ دیگر است:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
    });
}
```

**توضیح**:
- ما دوباره از `thread::spawn` برای ایجاد یک نخ جدید استفاده می‌کنیم و از کلمه‌کلید `move` استفاده می‌کنیم تا `tx` را به کلوژر منتقل کنیم، بنابراین نخ تولیدشده مالک `tx` می‌شود. نخ تولیدشده برای ارسال پیام‌ها از طریق کانال باید مالک فرستنده باشد.
- فرستنده دارای متد `send` است که مقداری را که می‌خواهیم ارسال کنیم می‌گیرد. متد `send` یک نوع `Result<T, E>` برمی‌گرداند، بنابراین اگر گیرنده قبلاً حذف شده باشد و جایی برای ارسال مقدار وجود نداشته باشد، عملیات ارسال خطا برمی‌گرداند.
- در این مثال، از `unwrap` استفاده می‌کنیم تا در صورت خطا پنیک کنیم. اما در یک برنامه واقعی، باید خطا را به درستی مدیریت کنیم: به فصل نهم بازگردید تا استراتژی‌های مدیریت خطای مناسب را مرور کنید.

## دریافت پیام در نخ اصلی

در Listing 16-8، مقدار را از گیرنده در نخ اصلی دریافت می‌کنیم. این مانند برداشتن اردک پلاستیکی از آب در انتهای رودخانه یا دریافت یک پیام چت است:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("دریافت شد: {received}"); // Got: {received}
}
```

**خروجی**:

```
دریافت شد: سلام
```

**توضیح**:
- گیرنده دو متد مفید دارد: `recv` و `try_recv`. ما از `recv` (مخفف receive) استفاده می‌کنیم که اجرای نخ اصلی را مسدود می‌کند و منتظر می‌ماند تا مقداری از طریق کانال ارسال شود. وقتی مقداری ارسال شود، `recv` آن را در یک `Result<T, E>` برمی‌گرداند. وقتی فرستنده بسته شود، `recv` یک خطا برمی‌گرداند تا نشان دهد دیگر مقداری نخواهد آمد.
- متد `try_recv` مسدود نمی‌کند، بلکه بلافاصله یک `Result<T, E>` برمی‌گرداند: یک مقدار `Ok` که پیام را نگه می‌دارد اگر پیام در دسترس باشد، و یک مقدار `Err` اگر این بار پیامی وجود نداشته باشد. استفاده از `try_recv` زمانی مفید است که این نخ کار دیگری برای انجام دادن در حین انتظار برای پیام‌ها دارد: می‌توانیم یک حلقه بنویسیم که هر چند وقت یک‌بار `try_recv` را فراخوانی کند، اگر پیامی در دسترس باشد آن را مدیریت کند، و در غیر این صورت برای مدتی کار دیگری انجام دهد تا دوباره بررسی کند.
- ما در این مثال از `recv` برای سادگی استفاده کردیم؛ نخ اصلی کار دیگری جز انتظار برای پیام‌ها ندارد، بنابراین مسدود کردن نخ اصلی مناسب است.

## کانال‌ها و انتقال مالکیت

قوانین مالکیت نقش حیاتی در ارسال پیام ایفا می‌کنند، زیرا به شما کمک می‌کنند کد همزمان ایمن بنویسید. جلوگیری از خطاها در برنامه‌نویسی همزمان مزیت فکر کردن به مالکیت در سراسر برنامه‌های Rust شماست. بیایید آزمایشی انجام دهیم تا نشان دهیم چگونه کانال‌ها و مالکیت با هم کار می‌کنند تا از مشکلات جلوگیری کنند: سعی می‌کنیم از یک مقدار `val` در نخ تولیدشده بعد از اینکه آن را از طریق کانال ارسال کردیم استفاده کنیم. کد در Listing 16-9 را کامپایل کنید تا ببینید چرا این کد مجاز نیست:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
        println!("val برابر است با {val}"); // val is {val}
    });

    let received = rx.recv().unwrap();
    println!("دریافت شد: {received}"); // Got: {received}
}
```

**خطای کامپایل**:

```
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --> src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val برابر است با {val}"); // val is {val}
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
```

**توضیح**:
- ما سعی کردیم بعد از ارسال `val` از طریق `tx.send`، آن را چاپ کنیم. اجازه دادن به این کار ایده بدی است: وقتی مقدار به نخ دیگری ارسال شد، آن نخ می‌تواند آن را تغییر دهد یا حذف کند قبل از اینکه ما دوباره سعی کنیم از مقدار استفاده کنیم. این تغییرات احتمالی نخ دیگر می‌توانند به دلیل داده‌های ناسازگار یا غیرموجود باعث خطاها یا نتایج غیرمنتظره شوند.
- خوشبختانه، سیستم مالکیت Rust با دادن خطا در زمان کامپایل، ما را از این اشتباه همزمانی نجات می‌دهد. تابع `send` مالکیت پارامتر خود را می‌گیرد، و وقتی مقدار منتقل می‌شود، گیرنده مالکیت آن را به دست می‌آورد. این ما را از استفاده تصادفی دوباره از مقدار پس از ارسال باز می‌دارد؛ سیستم مالکیت بررسی می‌کند که همه چیز درست است.

## ارسال چندین مقدار و مشاهده انتظار گیرنده

کد در Listing 16-8 کامپایل و اجرا شد، اما به‌وضوح نشان نداد که دو نخ جداگانه از طریق کانال با یکدیگر صحبت می‌کنند. در Listing 16-10 تغییراتی ایجاد کردیم که ثابت می‌کند کد در Listing 16-8 به‌صورت همزمان اجرا می‌شود: نخ تولیدشده حالا چندین پیام ارسال می‌کند و بین هر پیام یک ثانیه مکث می‌کند:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("سلام"), // hi
            String::from("از"), // from
            String::from("این"), // the
            String::from("نخ"), // thread
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("دریافت شد: {received}"); // Got: {received}
    }
}
```

**خروجی**:

```
دریافت شد: سلام
دریافت شد: از
دریافت شد: این
دریافت شد: نخ
```

**توضیح**:
- این بار، نخ تولیدشده یک وکتور از رشته‌ها دارد که می‌خواهیم به نخ اصلی ارسال کنیم. ما روی آن‌ها پیمایش می‌کنیم، هر کدام را به‌صورت جداگانه ارسال می‌کنیم، و بین هر کدام با فراخوانی تابع `thread::sleep` با مقدار `Duration` یک ثانیه مکث می‌کنیم.
- در نخ اصلی، دیگر تابع `recv` را به‌صورت صریح فراخوانی نمی‌کنیم: در عوض، `rx` را به‌عنوان یک تکرارکننده (iterator) در نظر می‌گیریم. برای هر مقدار دریافت‌شده، آن را چاپ می‌کنیم. وقتی کانال بسته شود، تکرار پایان می‌یابد.
- چون هیچ کدی که در حلقه `for` نخ اصلی مکث یا تأخیر ایجاد کند نداریم، می‌توانیم بگوییم که نخ اصلی منتظر دریافت مقادیر از نخ تولیدشده است.

## ایجاد چندین تولیدکننده با کلون کردن فرستنده

قبلاً ذکر کردیم که `mpsc` مخفف **multiple producer, single consumer** است. بیایید از `mpsc` استفاده کنیم و کد در Listing 16-10 را گسترش دهیم تا چندین نخ ایجاد کنیم که همه مقادیر را به یک گیرنده ارسال کنند. می‌توانیم این کار را با کلون کردن فرستنده انجام دهیم، همان‌طور که در Listing 16-11 نشان داده شده است:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("سلام"), // hi
            String::from("از"), // from
            String::from("این"), // the
            String::from("نخ"), // thread
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("بیشتر"), // more
            String::from("پیام‌ها"), // messages
            String::from("برای"), // for
            String::from("شما"), // you
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("دریافت شد: {received}"); // Got: {received}
    }
}
```

**خروجی نمونه**:

```
دریافت شد: سلام
دریافت شد: بیشتر
دریافت شد: از
دریافت شد: پیام‌ها
دریافت شد: برای
دریافت شد: این
دریافت شد: نخ
دریافت شد: شما
```

**توضیح**:
- این بار، قبل از ایجاد اولین نخ تولیدشده، روی فرستنده `clone` را فراخوانی می‌کنیم. این یک فرستنده جدید به ما می‌دهد که می‌توانیم به اولین نخ تولیدشده پاس دهیم. فرستنده اصلی را به یک نخ تولیدشده دوم پاس می‌دهیم. این به ما دو نخ می‌دهد که هر کدام پیام‌های متفاوتی به یک گیرنده ارسال می‌کنند.
- ممکن است مقادیر را به ترتیب دیگری ببینید، بسته به سیستم شما. این چیزی است که همزمانی را هم جالب و هم دشوار می‌کند.
- اگر با `thread::sleep` آزمایش کنید و مقادیر مختلفی به آن در نخ‌های مختلف بدهید، هر اجرا غیرقطعی‌تر خواهد بود و هر بار خروجی متفاوتی ایجاد می‌کند.

حالا که نحوه کار کانال‌ها را بررسی کردیم، بیایید به روش دیگری از همزمانی نگاه کنیم.
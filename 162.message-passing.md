# استفاده از انتقال پیام برای جابجایی داده‌ها بین رسیمان‌ها

یکی از روش‌های روزافزون برای تضمین همزمانی ایمن، **انتقال پیام** (message passing) است، که در آن رسیمان‌ها یا بازیگران (actors) با ارسال پیام‌هایی حاوی داده به یکدیگر ارتباط برقرار می‌کنند. شعاری از مستندات زبان Go این ایده را به خوبی بیان می‌کند: «با به اشتراک گذاشتن حافظه ارتباط برقرار نکنید؛ در عوض، حافظه را با ارتباط به اشتراک بگذارید.»

برای پیاده‌سازی همزمانی مبتنی بر ارسال پیام، کتابخانه استاندارد Rust پیاده‌سازی‌ای از **کانال‌ها** (channels) ارائه می‌دهد. کانال یک مفهوم عمومی برنامه‌نویسی است که از طریق آن داده‌ها از یکرسیمان بهرسیمان دیگر ارسال می‌شوند.

می‌توانید یک کانال در برنامه‌نویسی را مانند یک جریان جهت‌دار آب، مانند یک جوی یا رودخانه، تصور کنید. اگر چیزی مانند یک اردک پلاستیکی را در رودخانه قرار دهید، به سمت پایین جریان می‌رود و به انتهای مسیر آب می‌رسد.

یک کانال از دو بخش تشکیل شده است: **فرستنده** (transmitter) و **گیرنده** (receiver). بخش فرستنده مانند محل بالادست رودخانه است که اردک پلاستیکی را در آن قرار می‌دهید، و بخش گیرنده جایی است که اردک در پایین‌دست به آن می‌رسد. بخشی از کد شما متدهایی را روی فرستنده با داده‌هایی که می‌خواهید ارسال کنید فراخوانی می‌کند، و بخش دیگر انتهای گیرنده را برای پیام‌های دریافتی بررسی می‌کند. گفته می‌شود یک کانال **بسته** (closed) است اگر یکی از نیمه‌های فرستنده یا گیرنده حذف (dropped) شود.

در اینجا، برنامه‌ای می‌سازیم که یکرسیمان مقادیر را تولید کرده و از طریق یک کانال ارسال می‌کند، ورسیمان دیگری این مقادیر را دریافت کرده و چاپ می‌کند. ما مقادیر ساده‌ای را بین رسیمان‌ها با استفاده از یک کانال ارسال می‌کنیم تا این ویژگی را نشان دهیم. وقتی با این تکنیک آشنا شدید، می‌توانید از کانال‌ها برای هر رسیمان‌هایی که نیاز به ارتباط با یکدیگر دارند استفاده کنید، مانند یک سیستم چت یا سیستمی که در آن چندینرسیمان بخش‌هایی از یک محاسبه را انجام داده و بخش‌ها را به یکرسیمان ارسال می‌کنند که نتایج را تجمیع می‌کند.

## ایجاد یک کانال

ابتدا، در فهرست کد 16-6، یک کانال ایجاد می‌کنیم اما هنوز کاری با آن انجام نمی‌دهیم. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود، زیرا Rust نمی‌داند چه نوع مقادیری می‌خواهیم از طریق کانال ارسال کنیم:


<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

**توضیح**:
- ما با استفاده از تابع `mpsc::channel` یک کانال جدید ایجاد می‌کنیم؛ `mpsc` مخفف **multiple producer, single consumer** (تولیدکننده چندگانه، مصرف‌کننده واحد) است.
- به طور خلاصه، نحوه پیاده‌سازی کانال‌ها در کتابخانه استاندارد Rust به این معناست که یک کانال می‌تواند چندین انتهای ارسال‌کننده داشته باشد که مقادیر را تولید می‌کنند، اما فقط یک انتهای گیرنده که آن مقادیر را مصرف می‌کند.
- مانند چندین جوی که به یک رودخانه بزرگ می‌ریزند: هر چیزی که از هر یک از جوی‌ها ارسال شود، در نهایت به یک رودخانه در انتها می‌رسد.
- تابع `mpsc::channel` یک تاپل برمی‌گرداند که عنصر اول آن انتهای ارسال‌کننده (فرستنده) و عنصر دوم آن انتهای گیرنده است. مخفف‌های `tx` و `rx` به ترتیب برای فرستنده (transmitter) و گیرنده (receiver) در بسیاری از حوزه‌ها به طور سنتی استفاده می‌شوند، بنابراین متغیرهایمان را به این صورت نام‌گذاری می‌کنیم.
- ما از یک دستور `let` با یک الگو استفاده می‌کنیم که تاپل را تجزیه (destructure) می‌کند؛ در فصل نوزدهم درباره استفاده از الگوها در دستورات `let` و تجزیه بیشتر بحث خواهیم کرد. فعلاً بدانید که استفاده از دستور `let` به این روش یک روش مناسب برای استخراج بخش‌های تاپل بازگشتی توسط `mpsc::channel` است.

## ارسال پیام از یکرسیمان تولیدشده

بیایید انتهای فرستنده را به یکرسیمان تولیدشده منتقل کنیم و آن را وادار کنیم یک رشته را ارسال کند تارسیمان تولیدشده بارسیمان اصلی ارتباط برقرار کند، همان‌طور که در فهرست کد 16-7 نشان داده شده است. این مانند قرار دادن یک اردک پلاستیکی در رودخانه در بالادست یا ارسال یک پیام چت از یکرسیمان بهرسیمان دیگر است:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
    });
}
```

**توضیح**:
- ما دوباره از `thread::spawn` برای ایجاد یکرسیمان جدید استفاده می‌کنیم و از کلمه‌کلید `move` استفاده می‌کنیم تا `tx` را به کلوژر منتقل کنیم، بنابراینرسیمان تولیدشده مالک `tx` می‌شود.رسیمان تولیدشده برای ارسال پیام‌ها از طریق کانال باید مالک فرستنده باشد.
- فرستنده دارای متد `send` است که مقداری را که می‌خواهیم ارسال کنیم می‌گیرد. متد `send` یک نوع `Result<T, E>` برمی‌گرداند، بنابراین اگر گیرنده قبلاً حذف شده باشد و جایی برای ارسال مقدار وجود نداشته باشد، عملیات ارسال خطا برمی‌گرداند.
- در این مثال، از `unwrap` استفاده می‌کنیم تا در صورت خطا پنیک کنیم. اما در یک برنامه واقعی، باید خطا را به درستی مدیریت کنیم: به فصل نهم بازگردید تا استراتژی‌های مدیریت خطای مناسب را مرور کنید.

## دریافت پیام دررسیمان اصلی

در فهرست کد 16-8، مقدار را از گیرنده دررسیمان اصلی دریافت می‌کنیم. این مانند برداشتن اردک پلاستیکی از آب در انتهای رودخانه یا دریافت یک پیام چت است:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("دریافت شد: {received}"); // Got: {received}
}
```

**خروجی**:

```
دریافت شد: سلام
```

**توضیح**:
- گیرنده دو متد مفید دارد: `recv` و `try_recv`. ما از `recv` (مخفف receive) استفاده می‌کنیم که اجرایرسیمان اصلی را مسدود می‌کند و منتظر می‌ماند تا مقداری از طریق کانال ارسال شود. وقتی مقداری ارسال شود، `recv` آن را در یک `Result<T, E>` برمی‌گرداند. وقتی فرستنده بسته شود، `recv` یک خطا برمی‌گرداند تا نشان دهد دیگر مقداری نخواهد آمد.
- متد `try_recv` مسدود نمی‌کند، بلکه بلافاصله یک `Result<T, E>` برمی‌گرداند: یک مقدار `Ok` که پیام را نگه می‌دارد اگر پیام در دسترس باشد، و یک مقدار `Err` اگر این بار پیامی وجود نداشته باشد. استفاده از `try_recv` زمانی مفید است که اینرسیمان کار دیگری برای انجام دادن در حین انتظار برای پیام‌ها دارد: می‌توانیم یک حلقه بنویسیم که هر چند وقت یک‌بار `try_recv` را فراخوانی کند، اگر پیامی در دسترس باشد آن را مدیریت کند، و در غیر این صورت برای مدتی کار دیگری انجام دهد تا دوباره بررسی کند.
- ما در این مثال از `recv` برای سادگی استفاده کردیم؛رسیمان اصلی کار دیگری جز انتظار برای پیام‌ها ندارد، بنابراین مسدود کردنرسیمان اصلی مناسب است.

## کانال‌ها و انتقال مالکیت

قوانین مالکیت نقش حیاتی در ارسال پیام ایفا می‌کنند، زیرا به شما کمک می‌کنند کد همزمان ایمن بنویسید. جلوگیری از خطاها در برنامه‌نویسی همزمان مزیت فکر کردن به مالکیت در سراسر برنامه‌های Rust شماست. بیایید آزمایشی انجام دهیم تا نشان دهیم چگونه کانال‌ها و مالکیت با هم کار می‌کنند تا از مشکلات جلوگیری کنند: سعی می‌کنیم از یک مقدار `val` دررسیمان تولیدشده بعد از اینکه آن را از طریق کانال ارسال کردیم استفاده کنیم. کد در فهرست کد 16-9 را کامپایل کنید تا ببینید چرا این کد مجاز نیست:


<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("سلام"); // hi
        tx.send(val).unwrap();
        println!("val برابر است با {val}"); // val is {val}
    });

    let received = rx.recv().unwrap();
    println!("دریافت شد: {received}"); // Got: {received}
}
```

**خطای کامپایل**:

```
$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --> src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val برابر است با {val}"); // val is {val}
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
```

**توضیح**:
- ما سعی کردیم بعد از ارسال `val` از طریق `tx.send`، آن را چاپ کنیم. اجازه دادن به این کار ایده بدی است: وقتی مقدار بهرسیمان دیگری ارسال شد، آنرسیمان می‌تواند آن را تغییر دهد یا حذف کند قبل از اینکه ما دوباره سعی کنیم از مقدار استفاده کنیم. این تغییرات احتمالیرسیمان دیگر می‌توانند به دلیل داده‌های ناسازگار یا غیرموجود باعث خطاها یا نتایج غیرمنتظره شوند.
- خوشبختانه، سیستم مالکیت Rust با دادن خطا در زمان کامپایل، ما را از این اشتباه همزمانی نجات می‌دهد. تابع `send` مالکیت پارامتر خود را می‌گیرد، و وقتی مقدار منتقل می‌شود، گیرنده مالکیت آن را به دست می‌آورد. این ما را از استفاده تصادفی دوباره از مقدار پس از ارسال باز می‌دارد؛ سیستم مالکیت بررسی می‌کند که همه چیز درست است.

## ارسال چندین مقدار و مشاهده انتظار گیرنده

کد در فهرست کد 16-8 کامپایل و اجرا شد، اما به‌وضوح نشان نداد که دورسیمان جداگانه از طریق کانال با یکدیگر صحبت می‌کنند. در فهرست کد 16-10 تغییراتی ایجاد کردیم که ثابت می‌کند کد در فهرست کد 16-8 به‌صورت همزمان اجرا می‌شود:رسیمان تولیدشده حالا چندین پیام ارسال می‌کند و بین هر پیام یک ثانیه مکث می‌کند:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("سلام"), // hi
            String::from("از"), // from
            String::from("این"), // the
            String::from("نخ"), // thread
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("دریافت شد: {received}"); // Got: {received}
    }
}
```

**خروجی**:

```
دریافت شد: سلام
دریافت شد: از
دریافت شد: این
دریافت شد: نخ
```

**توضیح**:
- این بار،رسیمان تولیدشده یک وکتور از رشته‌ها دارد که می‌خواهیم به رسیمان اصلی ارسال کنیم. ما روی آن‌ها پیمایش می‌کنیم، هر کدام را به‌صورت جداگانه ارسال می‌کنیم، و بین هر کدام با فراخوانی تابع `thread::sleep` با مقدار `Duration` یک ثانیه مکث می‌کنیم.
- دررسیمان اصلی، دیگر تابع `recv` را به‌صورت صریح فراخوانی نمی‌کنیم: در عوض، `rx` را به‌عنوان یک تکرارکننده (iterator) در نظر می‌گیریم. برای هر مقدار دریافت‌شده، آن را چاپ می‌کنیم. وقتی کانال بسته شود، تکرار پایان می‌یابد.
- چون هیچ کدی که در حلقه `for`رسیمان اصلی مکث یا تأخیر ایجاد کند نداریم، می‌توانیم بگوییم کهرسیمان اصلی منتظر دریافت مقادیر ازرسیمان تولیدشده است.

## ایجاد چندین تولیدکننده با کلون کردن فرستنده

قبلاً ذکر کردیم که `mpsc` مخفف **multiple producer, single consumer** است. بیایید از `mpsc` استفاده کنیم و کد در فهرست کد 16-10 را گسترش دهیم تا چندینرسیمان ایجاد کنیم که همه مقادیر را به یک گیرنده ارسال کنند. می‌توانیم این کار را با کلون کردن فرستنده انجام دهیم، همان‌طور که در فهرست کد 16-11 نشان داده شده است:

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("سلام"), // hi
            String::from("از"), // from
            String::from("این"), // the
            String::from("نخ"), // thread
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("بیشتر"), // more
            String::from("پیام‌ها"), // messages
            String::from("برای"), // for
            String::from("شما"), // you
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("دریافت شد: {received}"); // Got: {received}
    }
}
```

**خروجی نمونه**:

```
دریافت شد: سلام
دریافت شد: بیشتر
دریافت شد: از
دریافت شد: پیام‌ها
دریافت شد: برای
دریافت شد: این
دریافت شد: نخ
دریافت شد: شما
```

**توضیح**:
- این بار، قبل از ایجاد اولینرسیمان تولیدشده، روی فرستنده `clone` را فراخوانی می‌کنیم. این یک فرستنده جدید به ما می‌دهد که می‌توانیم به اولینرسیمان تولیدشده پاس دهیم. فرستنده اصلی را به یکرسیمان تولیدشده دوم پاس می‌دهیم. این به ما دورسیمان می‌دهد که هر کدام پیام‌های متفاوتی به یک گیرنده ارسال می‌کنند.
- ممکن است مقادیر را به ترتیب دیگری ببینید، بسته به سیستم شما. این چیزی است که همزمانی را هم جالب و هم دشوار می‌کند.
- اگر با `thread::sleep` آزمایش کنید و مقادیر مختلفی به آن در رسیمان‌های مختلف بدهید، هر اجرا غیرقطعی‌تر خواهد بود و هر بار خروجی متفاوتی ایجاد می‌کند.

حالا که نحوه کار کانال‌ها را بررسی کردیم، بیایید به روش دیگری از همزمانی نگاه کنیم.
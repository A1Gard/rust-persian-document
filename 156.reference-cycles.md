# چرخه‌های مرجع می‌توانند باعث نشت حافظه شوند

تضمین‌های ایمنی حافظه در Rust ایجاد حافظه‌ای که هرگز پاکسازی نشود (معروف به **نشت حافظه** یا memory leak) را دشوار می‌کنند، اما غیرممکن نیست. جلوگیری کامل از نشت‌های حافظه یکی از تضمین‌های Rust نیست، به این معنا که نشت‌های حافظه در Rust از نظر ایمنی حافظه مشکلی ایجاد نمی‌کنند. می‌توانیم ببینیم که Rust با استفاده از `Rc<T>` و `RefCell<T>` امکان نشت حافظه را فراهم می‌کند: می‌توان ارجاعاتی ایجاد کرد که آیتم‌ها به‌صورت چرخه‌ای به یکدیگر اشاره کنند. این باعث نشت حافظه می‌شود، زیرا برشمارش مرجع هر آیتم در چرخه هرگز به صفر نمی‌رسد و مقادیر هیچ‌گاه حذف (drop) نمی‌شوند.

## ایجاد یک چرخه مرجع

بیایید بررسی کنیم که چگونه یک چرخه مرجع ممکن است ایجاد شود و چگونه می‌توان از آن جلوگیری کرد. ابتدا با تعریف نوع `List` و متد `tail` در Listing 15-25 شروع می‌کنیم:

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

**توضیح کد**:
- ما از نسخه دیگری از تعریف `List` که در Listing 15-5 معرفی شد استفاده می‌کنیم. عنصر دوم در نوع `Cons` حالا `RefCell<Rc<List>>` است، به این معنا که به جای تغییر مقدار `i32` (مانند Listing 15-24)، می‌خواهیم مقدار `List` که یک نوع `Cons` به آن اشاره می‌کند را تغییر دهیم.
- متد `tail` را اضافه کردیم تا دسترسی به آیتم دوم در صورت داشتن یک نوع `Cons` راحت‌تر شود.

در Listing 15-26، تابع `main` را اضافه می‌کنیم که از تعریف‌های Listing 15-25 استفاده می‌کند. این کد یک لیست در `a` و یک لیست در `b` که به لیست `a` اشاره می‌کند ایجاد می‌کند. سپس لیست `a` را تغییر می‌دهد تا به `b` اشاره کند و یک چرخه مرجع ایجاد می‌کند. دستورات `println!` در طول مسیر اضافه شده‌اند تا برشمارش مراجع در نقاط مختلف این فرآیند نشان داده شود:

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("برشمارش اولیه rc برای a = {}", Rc::strong_count(&a)); // a initial rc count
    println!("آیتم بعدی a = {:?}", a.tail()); // a next item

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("برشمارش rc برای a پس از ایجاد b = {}", Rc::strong_count(&a)); // a rc count after b creation
    println!("برشمارش اولیه rc برای b = {}", Rc::strong_count(&b)); // b initial rc count
    println!("آیتم بعدی b = {:?}", b.tail()); // b next item

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("برشمارش rc برای b پس از تغییر a = {}", Rc::strong_count(&b)); // b rc count after changing a
    println!("برشمارش rc برای a پس از تغییر a = {}", Rc::strong_count(&a)); // a rc count after changing a

    // خط بعدی را از حالت کامنت خارج کنید تا چرخه را ببینید؛
    // این باعث سرریز پشته می‌شود.
    // println!("آیتم بعدی a = {:?}", a.tail()); // a next item
}
```

**خروجی کد:**

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
برشمارش اولیه rc برای a = 1
آیتم بعدی a = Some(RefCell { value: Nil })
برشمارش rc برای a پس از ایجاد b = 2
برشمارش اولیه rc برای b = 1
آیتم بعدی b = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
برشمارش rc برای b پس از تغییر a = 2
برشمارش rc برای a پس از تغییر a = 2
```

**توضیح خروجی**:
- ما یک نمونه `Rc<List>` در متغیر `a` ایجاد می‌کنیم که یک لیست با مقدار اولیه `5, Nil` دارد.
- سپس یک نمونه `Rc<List>` دیگر در متغیر `b` ایجاد می‌کنیم که شامل مقدار 10 است و به لیست `a` اشاره می‌کند.
- با استفاده از متد `tail`، به `RefCell<Rc<List>>` در `a` دسترسی پیدا می‌کنیم و آن را در متغیر `link` قرار می‌دهیم. سپس با استفاده از متد `borrow_mut` روی `RefCell<Rc<List>>`، مقدار داخلی را از `Rc<List>` که شامل `Nil` است به `Rc<List>` در `b` تغییر می‌دهیم و چرخه‌ای ایجاد می‌کنیم.
- پس از تغییر لیست در `a` به اشاره به `b`، برشمارش مرجع نمونه‌های `Rc<List>` در هر دو `a` و `b` به 2 می‌رسد.
- در انتهای `main`، Rust متغیر `b` را حذف می‌کند که برشمارش مرجع نمونه `b` را از 2 به 1 کاهش می‌دهد. حافظه‌ای که `Rc<List>` در هیپ دارد در این مرحله حذف نمی‌شود، زیرا برشمارش مرجع آن 1 است، نه 0.
- سپس Rust متغیر `a` را حذف می‌کند که برشمارش مرجع نمونه `a` را نیز از 2 به 1 کاهش می‌دهد. این حافظه هم نمی‌تواند حذف شود، زیرا نمونه دیگر `Rc<List>` همچنان به آن اشاره می‌کند.
- حافظه تخصیص‌یافته به لیست برای همیشه جمع‌آوری نشده باقی می‌ماند.

**شکل 15-4: چرخه مرجع بین لیست‌های `a` و `b` که به یکدیگر اشاره می‌کنند**

<img src="img/trpl15-04.svg">

اگر خط آخر `println!` را از حالت کامنت خارج کنید و برنامه را اجرا کنید، Rust سعی می‌کند این چرخه را چاپ کند که در آن `a` به `b` اشاره می‌کند و `b` به `a` و همین‌طور ادامه می‌یابد تا زمانی که پشته سرریز شود.

در مقایسه با برنامه‌های واقعی، پیامدهای ایجاد یک چرخه مرجع در این مثال چندان جدی نیست: درست پس از ایجاد چرخه مرجع، برنامه پایان می‌یابد. اما اگر یک برنامه پیچیده‌تر مقدار زیادی حافظه را در یک چرخه تخصیص دهد و آن را برای مدت طولانی نگه دارد، برنامه حافظه بیشتری از آنچه نیاز دارد استفاده می‌کند و ممکن است سیستم را تحت فشار قرار دهد و باعث اتمام حافظه در دسترس شود.

ایجاد چرخه‌های مرجع به‌راحتی انجام نمی‌شود، اما غیرممکن هم نیست. اگر مقادیر `RefCell<T>` دارید که شامل مقادیر `Rc<T>` یا ترکیب‌های تو در تو مشابه با تغییرپذیری داخلی و برشمارش مرجع هستند، باید اطمینان حاصل کنید که چرخه‌ای ایجاد نمی‌کنید؛ نمی‌توانید به Rust برای شناسایی آن‌ها تکیه کنید. ایجاد یک چرخه مرجع یک اشکال منطقی (logic bug) در برنامه شما است که باید با استفاده از تست‌های خودکار، بازبینی کد و سایر شیوه‌های توسعه نرم‌افزار به حداقل برسانید.

**راه‌حل جایگزین**: یک راه دیگر برای جلوگیری از چرخه‌های مرجع، بازسازی ساختارهای داده‌تان است به‌گونه‌ای که برخی ارجاعات مالکیت را بیان کنند و برخی دیگر نه. در نتیجه، می‌توانید چرخه‌هایی داشته باشید که از برخی روابط مالکیتی و برخی روابط غیرمالکیتی تشکیل شده‌اند و فقط روابط مالکیتی روی اینکه آیا یک مقدار می‌تواند حذف شود یا نه تأثیر می‌گذارند. در Listing 15-25، ما همیشه می‌خواهیم نوع‌های `Cons` مالک لیست خود باشند، بنابراین بازسازی ساختار داده در این مورد ممکن نیست. بیایید مثالی با گراف‌هایی از گره‌های والد و فرزند بررسی کنیم تا ببینیم روابط غیرمالکیتی چه زمانی برای جلوگیری از چرخه‌های مرجع مناسب هستند.

## جلوگیری از چرخه‌های مرجع با استفاده از `Weak<T>`

تاکنون نشان دادیم که فراخوانی `Rc::clone` تعداد `strong_count` یک نمونه `Rc<T>` را افزایش می‌دهد و یک نمونه `Rc<T>` تنها زمانی پاکسازی می‌شود که `strong_count` آن به 0 برسد. همچنین می‌توانید با فراخوانی `Rc::downgrade` و پاس دادن یک ارجاع به `Rc<T>`، یک **ارجاع ضعیف** (weak reference) به مقدار داخل نمونه `Rc<T>` ایجاد کنید. ارجاعات قوی (strong references) راهی برای به اشتراک گذاشتن مالکیت یک نمونه `Rc<T>` هستند. ارجاعات ضعیف رابطه مالکیتی را بیان نمی‌کنند و برشمارش آن‌ها روی زمان پاکسازی نمونه `Rc<T>` تأثیر نمی‌گذارد. بنابراین، آن‌ها باعث ایجاد چرخه مرجع نمی‌شوند، زیرا هر چرخه‌ای که شامل ارجاعات ضعیف باشد، زمانی که تعداد ارجاعات قوی مقادیر درگیر به 0 برسد، شکسته می‌شود.

وقتی `Rc::downgrade` را فراخوانی می‌کنید، یک اشاره‌گر هوشمند از نوع `Weak<T>` دریافت می‌کنید. به جای افزایش `strong_count` در نمونه `Rc<T>` به اندازه 1، فراخوانی `Rc::downgrade` تعداد `weak_count` را 1 واحد افزایش می‌دهد. نوع `Rc<T>` از `weak_count` برای ردیابی تعداد ارجاعات `Weak<T>` موجود استفاده می‌کند، مشابه `strong_count`. تفاوت در این است که `weak_count` نیازی به صفر بودن برای پاکسازی نمونه `Rc<T>` ندارد.

از آنجا که مقداری که `Weak<T>` به آن اشاره می‌کند ممکن است حذف شده باشد، برای انجام هر کاری با مقداری که یک `Weak<T>` به آن اشاره می‌کند، باید مطمئن شوید که مقدار همچنان وجود دارد. این کار را با فراخوانی متد `upgrade` روی یک نمونه `Weak<T>` انجام می‌دهید که یک `Option<Rc<T>>` برمی‌گرداند. اگر مقدار `Rc<T>` هنوز حذف نشده باشد، نتیجه `Some` خواهد بود و اگر مقدار `Rc<T>` حذف شده باشد، نتیجه `None` خواهد بود. چون `upgrade` یک `Option<Rc<T>>` برمی‌گرداند، Rust تضمین می‌کند که موارد `Some` و `None` مدیریت شوند و هیچ اشاره‌گر نامعتبری وجود نداشته باشد.

### ایجاد یک ساختار داده درختی: گره با گره‌های فرزند

به عنوان مثال، به جای استفاده از لیستی که آیتم‌های آن فقط از آیتم بعدی خبر دارند، یک درخت می‌سازیم که آیتم‌های آن از گره‌های فرزند و والد خود آگاه هستند. ابتدا یک درخت با گره‌هایی می‌سازیم که از گره‌های فرزند خود خبر دارند. یک ساختار به نام `Node` ایجاد می‌کنیم که مقدار `i32` خود و ارجاعاتی به گره‌های فرزند خود از نوع `Node` را نگه می‌دارد:

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
```

**توضیح**:
- ما می‌خواهیم یک `Node` مالک گره‌های فرزند خود باشد و این مالکیت را با متغیرها به اشتراک بگذاریم تا بتوانیم به هر `Node` در درخت مستقیماً دسترسی داشته باشیم. برای این کار، آیتم‌های `Vec<T>` را از نوع `Rc<Node>` تعریف می‌کنیم.
- همچنین می‌خواهیم بتوانیم مشخص کنیم که کدام گره‌ها فرزند گره دیگری هستند، بنابراین یک `RefCell<T>` دور `Vec<Rc<Node>>` در فیلد `children` قرار می‌دهیم.

در ادامه، از تعریف ساختار خود استفاده می‌کنیم و یک نمونه `Node` به نام `leaf` با مقدار 3 و بدون فرزند، و یک نمونه دیگر به نام `branch` با مقدار 5 و `leaf` به عنوان یکی از فرزندانش ایجاد می‌کنیم، همان‌طور که در Listing 15-27 نشان داده شده است:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```

**توضیح**:
- ما `Rc<Node>` در `leaf` را کلون می‌کنیم و آن را در `branch` ذخیره می‌کنیم، به این معنا که `Node` در `leaf` حالا دو مالک دارد: `leaf` و `branch`.
- می‌توانیم از `branch` به `leaf` از طریق `branch.children` دسترسی پیدا کنیم، اما راهی برای رفتن از `leaf` به `branch` وجود ندارد. دلیلش این است که `leaf` هیچ ارجاعی به `branch` ندارد و نمی‌داند که این دو به هم مرتبط هستند.
- می‌خواهیم `leaf` بداند که `branch` والد آن است. این کار را در ادامه انجام می‌دهیم.

### افزودن ارجاع از فرزند به والد

برای اینکه گره فرزند از والد خود آگاه باشد، باید یک فیلد `parent` به تعریف ساختار `Node` اضافه کنیم. مشکل در انتخاب نوع فیلد `parent` است. می‌دانیم که نمی‌تواند شامل `Rc<T>` باشد، زیرا این کار یک چرخه مرجع ایجاد می‌کند که در آن `leaf.parent` به `branch` و `branch.children` به `leaf` اشاره می‌کند، و این باعث می‌شود مقادیر `strong_count` آن‌ها هرگز به 0 نرسد.

با نگاه دیگری به روابط، یک گره والد باید مالک گره‌های فرزند خود باشد: اگر یک گره والد حذف شود، گره‌های فرزند آن نیز باید حذف شوند. اما یک فرزند نباید مالک والد خود باشد: اگر یک گره فرزند را حذف کنیم، والد باید همچنان وجود داشته باشد. این مورد برای ارجاعات ضعیف مناسب است!

بنابراین، به جای `Rc<T>`، نوع فیلد `parent` را از `Weak<T>` استفاده می‌کنیم، به‌طور خاص یک `RefCell<Weak<Node>>`. حالا تعریف ساختار `Node` ما به این شکل است:

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```

**توضیح**:
- یک گره حالا می‌تواند به گره والد خود اشاره کند اما مالک آن نیست.

در Listing 15-28، تابع `main` را به‌روزرسانی می‌کنیم تا از این تعریف جدید استفاده کند و گره `leaf` راهی برای اشاره به والد خود، یعنی `branch`، داشته باشد:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("والد leaf = {:?}", leaf.parent.borrow().upgrade()); // leaf parent

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("والد leaf = {:?}", leaf.parent.borrow().upgrade()); // leaf parent
}
```

**خروجی کد:**

```
والد leaf = None
والد leaf = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```

**توضیح کد**:
- ایجاد گره `leaf` مشابه Listing 15-27 است، با این تفاوت که فیلد `parent` در ابتدا بدون والد است، بنابراین یک ارجاع `Weak<Node>` خالی جدید ایجاد می‌کنیم.
- وقتی سعی می‌کنیم با استفاده از متد `upgrade` به والد `leaf` دسترسی پیدا کنیم، مقدار `None` دریافت می‌کنیم، همان‌طور که در خروجی اولین `println!` می‌بینیم.
- وقتی گره `branch` را ایجاد می‌کنیم، آن هم یک ارجاع `Weak<Node>` جدید در فیلد `parent` دارد، زیرا `branch` والدی ندارد. همچنان `leaf` را به عنوان یکی از فرزندان `branch` داریم.
- وقتی نمونه `Node` را در `branch` داریم، می‌توانیم `leaf` را تغییر دهیم تا یک ارجاع `Weak<Node>` به والد خود داشته باشد. ما از متد `borrow_mut` روی `RefCell<Weak<Node>>` در فیلد `parent` از `leaf` استفاده می‌کنیم و سپس از تابع `Rc::downgrade` برای ایجاد یک ارجاع `Weak<Node>` به `branch` از `Rc<Node>` در `branch` استفاده می‌کنیم.
- وقتی دوباره والد `leaf` را چاپ می‌کنیم، این بار یک نوع `Some` دریافت می‌کنیم که شامل `branch` است: حالا `leaf` می‌تواند به والد خود دسترسی پیدا کند!
- هنگام چاپ `leaf`، از چرخه‌ای که در Listing 15-26 باعث سرریز پشته شد جلوگیری می‌کنیم؛ ارجاعات `Weak<Node>` به صورت `(Weak)` چاپ می‌شوند.
- نبود خروجی بی‌نهایت نشان می‌دهد که این کد چرخه مرجع ایجاد نکرده است. همچنین می‌توانیم این را با بررسی مقادیر دریافت‌شده از فراخوانی `Rc::strong_count` و `Rc::weak_count` تأیید کنیم.

### تجسم تغییرات در `strong_count` و `weak_count`

بیایید بررسی کنیم که چگونه مقادیر `strong_count` و `weak_count` نمونه‌های `Rc<Node>` با ایجاد یک محدوده داخلی جدید و انتقال ایجاد `branch` به آن محدوده تغییر می‌کنند. با این کار می‌توانیم ببینیم وقتی `branch` ایجاد می‌شود و سپس با خروج از محدوده حذف می‌شود، چه اتفاقی می‌افتد. تغییرات در Listing 15-29 نشان داده شده است:

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}", // leaf strong, weak
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}", // branch strong, weak
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}", // leaf strong, weak
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("والد leaf = {:?}", leaf.parent.borrow().upgrade()); // leaf parent
    println!(
        "leaf strong = {}, weak = {}", // leaf strong, weak
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```

**خروجی کد:**

```
leaf strong = 1, weak = 0
branch strong = 1, weak = 1
leaf strong = 2, weak = 0
والد leaf = None
leaf strong = 1, weak = 0
```

**توضیح خروجی**:
- پس از ایجاد `leaf`، نمونه `Rc<Node>` آن یک `strong_count` برابر با 1 و یک `weak_count` برابر با 0 دارد.
- در محدوده داخلی، `branch` را ایجاد می‌کنیم و آن را با `leaf` مرتبط می‌کنیم. در این مرحله، وقتی برشمارش‌ها را چاپ می‌کنیم، `Rc<Node>` در `branch` یک `strong_count` برابر با 1 و یک `weak_count` برابر با 1 خواهد داشت (برای `leaf.parent` که با یک `Weak<Node>` به `branch` اشاره می‌کند).
- وقتی برشمارش‌ها را برای `leaf` چاپ می‌کنیم، می‌بینیم که `strong_count` آن 2 است، زیرا `branch` حالا یک کپی از `Rc<Node>` مربوط به `leaf` را در `branch.children` ذخیره کرده است، اما `weak_count` همچنان 0 است.
- وقتی محدوده داخلی پایان می‌یابد، `branch` از محدوده خارج می‌شود و `strong_count` نمونه `Rc<Node>` به 0 کاهش می‌یابد، بنابراین `Node` آن حذف می‌شود. `weak_count` برابر با 1 از `leaf.parent` تأثیری روی حذف شدن یا نشدن `Node` ندارد، بنابراین هیچ نشت حافظه‌ای رخ نمی‌دهد!
- اگر پس از پایان محدوده سعی کنیم به والد `leaf` دسترسی پیدا کنیم، دوباره `None` دریافت می‌کنیم.
- در انتهای برنامه، `Rc<Node>` در `leaf` یک `strong_count` برابر با 1 و یک `weak_count` برابر با 0 دارد، زیرا متغیر `leaf` حالا تنها ارجاع به `Rc<Node>` است.

تمام منطقی که برشمارش‌ها و حذف مقادیر را مدیریت می‌کند، در `Rc<T>` و `Weak<T>` و پیاده‌سازی‌های ویژگی `Drop` آن‌ها تعبیه شده است. با مشخص کردن اینکه رابطه از فرزند به والد باید یک ارجاع `Weak<T>` در تعریف `Node` باشد، می‌توانید اجازه دهید گره‌های والد به گره‌های فرزند و بالعکس اشاره کنند بدون ایجاد چرخه مرجع و نشت حافظه.

## خلاصه

در این فصل، نحوه استفاده از اشاره‌گرهای هوشمند برای ایجاد تضمین‌ها و تعادل‌های متفاوت نسبت به آنچه Rust به‌صورت پیش‌فرض با ارجاعات معمولی ارائه می‌دهد را بررسی کردیم:
- نوع `Box<T>` اندازه‌ای مشخص دارد و به داده‌های تخصیص‌یافته روی هیپ اشاره می‌کند.
- نوع `Rc<T>` تعداد ارجاعات به داده‌های روی هیپ را ردیابی می‌کند تا داده‌ها بتوانند چندین مالک داشته باشند.
- نوع `RefCell<T>` با تغییرپذیری داخلی خود، به ما اجازه می‌دهد از نوعی استفاده کنیم که وقتی نیاز به تغییر مقدار داخلی آن داریم، غیرقابل تغییر به نظر می‌رسد؛ همچنین قوانین قرض‌گیری را در زمان اجرا به جای زمان کامپایل اعمال می‌کند.

همچنین درباره ویژگی‌های `Deref` و `Drop` صحبت کردیم که بسیاری از قابلیت‌های اشاره‌گرهای هوشمند را ممکن می‌سازند. ما چرخه‌های مرجعی که می‌توانند باعث نشت حافظه شوند و نحوه جلوگیری از آن‌ها با استفاده از `Weak<T>` را بررسی کردیم.

> **توجه**: اگر این فصل علاقه شما را برانگیخته و می‌خواهید اشاره‌گرهای هوشمند خودتان را پیاده‌سازی کنید، به منبع «The Rustonomicon» برای اطلاعات مفیدتر مراجعه کنید.

در ادامه، درباره همزمانی (concurrency) در Rust صحبت خواهیم کرد. حتی درباره چند اشاره‌گر هوشمند جدید نیز خواهید آموخت.
# اعتبارسنجی مراجع با طول عمر (Lifetimes)

طول عمرها نوع دیگری از Generic‌ها هستند که قبلاً از آن‌ها استفاده کرده‌ایم. به جای اطمینان از اینکه یک نوع رفتار مورد نظر ما را دارد، طول عمرها تضمین می‌کنند که مراجع تا زمانی که به آن‌ها نیاز داریم معتبر باقی می‌مانند.

یکی از جزئیاتی که در بخش «مراجع و قرض‌گیری» در فصل چهارم بحث نکردیم این است که هر مرجع در **Rust** یک طول عمر دارد، که حوزه‌ای است که آن مرجع در آن معتبر است. بیشتر اوقات، طول عمرها ضمنی و استنباط‌شده هستند، درست مانند اینکه بیشتر اوقات نوع‌ها استنباط می‌شوند. ما فقط باید نوع‌ها را زمانی حاشیه‌نویسی کنیم که چندین نوع ممکن باشد. به طور مشابه، باید طول عمرها را زمانی حاشیه‌نویسی کنیم که طول عمر مراجع ممکن است به چند روش مختلف مرتبط باشند. **Rust** از ما می‌خواهد روابط را با استفاده از پارامترهای طول عمر Generic حاشیه‌نویسی کنیم تا اطمینان حاصل شود که مراجع واقعی استفاده‌شده در زمان اجرا قطعاً معتبر خواهند بود.

حاشیه‌نویسی طول عمر حتی مفهومی نیست که بیشتر زبان‌های برنامه‌نویسی دیگر داشته باشند، بنابراین این ممکن است ناآشنا به نظر برسد. اگرچه در این فصل طول عمرها را به طور کامل پوشش نمی‌دهیم، روش‌های رایجی که ممکن است با نحو طول عمر مواجه شوید را بحث خواهیم کرد تا با این مفهوم راحت شوید.

## جلوگیری از مراجع معلق با طول عمر

هدف اصلی طول عمرها جلوگیری از **مراجع معلق (dangling references)** است، که باعث می‌شود برنامه به داده‌ای ارجاع دهد که غیر از داده‌ای که قصد ارجاع به آن را داشته است. برنامه در **جدول 10-16** را در نظر بگیرید، که دارای یک حوزه بیرونی و یک حوزه درونی است.

**این کد کامپایل نمی‌شود!**

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {r}");
}
```

**جدول 10-16**: تلاش برای استفاده از مرجعی که مقدار آن از حوزه خارج شده است

> **توجه**: مثال‌های موجود در جداول 10-16، 10-17، و 10-23 متغیرها را بدون دادن مقدار اولیه به آن‌ها اعلام می‌کنند، بنابراین نام متغیر در حوزه بیرونی وجود دارد. در نگاه اول، این ممکن است با این که **Rust** هیچ مقدار نال ندارد در تضاد به نظر برسد. با این حال، اگر سعی کنیم از یک متغیر قبل از دادن مقدار به آن استفاده کنیم، یک خطای زمان کامپایل دریافت خواهیم کرد، که نشان می‌دهد **Rust** واقعاً اجازه مقادیر نال را نمی‌دهد.

حوزه بیرونی یک متغیر به نام `r` بدون مقدار اولیه اعلام می‌کند، و حوزه درونی یک متغیر به نام `x` با مقدار اولیه 5 اعلام می‌کند. در داخل حوزه درونی، سعی می‌کنیم مقدار `r` را به‌عنوان مرجعی به `x` تنظیم کنیم. سپس حوزه درونی پایان می‌یابد، و ما سعی می‌کنیم مقدار موجود در `r` را چاپ کنیم. این کد کامپایل نمی‌شود زیرا مقداری که `r` به آن ارجاع می‌دهد قبل از اینکه بخواهیم از آن استفاده کنیم از حوزه خارج شده است. پیام خطا به این صورت است:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

پیام خطا می‌گوید که متغیر `x` «به اندازه کافی عمر نمی‌کند». دلیلش این است که `x` وقتی حوزه درونی در خط 7 پایان می‌یابد از حوزه خارج می‌شود. اما `r` همچنان برای حوزه بیرونی معتبر است؛ چون حوزه‌اش بزرگ‌تر است، می‌گوییم که «طولانی‌تر عمر می‌کند». اگر **Rust** اجازه می‌داد این کد کار کند، `r` به حافظه‌ای ارجاع می‌داد که وقتی `x` از حوزه خارج شد آزاد شده بود، و هر کاری که با `r` سعی می‌کردیم انجام دهیم به درستی کار نمی‌کرد. پس **Rust** چگونه تشخیص می‌دهد که این کد نامعتبر است؟ از یک **بررسی‌کننده قرض (borrow checker)** استفاده می‌کند.

## بررسی‌کننده قرض

کامپایلر **Rust** یک بررسی‌کننده قرض دارد که حوزه‌ها را مقایسه می‌کند تا مشخص کند آیا همه قرض‌ها معتبر هستند یا خیر. **جدول 10-17** همان کد موجود در **جدول 10-16** را نشان می‌دهد اما با حاشیه‌نویسی‌هایی که طول عمر متغیرها را نشان می‌دهند.

**این کد کامپایل نمی‌شود!**

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

**جدول 10-17**: حاشیه‌نویسی‌های طول عمر `r` و `x`، که به ترتیب `'a` و `'b` نام‌گذاری شده‌اند

در اینجا، طول عمر `r` را با `'a` و طول عمر `x` را با `'b` حاشیه‌نویسی کرده‌ایم. همان‌طور که می‌بینید، بلاک درونی `'b` بسیار کوچک‌تر از بلاک طول عمر بیرونی `'a` است. در زمان کامپایل، **Rust** اندازه دو طول عمر را مقایسه می‌کند و می‌بیند که `r` دارای طول عمر `'a` است اما به حافظه‌ای با طول عمر `'b` ارجاع می‌دهد. برنامه رد می‌شود زیرا `'b` کوتاه‌تر از `'a` است: موضوع مرجع به اندازه مرجع عمر نمی‌کند.

**جدول 10-18** کد را اصلاح می‌کند تا مرجع معلق نداشته باشد و بدون هیچ خطایی کامپایل شود.

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

**جدول 10-18**: یک مرجع معتبر زیرا داده طول عمر طولانی‌تری نسبت به مرجع دارد

در اینجا، `x` دارای طول عمر `'b` است، که در این مورد بزرگ‌تر از `'a` است. این بدان معناست که `r` می‌تواند به `x` ارجاع دهد زیرا **Rust** می‌داند که مرجع در `r` همیشه تا زمانی که `x` معتبر است معتبر خواهد بود.

اکنون که می‌دانید طول عمر مراجع کجاست و چگونه **Rust** طول عمرها را تحلیل می‌کند تا اطمینان حاصل کند که مراجع همیشه معتبر خواهند بود، بیایید طول عمرهای Generic پارامترها و مقادیر بازگشتی را در زمینه توابع بررسی کنیم.

## طول عمرهای Generic در توابع

ما تابعی خواهیم نوشت که طولانی‌ترین برش رشته‌ای از بین دو برش رشته‌ای را برمی‌گرداند. این تابع دو برش رشته‌ای می‌گیرد و یک برش رشته‌ای واحد برمی‌گرداند. پس از پیاده‌سازی تابع `longest`، کد در **جدول 10-19** باید چاپ کند: `The longest string is abcd`.

**فایل: src/main.rs**

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}
```

**جدول 10-19**: یک تابع `main` که تابع `longest` را فراخوانی می‌کند تا طولانی‌ترین برش از بین دو برش رشته‌ای را پیدا کند

توجه داشته باشید که ما می‌خواهیم تابع برش‌های رشته‌ای را بگیرد، که مراجع هستند، نه رشته‌ها، زیرا نمی‌خواهیم تابع `longest` مالکیت پارامترهایش را بگیرد. برای بحث بیشتر درباره اینکه چرا پارامترهایی که در **جدول 10-19** استفاده می‌کنیم همان‌هایی هستند که می‌خواهیم، به بخش «برش‌های رشته‌ای به‌عنوان پارامتر» در فصل چهارم مراجعه کنید.

اگر سعی کنیم تابع `longest` را همان‌طور که در **جدول 10-20** نشان داده شده پیاده‌سازی کنیم، کامپایل نخواهد شد.

**فایل: src/main.rs**

**این کد کامپایل نمی‌شود!**

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

**جدول 10-20**: یک پیاده‌سازی از تابع `longest` که طولانی‌ترین برش از بین دو برش رشته‌ای را برمی‌گرداند اما هنوز کامپایل نمی‌شود

به جای آن، خطای زیر را دریافت می‌کنیم که درباره طول عمرها صحبت می‌کند:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

متن راهنما نشان می‌دهد که نوع بازگشتی به یک پارامتر طول عمر Generic نیاز دارد زیرا **Rust** نمی‌تواند تشخیص دهد که مرجع برگردانده‌شده به `x` ارجاع می‌دهد یا به `y`. در واقع، ما هم نمی‌دانیم، زیرا بلاک `if` در بدنه این تابع مرجعی به `x` برمی‌گرداند و بلاک `else` مرجعی به `y` برمی‌گرداند!

وقتی این تابع را تعریف می‌کنیم، نمی‌دانیم مقادیر مشخصی که به این تابع پاس داده می‌شوند چیستند، بنابراین نمی‌دانیم که مورد `if` اجرا خواهد شد یا مورد `else`. همچنین طول عمرهای مشخص مراجعی که پاس داده می‌شوند را نمی‌دانیم، بنابراین نمی‌توانیم به حوزه‌ها نگاه کنیم همان‌طور که در جداول 10-17 و 10-18 کردیم تا مشخص کنیم آیا مرجعی که برمی‌گردانیم همیشه معتبر خواهد بود یا خیر. بررسی‌کننده قرض هم نمی‌تواند این را تشخیص دهد، زیرا نمی‌داند طول عمرهای `x` و `y` چگونه با طول عمر مقدار بازگشتی مرتبط هستند. برای رفع این خطا، پارامترهای طول عمر Generic را اضافه خواهیم کرد که رابطه بین مراجع را تعریف می‌کنند تا بررسی‌کننده قرض بتواند تحلیل خود را انجام دهد.

## نحو حاشیه‌نویسی طول عمر

حاشیه‌نویسی‌های طول عمر طول عمر هیچ‌یک از مراجع را تغییر نمی‌دهند. بلکه، آن‌ها روابط طول عمر چندین مرجع را نسبت به یکدیگر توصیف می‌کنند بدون اینکه روی طول عمرها تأثیر بگذارند. همان‌طور که توابع می‌توانند هر نوع را وقتی امضا یک پارامتر نوع Generic مشخص می‌کند بپذیرند، توابع می‌توانند مراجع با هر طول عمری را با مشخص کردن یک پارامتر طول عمر Generic بپذیرند.

حاشیه‌نویسی‌های طول عمر نحو کمی غیرمعمولی دارند: نام‌های پارامترهای طول عمر باید با یک آپوستروف (`'`) شروع شوند و معمولاً تماماً با حروف کوچک و بسیار کوتاه هستند، مانند نوع‌های Generic. اکثر افراد از نام `'a` برای اولین حاشیه‌نویسی طول عمر استفاده می‌کنند. حاشیه‌نویسی‌های پارامتر طول عمر را بعد از `&` یک مرجع قرار می‌دهیم، با استفاده از یک فاصله برای جدا کردن حاشیه‌نویسی از نوع مرجع.

در اینجا چند مثال آورده شده است: یک مرجع به `i32` بدون پارامتر طول عمر، یک مرجع به `i32` که یک پارامتر طول عمر به نام `'a` دارد، و یک مرجع قابل‌تغییر به `i32` که همچنین طول عمر `'a` دارد.

```rust
&i32        // یک مرجع
&'a i32     // یک مرجع با طول عمر صریح
&'a mut i32 // یک مرجع قابل‌تغییر با طول عمر صریح
```

یک حاشیه‌نویسی طول عمر به تنهایی معنای زیادی ندارد، زیرا حاشیه‌نویسی‌ها برای این هستند که به **Rust** بگویند پارامترهای طول عمر Generic چندین مرجع چگونه به یکدیگر مرتبط هستند. بیایید بررسی کنیم که حاشیه‌نویسی‌های طول عمر چگونه در زمینه تابع `longest` به یکدیگر مرتبط هستند.

## حاشیه‌نویسی‌های طول عمر در امضاهای تابع

برای استفاده از حاشیه‌نویسی‌های طول عمر در امضاهای تابع، باید پارامترهای طول عمر Generic را داخل کروشه‌ها بین نام تابع و لیست پارامترها اعلام کنیم، همان‌طور که با پارامترهای نوع Generic کردیم.

ما می‌خواهیم امضا این محدودیت را بیان کند: مرجع برگردانده‌شده تا زمانی که هر دو پارامتر معتبر باشند معتبر خواهد بود. این رابطه بین طول عمرهای پارامترها و مقدار بازگشتی است. ما طول عمر را `'a` نام‌گذاری خواهیم کرد و سپس آن را به هر مرجع اضافه می‌کنیم، همان‌طور که در **جدول 10-21** نشان داده شده است.

**فایل: src/main.rs**

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

**جدول 10-21**: تعریف تابع `longest` که مشخص می‌کند همه مراجع در امضا باید طول عمر یکسانی `'a` داشته باشند

این کد باید کامپایل شود و نتیجه‌ای که می‌خواهیم را وقتی با تابع `main` در **جدول 10-19** استفاده می‌کنیم تولید کند.

امضای تابع اکنون به **Rust** می‌گوید که برای یک طول عمر `'a`، تابع دو پارامتر می‌گیرد، که هر دو برش‌های رشته‌ای هستند که حداقل تا طول عمر `'a` عمر می‌کنند. امضای تابع همچنین به **Rust** می‌گوید که برش رشته‌ای برگردانده‌شده از تابع حداقل تا طول عمر `'a` عمر خواهد کرد. در عمل، این بدان معناست که طول عمر مرجع برگردانده‌شده توسط تابع `longest` همانند کوچک‌ترین طول عمر مقادیر ارجاع‌شده توسط آرگومان‌های تابع است. این روابط همان چیزی است که می‌خواهیم **Rust** هنگام تحلیل این کد استفاده کند.

به یاد داشته باشید، وقتی پارامترهای طول عمر را در این امضای تابع مشخص می‌کنیم، طول عمر هیچ‌یک از مقادیر پاس‌شده یا برگردانده‌شده را تغییر نمی‌دهیم. بلکه، ما مشخص می‌کنیم که بررسی‌کننده قرض باید هر مقداری را که به این محدودیت‌ها پایبند نیست رد کند. توجه داشته باشید که تابع `longest` نیازی ندارد بداند که `x` و `y` دقیقاً چقدر عمر خواهند کرد، فقط اینکه یک حوزه می‌تواند برای `'a` جایگزین شود که این امضا را برآورده کند.

هنگام حاشیه‌نویسی طول عمرها در توابع، حاشیه‌نویسی‌ها در امضای تابع قرار می‌گیرند، نه در بدنه تابع. حاشیه‌نویسی‌های طول عمر بخشی از قرارداد تابع می‌شوند، درست مانند نوع‌ها در امضا. داشتن امضاهای تابع که شامل قرارداد طول عمر هستند به این معناست که تحلیل‌هایی که کامپایلر **Rust** انجام می‌دهد می‌توانند ساده‌تر باشند. اگر مشکلی در نحوه حاشیه‌نویسی یک تابع یا نحوه فراخوانی آن وجود داشته باشد، خطاهای کامپایلر می‌توانند به بخش خاصی از کد ما و محدودیت‌ها به‌طور دقیق‌تر اشاره کنند. اگر به جای آن، کامپایلر **Rust** استنباط‌های بیشتری درباره اینکه ما چه روابطی برای طول عمرها در نظر داشتیم انجام می‌داد، ممکن بود کامپایلر فقط بتواند به استفاده‌ای از کد ما چند مرحله دورتر از علت مشکل اشاره کند.

وقتی مراجع مشخص را به `longest` پاس می‌دهیم، طول عمر مشخصی که برای `'a` جایگزین می‌شود بخشی از حوزه `x` است که با حوزه `y` هم‌پوشانی دارد. به عبارت دیگر، طول عمر Generic `'a` طول عمر مشخصی را دریافت می‌کند که برابر با کوچک‌ترین طول عمرهای `x` و `y` است. چون ما مرجع برگردانده‌شده را با همان پارامتر طول عمر `'a` حاشیه‌نویسی کرده‌ایم، مرجع برگردانده‌شده نیز برای مدت کوچک‌ترین طول عمرهای `x` و `y` معتبر خواهد بود.

بیایید ببینیم که چگونه حاشیه‌نویسی‌های طول عمر تابع `longest` را با پاس دادن مراجعی که طول عمرهای مشخص متفاوتی دارند محدود می‌کنند. **جدول 10-22** یک مثال ساده است.

**فایل: src/main.rs**

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

**جدول 10-22**: استفاده از تابع `longest` با مراجع به مقادیر `String` که طول عمرهای مشخص متفاوتی دارند

در این مثال، `string1` تا پایان حوزه بیرونی معتبر است، `string2` تا پایان حوزه درونی معتبر است، و `result` به چیزی ارجاع می‌دهد که تا پایان حوزه درونی معتبر است. این کد را اجرا کنید و خواهید دید که بررسی‌کننده قرض آن را تأیید می‌کند؛ کد کامپایل می‌شود و چاپ می‌کند: `The longest string is long string is long`.

حالا، بیایید مثالی را امتحان کنیم که نشان می‌دهد طول عمر مرجع در `result` باید کوچک‌ترین طول عمر دو آرگومان باشد. ما اعلام متغیر `result` را به خارج از حوزه درونی منتقل خواهیم کرد اما تخصیص مقدار به متغیر `result` را داخل حوزه با `string2` نگه می‌داریم. سپس `println!` که از `result` استفاده می‌کند را به خارج از حوزه درونی، بعد از پایان حوزه درونی، منتقل خواهیم کرد. کد در **جدول 10-23** کامپایل نخواهد شد.

**فایل: src/main.rs**

**این کد کامپایل نمی‌شود!**

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

**جدول 10-23**: تلاش برای استفاده از `result` بعد از اینکه `string2` از حوزه خارج شده است

وقتی سعی می‌کنیم این کد را کامپایل کنیم، خطای زیر را دریافت می‌کنیم:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

خطا نشان می‌دهد که برای اینکه `result` برای دستور `println!` معتبر باشد، `string2` باید تا پایان حوزه بیرونی معتبر باشد. **Rust** این را می‌داند زیرا ما طول عمرهای پارامترهای تابع و مقادیر بازگشتی را با استفاده از همان پارامتر طول عمر `'a` حاشیه‌نویسی کرده‌ایم.

ما به‌عنوان انسان می‌توانیم به این کد نگاه کنیم و ببینیم که `string1` طولانی‌تر از `string2` است، و بنابراین، `result` شامل مرجعی به `string1` خواهد بود. چون `string1` هنوز از حوزه خارج نشده است، مرجعی به `string1` همچنان برای دستور `println!` معتبر خواهد بود. با این حال، کامپایلر نمی‌تواند ببیند که مرجع در این مورد معتبر است. ما به **Rust** گفته‌ایم که طول عمر مرجع برگردانده‌شده توسط تابع `longest` همانند کوچک‌ترین طول عمر مراجع پاس‌شده است. بنابراین، بررسی‌کننده قرض کد در **جدول 10-23** را به‌عنوان احتمالاً دارای یک مرجع نامعتبر رد می‌کند.

سعی کنید آزمایش‌های بیشتری طراحی کنید که مقادیر و طول عمرهای مراجع پاس‌شده به تابع `longest` و نحوه استفاده از مرجع برگردانده‌شده را تغییر می‌دهند. قبل از کامپایل، فرضیه‌هایی درباره اینکه آیا آزمایش‌های شما بررسی‌کننده قرض را پشت سر می‌گذارند یا خیر بسازید؛ سپس بررسی کنید که آیا درست حدس زده‌اید یا خیر!

## تفکر در قالب طول عمر

نحوه‌ای که باید پارامترهای طول عمر را مشخص کنید به کاری که تابع شما انجام می‌دهد بستگی دارد. برای مثال، اگر پیاده‌سازی تابع `longest` را تغییر دهیم تا همیشه پارامتر اول را به‌جای طولانی‌ترین برش رشته‌ای برگرداند، نیازی به مشخص کردن طول عمر روی پارامتر `y` نخواهیم داشت. کد زیر کامپایل خواهد شد:

**فایل: src/main.rs**

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

ما یک پارامتر طول عمر `'a` برای پارامتر `x` و نوع بازگشتی مشخص کرده‌ایم، اما برای پارامتر `y` خیر، زیرا طول عمر `y` هیچ رابطه‌ای با طول عمر `x` یا مقدار بازگشتی ندارد.

وقتی مرجعی از یک تابع برمی‌گردانیم، پارامتر طول عمر برای نوع بازگشتی باید با پارامتر طول عمر یکی از پارامترها مطابقت داشته باشد. اگر مرجع برگردانده‌شده به یکی از پارامترها ارجاع ندهد، باید به مقداری ارجاع دهد که در داخل این تابع ایجاد شده است. با این حال، این یک مرجع معلق خواهد بود زیرا مقدار در پایان تابع از حوزه خارج می‌شود. این تلاش برای پیاده‌سازی تابع `longest` را در نظر بگیرید که کامپایل نخواهد شد:

**فایل: src/main.rs**

**این کد کامپایل نمی‌شود!**

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

در اینجا، اگرچه ما یک پارامتر طول عمر `'a` برای نوع بازگشتی مشخص کرده‌ایم، این پیاده‌سازی کامپایل نخواهد شد زیرا طول عمر مقدار بازگشتی اصلاً به طول عمر پارامترها مرتبط نیست. پیام خطایی که دریافت می‌کنیم به این صورت است:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

مشکل این است که `result` در پایان تابع `longest` از حوزه خارج می‌شود و پاک‌سازی می‌شود. ما همچنین سعی می‌کنیم مرجعی به `result` از تابع برگردانیم. هیچ راهی وجود ندارد که بتوانیم پارامترهای طول عمر را مشخص کنیم که مرجع معلق را تغییر دهد، و **Rust** به ما اجازه ایجاد مرجع معلق را نمی‌دهد. در این مورد، بهترین راه‌حل این است که یک نوع داده مالک‌شده را به‌جای مرجع برگردانیم تا تابع فراخواننده مسئول پاک‌سازی مقدار باشد.

در نهایت، نحو طول عمر درباره اتصال طول عمرهای پارامترها و مقادیر بازگشتی مختلف توابع است. وقتی آن‌ها متصل شوند، **Rust** اطلاعات کافی برای اجازه دادن به عملیات‌های ایمن حافظه و جلوگیری از عملیات‌هایی که اشاره‌گرهای معلق ایجاد می‌کنند یا به نحو دیگری ایمنی حافظه را نقض می‌کنند، دارد.

## حاشیه‌نویسی‌های طول عمر در تعریف‌های ساختار

تا کنون، ساختارهایی که تعریف کردیم همه نوع‌های مالک‌شده را نگه می‌داشتند. ما می‌توانیم ساختارهایی تعریف کنیم که مراجع را نگه دارند، اما در این صورت باید یک حاشیه‌نویسی طول عمر روی هر مرجع در تعریف ساختار اضافه کنیم. **جدول 10-24** یک ساختار به نام `ImportantExcerpt` دارد که یک برش رشته‌ای را نگه می‌دارد.

**فایل: src/main.rs**

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

**جدول 10-24**: یک ساختار که یک مرجع را نگه می‌دارد، نیازمند حاشیه‌نویسی طول عمر

این ساختار یک فیلد واحد `part` دارد که یک برش رشته‌ای را نگه می‌دارد، که یک مرجع است. مانند نوع‌های داده Generic، ما نام پارامتر طول عمر Generic را داخل کروشه‌ها بعد از نام ساختار اعلام می‌کنیم تا بتوانیم از پارامتر طول عمر در بدنه تعریف ساختار استفاده کنیم. این حاشیه‌نویسی به این معناست که یک نمونه از `ImportantExcerpt` نمی‌تواند از مرجعی که در فیلد `part` خود نگه می‌دارد طولانی‌تر عمر کند.

تابع `main` در اینجا یک نمونه از ساختار `ImportantExcerpt` ایجاد می‌کند که مرجعی به اولین جمله از `String` مالک‌شده توسط متغیر `novel` نگه می‌دارد. داده در `novel` قبل از ایجاد نمونه `ImportantExcerpt` وجود دارد. علاوه بر این، `novel` تا بعد از اینکه `ImportantExcerpt` از حوزه خارج شود از حوزه خارج نمی‌شود، بنابراین مرجع در نمونه `ImportantExcerpt` معتبر است.

## حذف طول عمر (Lifetime Elision)

شما آموخته‌اید که هر مرجع یک طول عمر دارد و باید پارامترهای طول عمر را برای توابع یا ساختارهایی که از مراجع استفاده می‌کنند مشخص کنید. با این حال، ما یک تابع در **جدول 4-9** داشتیم، که دوباره در **جدول 10-25** نشان داده شده است، که بدون حاشیه‌نویسی‌های طول عمر کامپایل شد.

**فایل: src/lib.rs**

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

**جدول 10-25**: تابعی که در **جدول 4-9** تعریف کردیم و بدون حاشیه‌نویسی‌های طول عمر کامپایل شد، اگرچه پارامتر و نوع بازگشتی مراجع هستند

دلیل اینکه این تابع بدون حاشیه‌نویسی‌های طول عمر کامپایل می‌شود تاریخی است: در نسخه‌های اولیه (قبل از 1.0) **Rust**، این کد کامپایل نمی‌شد زیرا هر مرجع به یک طول عمر صریح نیاز داشت. در آن زمان، امضای تابع به این صورت نوشته می‌شد:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

پس از نوشتن مقدار زیادی کد **Rust**، تیم **Rust** متوجه شد که برنامه‌نویسان **Rust** در موقعیت‌های خاصی بارها و بارها همان حاشیه‌نویسی‌های طول عمر را وارد می‌کردند. این موقعیت‌ها قابل پیش‌بینی بودند و از چند الگوی قطعی پیروی می‌کردند. توسعه‌دهندگان این الگوها را در کد کامپایلر برنامه‌ریزی کردند تا بررسی‌کننده قرض بتواند طول عمرها را در این موقعیت‌ها استنباط کند و نیازی به حاشیه‌نویسی‌های صریح نداشته باشد.

این بخش از تاریخچه **Rust** مرتبط است زیرا ممکن است الگوهای قطعی بیشتری ظاهر شوند و به کامپایلر اضافه شوند. در آینده، ممکن است به حاشیه‌نویسی‌های طول عمر کمتری نیاز باشد.

الگوهای برنامه‌ریزی‌شده در تحلیل مراجع **Rust** به نام **قوانین حذف طول عمر (lifetime elision rules)** شناخته می‌شوند. این‌ها قوانینی نیستند که برنامه‌نویسان باید دنبال کنند؛ آن‌ها مجموعه‌ای از موارد خاص هستند که کامپایلر در نظر می‌گیرد، و اگر کد شما با این موارد مطابقت داشته باشد، نیازی به نوشتن طول عمرها به‌صورت صریح ندارید.

قوانین حذف طول عمر استنباط کامل را فراهم نمی‌کنند. اگر پس از اعمال قوانین هنوز ابهامی درباره اینکه مراجع چه طول عمرهایی دارند وجود داشته باشد، کامپایلر حدس نخواهد زد که طول عمر مراجع باقی‌مانده باید چه باشد. به جای حدس زدن، کامپایلر خطایی به شما می‌دهد که می‌توانید با افزودن حاشیه‌نویسی‌های طول عمر آن را رفع کنید.

طول عمرهای روی پارامترهای تابع یا متد به نام **طول عمرهای ورودی (input lifetimes)** شناخته می‌شوند، و طول عمرهای روی مقادیر بازگشتی به نام **طول عمرهای خروجی (output lifetimes)** شناخته می‌شوند.

کامپایلر از سه قانون برای مشخص کردن طول عمرهای مراجع وقتی حاشیه‌نویسی‌های صریحی وجود ندارد استفاده می‌کند. قانون اول به طول عمرهای ورودی اعمال می‌شود، و قوانین دوم و سوم به طول عمرهای خروجی اعمال می‌شوند. اگر کامپایلر به پایان سه قانون برسد و هنوز مراجعی وجود داشته باشد که نتواند طول عمرهایشان را مشخص کند، با یک خطا متوقف خواهد شد. این قوانین برای تعریف‌های `fn` و همچنین بلاک‌های `impl` اعمال می‌شوند.

**قانون اول** این است که کامپایلر به هر پارامتری که مرجع است یک پارامتر طول عمر اختصاص می‌دهد. به عبارت دیگر، تابعی با یک پارامتر یک پارامتر طول عمر دریافت می‌کند: `fn foo<'a>(x: &'a i32)`؛ تابعی با دو پارامتر دو پارامتر طول عمر جداگانه دریافت می‌کند: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`؛ و به همین ترتیب.

**قانون دوم** این است که اگر دقیقاً یک پارامتر طول عمر ورودی وجود داشته باشد، آن طول عمر به همه پارامترهای طول عمر خروجی اختصاص می‌یابد: `fn foo<'a>(x: &'a i32) -> &'a i32`.

**قانون سوم** این است که اگر چندین پارامتر طول عمر ورودی وجود داشته باشد، اما یکی از آن‌ها `&self` یا `&mut self` باشد زیرا این یک متد است، طول عمر `self` به همه پارامترهای طول عمر خروجی اختصاص می‌یابد. این قانون سوم خواندن و نوشتن متدها را بسیار زیباتر می‌کند زیرا به نمادهای کمتری نیاز است.

بیایید وانمود کنیم که کامپایلر هستیم. ما این قوانین را اعمال خواهیم کرد تا طول عمرهای مراجع در امضای تابع `first_word` در **جدول 10-25** را مشخص کنیم. امضا بدون هیچ طول عمری مرتبط با مراجع شروع می‌شود:

```rust
fn first_word(s: &str) -> &str {
```

سپس کامپایلر قانون اول را اعمال می‌کند، که مشخص می‌کند هر پارامتر طول عمر خود را دریافت می‌کند. ما آن را طبق معمول `'a` می‌نامیم، بنابراین اکنون امضا به این صورت است:

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

قانون دوم اعمال می‌شود زیرا دقیقاً یک طول عمر ورودی وجود دارد. قانون دوم مشخص می‌کند که طول عمر تک پارامتر ورودی به طول عمر خروجی اختصاص می‌یابد، بنابراین امضا اکنون به این صورت است:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

اکنون همه مراجع در این امضای تابع طول عمر دارند، و کامپایلر می‌تواند تحلیل خود را بدون نیاز به حاشیه‌نویسی طول عمرها توسط برنامه‌نویس در این امضای تابع ادامه دهد.

بیایید مثال دیگری را بررسی کنیم، این بار با تابع `longest` که وقتی شروع به کار با آن در **جدول 10-20** کردیم هیچ پارامتر طول عمری نداشت:

```rust
fn longest(x: &str, y: &str) -> &str {
```

بیایید قانون اول را اعمال کنیم: هر پارامتر طول عمر خود را دریافت می‌کند. این بار دو پارامتر داریم به‌جای یکی، بنابراین دو طول عمر داریم:

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

می‌توانید ببینید که قانون دوم اعمال نمی‌شود زیرا بیش از یک طول عمر ورودی وجود دارد. قانون سوم هم اعمال نمی‌شود، زیرا `longest` یک تابع است نه یک متد، بنابراین هیچ‌یک از پارامترها `self` نیست. پس از بررسی همه سه قانون، هنوز مشخص نکرده‌ایم که طول عمر نوع بازگشتی چیست. به همین دلیل است که هنگام تلاش برای کامپایل کد در **جدول 10-20** خطا دریافت کردیم: کامپایلر قوانین حذف طول عمر را بررسی کرد اما هنوز نتوانست همه طول عمرهای مراجع در امضا را مشخص کند.

چون قانون سوم واقعاً فقط در امضاهای متد اعمال می‌شود، در ادامه به طول عمرها در آن زمینه نگاه خواهیم کرد تا ببینیم چرا قانون سوم به این معناست که اغلب نیازی به حاشیه‌نویسی طول عمرها در امضاهای متد نداریم.

## حاشیه‌نویسی‌های طول عمر در تعریف‌های متد

وقتی متدها را روی یک ساختار با طول عمرها پیاده‌سازی می‌کنیم، از همان نحوی استفاده می‌کنیم که برای پارامترهای نوع Generic استفاده کردیم، همان‌طور که در **جدول 10-11** نشان داده شده است. جایی که پارامترهای طول عمر را اعلام و استفاده می‌کنیم به این بستگی دارد که آیا آن‌ها به فیلدهای ساختار مرتبط هستند یا به پارامترهای متد و مقادیر بازگشتی.

نام‌های طول عمر برای فیلدهای ساختار همیشه باید بعد از کلمه‌کلیدی `impl` اعلام شوند و سپس بعد از نام ساختار استفاده شوند زیرا این طول عمرها بخشی از نوع ساختار هستند.

در امضاهای متد داخل بلاک `impl`، مراجع ممکن است به طول عمر مراجع در فیلدهای ساختار وابسته باشند، یا ممکن است مستقل باشند. علاوه بر این، قوانین حذف طول عمر اغلب باعث می‌شوند که حاشیه‌نویسی‌های طول عمر در امضاهای متد لازم نباشند. بیایید چند مثال را با استفاده از ساختار به نام `ImportantExcerpt` که در **جدول 10-24** تعریف کردیم بررسی کنیم.

ابتدا یک متد به نام `level` استفاده خواهیم کرد که تنها پارامترش مرجعی به `self` است و مقدار بازگشتی آن یک `i32` است، که به هیچ‌چیز مرجع نیست:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

اعلام پارامتر طول عمر بعد از `impl` و استفاده از آن بعد از نام نوع لازم است، اما به دلیل قانون اول حذف، نیازی به حاشیه‌نویسی طول عمر مرجع به `self` نداریم.

در اینجا مثالی است که قانون سوم حذف طول عمر اعمال می‌شود:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```

دو طول عمر ورودی وجود دارد، بنابراین **Rust** قانون اول حذف طول عمر را اعمال می‌کند و به هر دو `&self` و `announcement` طول عمرهای خودشان را می‌دهد. سپس، چون یکی از پارامترها `&self` است، نوع بازگشتی طول عمر `&self` را دریافت می‌کند، و همه طول عمرها حساب شده‌اند.

## طول عمر استاتیک

یک طول عمر خاص که باید درباره آن بحث کنیم `'static` است، که نشان می‌دهد مرجع تحت تأثیر می‌تواند برای کل مدت اجرای برنامه عمر کند. همه لفظ‌های رشته‌ای طول عمر `'static` دارند، که می‌توانیم آن را به این صورت حاشیه‌نویسی کنیم:

```rust
let s: &'static str = "I have a static lifetime.";
```

متن این رشته مستقیماً در فایل باینری برنامه ذخیره می‌شود، که همیشه در دسترس است. بنابراین، طول عمر همه لفظ‌های رشته‌ای `'static` است.

ممکن است در پیام‌های خطا پیشنهاداتی برای استفاده از طول عمر `'static` ببینید. اما قبل از مشخص کردن `'static` به‌عنوان طول عمر برای یک مرجع، فکر کنید که آیا مرجعی که دارید واقعاً کل طول عمر برنامه شما را دارد یا خیر، و آیا می‌خواهید این‌طور باشد. بیشتر اوقات، پیام خطایی که طول عمر `'static` را پیشنهاد می‌کند ناشی از تلاش برای ایجاد یک مرجع معلق یا عدم تطابق طول عمرهای موجود است. در چنین مواردی، راه‌حل این است که آن مشکلات را رفع کنید، نه اینکه طول عمر `'static` را مشخص کنید.

## پارامترهای نوع Generic، محدودیت‌های ترییت، و طول عمرها با هم

بیایید به‌صورت مختصر به نحو مشخص کردن پارامترهای نوع Generic، محدودیت‌های ترییت، و طول عمرها همه در یک تابع نگاه کنیم!

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}
```

این تابع `longest` از **جدول 10-21** است که طولانی‌ترین برش از بین دو برش رشته‌ای را برمی‌گرداند. اما اکنون یک پارامتر اضافی به نام `ann` از نوع Generic `T` دارد، که می‌تواند توسط هر نوع که ترییت `Display` را پیاده‌سازی می‌کند پر شود، همان‌طور که توسط بند `where` مشخص شده است. این پارامتر اضافی با استفاده از `{}` چاپ خواهد شد، به همین دلیل محدودیت ترییت `Display` لازم است. چون طول عمرها نوعی Generic هستند، اعلام‌های پارامتر طول عمر `'a` و پارامتر نوع Generic `T` در همان لیست داخل کروشه‌ها بعد از نام تابع قرار می‌گیرند.

## خلاصه

ما در این فصل مطالب زیادی را پوشش دادیم! حالا که درباره پارامترهای نوع Generic، ترییت‌ها و محدودیت‌های ترییت، و پارامترهای طول عمر Generic می‌دانید، آماده هستید که کدی بدون تکرار بنویسید که در موقعیت‌های مختلف کار کند. پارامترهای نوع Generic به شما اجازه می‌دهند کد را برای نوع‌های مختلف اعمال کنید. ترییت‌ها و محدودیت‌های ترییت اطمینان می‌دهند که حتی اگر نوع‌ها Generic باشند، رفتار مورد نیاز کد را خواهند داشت. شما آموختید که چگونه از حاشیه‌نویسی‌های طول عمر برای اطمینان از اینکه این کد انعطاف‌پذیر هیچ مرجع معلقی نخواهد داشت استفاده کنید. و همه این تحلیل‌ها در زمان کامپایل اتفاق می‌افتند، که روی عملکرد زمان اجرا تأثیر نمی‌گذارد!

باور کنید یا نه، هنوز چیزهای بیشتری برای یادگیری در مورد موضوعاتی که در این فصل بحث کردیم وجود دارد: فصل هجدهم درباره اشیاء ترییت بحث می‌کند، که راه دیگری برای استفاده از ترییت‌ها هستند. همچنین سناریوهای پیچیده‌تری شامل حاشیه‌نویسی‌های طول عمر وجود دارند که فقط در سناریوهای بسیار پیشرفته به آن‌ها نیاز خواهید داشت؛ برای این موارد، باید مرجع **Rust** را بخوانید. اما در ادامه، یاد خواهید گرفت که چگونه در **Rust** تست بنویسید تا مطمئن شوید کدتان همان‌طور که باید کار می‌کند.
# مدیریت خطاها

خطاها واقعیت اجتناب‌ناپذیر در توسعه نرم‌افزار هستند، بنابراین **Rust** ابزارهای متعددی برای مدیریت موقعیت‌های نامطلوب ارائه می‌دهد. در بسیاری از موارد، **Rust** از شما می‌خواهد امکان وقوع خطا را پیش‌بینی کرده و اقدامات مناسب را پیش از کامپایل کد انجام دهید. این الزام، برنامه‌های شما را مقاوم‌تر می‌کند، چرا که خطاها قبل از انتشار کد به محیط عملیاتی شناسایی و مدیریت می‌شوند!

## دسته‌بندی خطاها در Rust
**Rust** خطاها را به دو دسته اصلی تقسیم می‌کند:
1. **خطاهای بازیافتی (Recoverable Errors)**: مانند خطای «فایل یافت نشد». معمولاً فقط نیاز است مشکل به کاربر گزارش شود و عملیات تکرار گردد.
2. **خطاهای غیرقابل‌بازیابی (Unrecoverable Errors)**: نشان‌دهنده باگ‌های جدی هستند، مثل دسترسی به ایندکس خارج از محدوده آرایه. در این موارد، برنامه باید بلافاصله متوقف شود.

> نکته: بسیاری از زبان‌ها این دو نوع خطا را از هم تفکیک نمی‌کنند و از مکانیسم‌هایی مثل **استثناها (Exceptions)** برای هر دو استفاده می‌کنند. اما **Rust** مسیر متفاوتی را طی می‌کند!

## ابزارهای مدیریت خطا در Rust
- برای خطاهای **بازیافتی**: از نوع `Result<T, E>` استفاده می‌شود.
- برای خطاهای **غیرقابل‌بازیابی**: ماکرو `panic!` اجرا را متوقف می‌کند.

در این فصل، ابتدا `panic!` را بررسی می‌کنیم، سپس به مقادیر `Result<T, E>` می‌پردازیم. همچنین، معیارهای تصمیم‌گیری بین «بازیابی خطا» یا «توقف برنامه» را تحلیل خواهیم کرد.

---  
**مثال مفهومی:**
```rust
// بازیافت خطا با Result
let file = File::open("hello.txt")?; // ? خطا را منتقل می‌کند

// توقف برنامه با panic! (در صورت دسترسی به ایندکس نامعتبر)
let v = vec![1, 2, 3];
v[99]; // <- این باعث panic! می‌شود
```  

> نکته: انتخاب بین `panic!` و `Result` بستگی به این دارد که آیا خطا قابل‌پیش‌بینی و مدیریت است یا خیر.

---  
## توابع

توابع در کد Rust بسیار رایج هستند. شما قبلاً یکی از مهم‌ترین توابع زبان را دیده‌اید: تابع `main`، که نقطه ورود بسیاری از برنامه‌هاست. همچنین کلیدواژه `fn` را دیده‌اید، که به شما امکان می‌دهد توابع جدیدی تعریف کنید.

کد Rust از سبک نام‌گذاری snake_case به‌عنوان قرارداد برای نام توابع و متغیرها استفاده می‌کند، که در آن همه حروف کوچک هستند و کلمات با زیرخط از هم جدا می‌شوند. در اینجا برنامه‌ای آورده شده که شامل یک نمونه تعریف تابع است:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    println!("سلام، دنیا!");

    another_function();
}

fn another_function() {
    println!("یک تابع دیگر.");
}
```

ما یک تابع در Rust با وارد کردن `fn` و سپس نام تابع و مجموعه‌ای از پرانتزها تعریف می‌کنیم. کروشه‌ها به کامپایلر می‌گویند که بدنه تابع از کجا شروع و کجا پایان می‌یابد.

می‌توانیم هر تابعی که تعریف کرده‌ایم را با وارد کردن نام آن و سپس مجموعه‌ای از پرانتزها فراخوانی کنیم. چون `another_function` در برنامه تعریف شده است، می‌توان آن را از داخل تابع `main` فراخوانی کرد. توجه کنید که ما `another_function` را بعد از تابع `main` در کد منبع تعریف کردیم؛ می‌توانستیم آن را قبل از آن نیز تعریف کنیم. Rust اهمیتی نمی‌دهد که توابع خود را کجا تعریف می‌کنید، فقط مهم است که در محدوده‌ای تعریف شده باشند که برای فراخواننده قابل‌دیدن باشد.

بیایید یک پروژه باینری جدید به نام `functions` شروع کنیم تا توابع را بیشتر بررسی کنیم. مثال `another_function` را در `src/main.rs` قرار دهید و آن را اجرا کنید. باید خروجی زیر را ببینید:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
سلام، دنیا!
یک تابع دیگر.
```

خطوط به ترتیبی که در تابع `main` ظاهر می‌شوند اجرا می‌شوند. ابتدا پیام «سلام، دنیا!» چاپ می‌شود، سپس `another_function` فراخوانی می‌شود و پیام آن چاپ می‌شود.

### پارامترها

ما می‌توانیم توابع را طوری تعریف کنیم که پارامتر داشته باشند، که متغیرهای خاصی هستند و بخشی از امضای تابع را تشکیل می‌دهند. وقتی یک تابع پارامتر دارد، می‌توانید مقادیر مشخصی را برای آن پارامترها ارائه دهید. از نظر فنی، مقادیر مشخص آرگومان نامیده می‌شوند، اما در گفت‌وگوی روزمره، افراد معمولاً از کلمات پارامتر و آرگومان به‌صورت قابل‌تعویض برای متغیرها در تعریف تابع یا مقادیر مشخصی که هنگام فراخوانی تابع پاس داده می‌شوند استفاده می‌کنند.

در این نسخه از `another_function` یک پارامتر اضافه می‌کنیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("مقدار x برابر است با: {x}");
}
```

این برنامه را اجرا کنید؛ باید خروجی زیر را دریافت کنید:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
مقدار x برابر است با: 5
```

اعلان `another_function` یک پارامتر به نام `x` دارد. نوع `x` به‌عنوان `i32` مشخص شده است. وقتی `5` را به `another_function` پاس می‌دهیم، ماکرو `println!` عدد `5` را در جایی که جفت کروشه‌های حاوی `x` در رشته فرمت بود قرار می‌دهد.

در امضاهای تابع، باید نوع هر پارامتر را اعلان کنید. این یک تصمیم عمدی در طراحی Rust است: نیاز به حاشیه‌نویسی نوع در تعریف توابع به این معنی است که کامپایلر تقریباً هیچ‌وقت نیازی به استفاده از آن‌ها در جای دیگری از کد برای تشخیص نوع مورد نظر شما ندارد. کامپایلر همچنین می‌تواند پیام‌های خطای مفیدتری ارائه دهد اگر بداند تابع چه نوع‌هایی را انتظار دارد.

وقتی چندین پارامتر تعریف می‌کنید، اعلان‌های پارامتر را با کاما جدا کنید، مانند این:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("اندازه‌گیری برابر است با: {value}{unit_label}");
}
```

این مثال تابعی به نام `print_labeled_measurement` با دو پارامتر ایجاد می‌کند. پارامتر اول به نام `value` از نوع `i32` است. پارامتر دوم به نام `unit_label` از نوع `char` است. سپس تابع متنی را چاپ می‌کند که شامل هر دو `value` و `unit_label` است.

بیایید این کد را اجرا کنیم. برنامه فعلی در فایل `src/main.rs` پروژه `functions` خود را با مثال بالا جایگزین کنید و آن را با استفاده از `cargo run` اجرا کنید:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
اندازه‌گیری برابر است با: 5h
```

چون ما تابع را با `5` به‌عنوان مقدار برای `value` و `'h'` به‌عنوان مقدار برای `unit_label` فراخوانی کردیم، خروجی برنامه شامل این مقادیر است.

**توضیح اضافی:** استفاده از نوع‌های مختلف برای پارامترها (مانند `i32` و `char`) به شما امکان می‌دهد توابع منعطفی بسازید که داده‌های متنوعی را پردازش کنند، مانند ترکیب اعداد و کاراکترها برای نمایش خروجی‌های فرمت‌شده.

### عبارات و دستورات

بدنه توابع از مجموعه‌ای از دستورات تشکیل شده‌اند که به‌صورت اختیاری با یک عبارت پایان می‌یابند. تا کنون، توابعی که پوشش دادیم شامل یک عبارت پایانی نبودند، اما شما یک عبارت را به‌عنوان بخشی از یک دستور دیده‌اید. چون Rust یک زبان مبتنی بر عبارت است، این یک تمایز مهم برای درک است. زبان‌های دیگر این تمایز را ندارند، بنابراین بیایید بررسی کنیم که دستورات و عبارات چیستند و چگونه تفاوت‌هایشان بر بدنه توابع تأثیر می‌گذارد.

- **دستورات** دستورالعمل‌هایی هستند که عملی را انجام می‌دهند و مقداری را برنمی‌گردانند.
- **عبارات** به یک مقدار نتیجه‌ای ارزیابی می‌شوند.

بیایید چند مثال را بررسی کنیم. ما در واقع قبلاً از دستورات و عبارات استفاده کرده‌ایم. ایجاد یک متغیر و تخصیص مقدار به آن با کلیدواژه `let` یک دستور است. در لیست ۳-۱، `let y = 6;` یک دستور است.

**نام فایل:** `src/main.rs**

```rust
fn main() {
    let y = 6;
}
```

**لیست ۳-۱:** اعلان تابع `main` حاوی یک دستور

تعریف توابع نیز دستورات هستند؛ کل مثال قبلی به‌خودی‌خود یک دستور است. (همان‌طور که در ادامه خواهیم دید، فراخوانی یک تابع دستور نیست.)

دستورات مقداری را برنمی‌گردانند. بنابراین، نمی‌توانید یک دستور `let` را به متغیر دیگری تخصیص دهید، همان‌طور که کد زیر سعی می‌کند انجام دهد؛ این کار خطا ایجاد می‌کند:

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let x = (let y = 6);
}
```

وقتی این برنامه را اجرا کنید، خطایی که دریافت می‌کنید شبیه این خواهد بود:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: فقط به‌صورت مستقیم در شرایط عبارات `if` و `while` پشتیبانی می‌شود

warning: unnecessary parentheses around assigned value
 --> src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
```

دستور `let y = 6` مقداری را برنمی‌گرداند، بنابراین چیزی برای اتصال به `x` وجود ندارد. این با آنچه در زبان‌های دیگر، مانند C و Ruby، رخ می‌دهد متفاوت است، جایی که تخصیص مقدار تخصیص‌شده را برمی‌گرداند. در آن زبان‌ها، می‌توانید `x = y = 6` بنویسید و هر دو `x` و `y` مقدار `6` داشته باشند؛ این در Rust صادق نیست.

عبارات به یک مقدار ارزیابی می‌شوند و بخش عمده‌ای از باقی کدهایی که در Rust خواهید نوشت را تشکیل می‌دهند. یک عملیات ریاضی، مانند `5 + 6`، یک عبارت است که به مقدار `11` ارزیابی می‌شود. عبارات می‌توانند بخشی از دستورات باشند: در لیست ۳-۱، عدد `6` در دستور `let y = 6;` یک عبارت است که به مقدار `6` ارزیابی می‌شود. فراخوانی یک تابع یک عبارت است. فراخوانی یک ماکرو یک عبارت است. یک بلوک محدوده جدید که با کروشه‌ها ایجاد می‌شود نیز یک عبارت است، برای مثال:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("مقدار y برابر است با: {y}");
}
```

این عبارت:

```rust
{
    let x = 3;
    x + 1
}
```

یک بلوک است که در این مورد به `4` ارزیابی می‌شود. آن مقدار به‌عنوان بخشی از دستور `let` به `y` متصل می‌شود. توجه کنید که خط `x + 1` در انتها سمی‌کالن ندارد، برخلاف اکثر خطوطی که تا کنون دیده‌اید. عبارات شامل سمی‌کالن‌های پایانی نمی‌شوند. اگر به انتهای یک عبارت سمی‌کالن اضافه کنید، آن را به یک دستور تبدیل می‌کنید، و سپس مقداری را برنمی‌گرداند. این را در ذهن داشته باشید وقتی در ادامه مقادیر بازگشتی توابع و عبارات را بررسی می‌کنیم.

**توضیح اضافی:** تفاوت بین دستورات و عبارات در Rust حیاتی است، زیرا عبارات به شما امکان می‌دهند مقادیر را به‌طور مستقیم در کد خود تولید کنید، در حالی که دستورات فقط عملی را انجام می‌دهند.

### توابع با مقادیر بازگشتی

توابع می‌توانند مقادیری را به کدی که آن‌ها را فراخوانی می‌کند برگردانند. ما مقادیر بازگشتی را نام‌گذاری نمی‌کنیم، اما باید نوع آن‌ها را بعد از یک پیکان (`->`) اعلان کنیم. در Rust، مقدار بازگشتی تابع مترادف با مقدار عبارت نهایی در بلوک بدنه تابع است. می‌توانید با استفاده از کلیدواژه `return` و مشخص کردن یک مقدار، زودتر از تابع خارج شوید، اما اکثر توابع به‌صورت ضمنی آخرین عبارت را برمی‌گردانند. در اینجا یک مثال از تابعی که مقداری را برمی‌گرداند آورده شده است:

**نام فایل:** `src/main.rs`

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("مقدار x برابر است با: {x}");
}
```

در تابع `five` هیچ فراخوانی تابع، ماکرو، یا حتی دستور `let` وجود ندارد—فقط عدد `5` به‌تنهایی. این یک تابع کاملاً معتبر در Rust است. توجه کنید که نوع بازگشتی تابع نیز مشخص شده است، به‌صورت `-> i32`. این کد را اجرا کنید؛ خروجی باید شبیه این باشد:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
مقدار x برابر است با: 5
```

عدد `5` در `five` مقدار بازگشتی تابع است، به همین دلیل نوع بازگشتی `i32` است. بیایید این را با جزئیات بیشتری بررسی کنیم. دو بخش مهم وجود دارد: اول، خط `let x = five();` نشان می‌دهد که ما از مقدار بازگشتی یک تابع برای مقداردهی یک متغیر استفاده می‌کنیم. چون تابع `five` عدد `5` را برمی‌گرداند، این خط همانند خط زیر است:

```rust
let x = 5;
```

دوم، تابع `five` هیچ پارامتری ندارد و نوع مقدار بازگشتی را تعریف می‌کند، اما بدنه تابع فقط عدد `5` است بدون سمی‌کالن، زیرا این یک عبارت است که می‌خواهیم مقدار آن را برگردانیم.

بیایید یک مثال دیگر ببینیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let x = plus_one(5);

    println!("مقدار x برابر است با: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

اجرای این کد چاپ می‌کند: `مقدار x برابر است با: 6`. اما اگر یک سمی‌کالن به انتهای خط حاوی `x + 1` اضافه کنیم و آن را از یک عبارت به یک دستور تبدیل کنیم، خطا دریافت خواهیم کرد:

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let x = plus_one(5);

    println!("مقدار x برابر است با: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

کامپایل این کد خطایی تولید می‌کند، به این صورت:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
```

پیام خطای اصلی، `mismatched types`، مشکل اصلی این کد را نشان می‌دهد. تعریف تابع `plus_one` می‌گوید که یک `i32` برمی‌گرداند، اما دستورات به مقداری ارزیابی نمی‌شوند، که با `()`، نوع واحد، بیان می‌شود. بنابراین، چیزی برگردانده نمی‌شود، که با تعریف تابع در تناقض است و منجر به خطا می‌شود. در این خروجی، Rust پیامی برای کمک به رفع این مشکل ارائه می‌دهد: پیشنهاد می‌کند سمی‌کالن را حذف کنیم، که خطا را برطرف خواهد کرد.

**توضیح اضافی:** افزودن سمی‌کالن به انتهای یک عبارت آن را به یک دستور تبدیل می‌کند، که باعث می‌شود تابع به‌جای مقدار مورد انتظار، نوع واحد `()` را برگرداند. این یکی از خطاهای رایج در Rust است که با درک تفاوت بین عبارات و دستورات می‌توان از آن اجتناب کرد.

# آینده‌ها و نحو ناهمگام

عناصر کلیدی برنامه‌نویسی ناهمگام در **Rust**، آینده‌ها و کلمات کلیدی `async` و `await` **Rust** هستند.

یک **آینده** مقداری است که ممکن است حالا آماده نباشد اما در آینده آماده خواهد شد. (این مفهوم مشابه در بسیاری از زبان‌ها ظاهر می‌شود، گاهی تحت نام‌های دیگری مانند وظیفه یا وعده.) **Rust** یک صفت `Future` `***` به‌عنوان بلوک ساختمانی فراهم می‌کند تا عملیات ناهمگام مختلف بتوانند با ساختارهای داده متفاوت اما با یک رابط مشترک پیاده‌سازی شوند. در **Rust**، آینده‌ها انواعی هستند که صفت `Future` را پیاده‌سازی می‌کنند. هر آینده اطلاعات خاص خود را درباره پیشرفتی که انجام شده و اینکه "آماده" به چه معناست نگه می‌دارد.

شما می‌توانید کلمه کلیدی `async` را روی بلوک‌ها و توابع اعمال کنید تا مشخص کنید که آن‌ها می‌توانند متوقف و ادامه پیدا کنند. درون یک بلوک یا تابع `async`، می‌توانید از کلمه کلیدی `await` برای انتظار روی یک آینده استفاده کنید (یعنی منتظر بمانید تا آماده شود). فرآیند بررسی با یک آینده برای دیدن اینکه آیا مقدارش هنوز در دسترس است یا نه، **polling** نامیده می‌شود.

زبان‌های دیگر، مانند **C#** و **JavaScript**، نیز از کلمات کلیدی `async` و `await` برای برنامه‌نویسی ناهمگام استفاده می‌کنند. اگر با آن زبان‌ها آشنا هستید، ممکن است تفاوت‌های قابل توجهی در نحوه مدیریت نحو توسط **Rust** متوجه شوید. این برای دلیل خوبی است، همان‌طور که خواهیم دید!

هنگام نوشتن **Rust** ناهمگام، بیشتر اوقات از کلمات کلیدی `async` و `await` استفاده می‌کنیم. **Rust** آن‌ها را به کد معادل با استفاده از صفت `Future` کامپایل می‌کند، همان‌طور که حلقه‌های `for` را به کد معادل با استفاده از صفت `Iterator` کامپایل می‌کند. چون **Rust** صفت `Future` را فراهم می‌کند، شما همچنین می‌توانید آن را برای انواع داده خودتان وقتی نیاز دارید پیاده‌سازی کنید. بسیاری از توابعی که در طول این فصل خواهیم دید، انواعی را برمی‌گردانند که پیاده‌سازی‌های خود از `Future` را دارند. ما در انتهای فصل به تعریف صفت برمی‌گردیم و جزئیات بیشتری درباره نحوه کارکرد آن بررسی می‌کنیم، اما این جزئیات کافی است تا ما را به جلو ببرد.

این ممکن است کمی انتزاعی به نظر برسد، بنابراین بیایید اولین برنامه ناهمگام خود را بنویسیم: یک اسکرپر وب کوچک. ما دو URL را از خط فرمان دریافت خواهیم کرد، هر دو را به‌صورت همزمان واکشی خواهیم کرد، و نتیجه هر کدام که اول تمام شد را برمی‌گردانیم. این مثال مقدار زیادی نحو جدید خواهد داشت، اما نگران نباشید—ما همه چیز مورد نیاز را در حین پیش‌روی توضیح خواهیم داد.

## اولین برنامه ناهمگام ما

برای نگه داشتن تمرکز این فصل روی یادگیری ناهمگام به جای دستکاری با بخش‌های اکوسیستم، ما کریت `trpl` را ایجاد کرده‌ایم (`trpl` مخفف "The Rust Programming Language" است). این کریت تمام انواع، صفت‌ها و توابعی را که نیاز خواهید داشت، عمدتاً از کریت‌های `futures` و `tokio` دوباره صادر می‌کند. کریت `futures` یک خانه رسمی برای آزمایش **Rust** برای کد ناهمگام است، و جایی است که صفت `Future` در ابتدا طراحی شده است. **Tokio** پرکاربردترین زمان‌اجرا ناهمگام در **Rust** امروز است، به‌ویژه برای برنامه‌های وب. زمان‌اجراهای عالی دیگری وجود دارند، و ممکن است برای اهداف شما مناسب‌تر باشند. ما از کریت `tokio` در پشت صحنه برای `trpl` استفاده می‌کنیم زیرا خوب تست‌شده و به طور گسترده استفاده می‌شود.

در برخی موارد، `trpl` همچنین نام‌ها را تغییر می‌دهد یا APIهای اصلی را می‌پوشاند تا شما را روی جزئیات مرتبط با این فصل متمرکز نگه دارد. اگر بخواهید بفهمید کریت چه کاری انجام می‌دهد، ما شما را تشویق می‌کنیم که کد منبع آن را بررسی کنید. شما خواهید توانست ببینید که هر دوباره‌صادرات از کدام کریت می‌آید، و ما نظرات گسترده‌ای گذاشته‌ایم که توضیح می‌دهند کریت چه کاری انجام می‌دهد.

یک پروژه باینری جدید به نام `hello-async` ایجاد کنید و کریت `trpl` را به‌عنوان وابستگی اضافه کنید:

```bash
$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
```

حالا می‌توانیم از قطعات مختلف ارائه‌شده توسط `trpl` برای نوشتن اولین برنامه ناهمگام خود استفاده کنیم. ما یک ابزار خط فرمان کوچک خواهیم ساخت که دو صفحه وب را واکشی می‌کند، عنصر `<title>` را از هر کدام بیرون می‌کشد، و عنوان صفحه‌ای که کل فرآیند را اول تمام می‌کند را چاپ می‌کند.

## تعریف تابع `page_title`

بیایید با نوشتن تابعی شروع کنیم که یک URL صفحه را به‌عنوان پارامتر دریافت می‌کند، درخواستی به آن ارسال می‌کند، و متن عنصر `<title>` را برمی‌گرداند (به **فهرست کد 17-1** نگاه کنید).

**فایل: src/main.rs**

```rust
use trpl::Html;

async fn page_title(url: &str) -> Option<String> {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}
```

**فهرست کد 17-1**: تعریف یک تابع ناهمگام برای گرفتن عنصر عنوان از یک صفحه HTML

ابتدا، تابعی به نام `page_title` تعریف می‌کنیم و آن را با کلمه کلیدی `async` علامت‌گذاری می‌کنیم. سپس از تابع `trpl::get` برای واکشی هر URL که پاس داده شده استفاده می‌کنیم و کلمه کلیدی `await` را برای انتظار روی پاسخ اضافه می‌کنیم. برای گرفتن متن پاسخ، متد `text` آن را فراخوانی می‌کنیم و دوباره آن را با کلمه کلیدی `await` انتظار می‌کنیم. هر دوی این مراحل ناهمگام هستند. برای تابع `get`، باید منتظر بمانیم تا سرور اولین بخش از پاسخ خود را ارسال کند، که شامل سربرگ‌های HTTP، کوکی‌ها و غیره است و می‌تواند جدا از بدنه پاسخ ارسال شود. به‌ویژه اگر بدنه بسیار بزرگ باشد، می‌تواند مدتی طول بکشد تا همه آن برسد. چون باید منتظر بمانیم تا تمام پاسخ برسد، متد `text` نیز ناهمگام است.

**توجه**: این متفاوت از رفتاری است که هنگام استفاده از `thread::spawn` در بخش "ایجاد یک ریسمان جدید با `spawn`" در فصل شانزدهم دیدیم، جایی که بسته‌بندی‌ای که به ریسمان دیگری پاس دادیم بلافاصله شروع به اجرا کرد. همچنین متفاوت از نحوه برخورد بسیاری از زبان‌های دیگر با ناهمگام است. اما برای **Rust** مهم است تا تضمین‌های عملکرد خود را ارائه دهد، همان‌طور که با تکرارسازها است.

هنگامی که `response_text` را داریم، می‌توانیم آن را به یک نمونه از نوع `Html` با استفاده از `Html::parse` تجزیه کنیم. به جای یک رشته خام، حالا یک نوع داده داریم که می‌توانیم از آن برای کار با HTML به‌عنوان یک ساختار داده غنی‌تر استفاده کنیم. به‌ویژه، می‌توانیم از متد `select_first` برای یافتن اولین نمونه از یک انتخاب‌گر CSS داده‌شده استفاده کنیم. با پاس دادن رشته `"title"`، اولین عنصر `<title>` در سند را دریافت خواهیم کرد، اگر وجود داشته باشد. چون ممکن است هیچ عنصر مطابق وجود نداشته باشد، `select_first` یک `Option<ElementRef>` برمی‌گرداند. در نهایت، از متد `Option::map` استفاده می‌کنیم، که به ما امکان می‌دهد با آیتم در `Option` اگر موجود باشد کار کنیم، و اگر نباشد هیچ کاری انجام ندهیم. (ما همچنین می‌توانیم از یک عبارت `match` اینجا استفاده کنیم، اما `map` ایدئوماتیک‌تر است.) در بدنه تابعی که به `map` ارائه می‌دهیم، `inner_html` را روی `title` فراخوانی می‌کنیم تا محتوای آن را دریافت کنیم، که یک `String` است. وقتی همه چیز تمام شد، یک `Option<String>` داریم.

توجه کنید که کلمه کلیدی `await` در **Rust** پس از عبارتی که انتظار می‌کنید قرار می‌گیرد، نه قبل از آن. یعنی، یک کلمه کلیدی پس‌وندی است. این ممکن است با آنچه اگر با ناهمگام در زبان‌های دیگر آشنا هستید متفاوت باشد، اما در **Rust** زنجیره‌های متدها را بسیار زیباتر می‌کند. در نتیجه، می‌توانیم بدنه `page_title` را تغییر دهیم تا فراخوانی‌های تابع `trpl::get` و `text` را با `await` بین آن‌ها زنجیره کنیم، همان‌طور که در **فهرست کد 17-2** نشان داده شده است.

**فایل: src/main.rs**

```rust
    let response_text = trpl::get(url).await.text().await;
```

**فهرست کد 17-2**: زنجیره کردن با کلمه کلیدی `await`

با این کار، اولین تابع ناهمگام خود را با موفقیت نوشته‌ایم! قبل از اینکه مقداری کد در `main` اضافه کنیم تا آن را فراخوانی کنیم، کمی بیشتر درباره آنچه نوشته‌ایم صحبت کنیم.

وقتی **Rust** یک بلوک علامت‌گذاری‌شده با کلمه کلیدی `async` را می‌بیند، آن را به یک نوع داده ناشناس منحصربه‌فرد که صفت `Future` را پیاده‌سازی می‌کند کامپایل می‌کند. وقتی **Rust** یک تابع علامت‌گذاری‌شده با `async` را می‌بیند، آن را به یک تابع غیرناهمگام کامپایل می‌کند که بدنه‌اش یک بلوک `async` است. نوع بازگشتی یک تابع `async` نوع ناشناس داده‌ای است که کامپایلر برای آن بلوک `async` ایجاد می‌کند.

بنابراین، نوشتن `async fn` معادل نوشتن تابعی است که آینده‌ای از نوع بازگشتی را برمی‌گرداند. برای کامپایلر، تعریف تابعی مانند `async fn page_title` در **فهرست کد 17-1** تقریباً معادل یک تابع غیرناهمگام تعریف‌شده مانند این است:

```rust
use std::future::Future;
use trpl::Html;

fn page_title(url: &str) -> impl Future<Output = Option<String>> {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
```

بیایید هر بخش از نسخه تبدیل‌شده را بررسی کنیم:

- از نحو `impl Trait` استفاده می‌کند که در بخش "صفات به‌عنوان پارامترها" در فصل دهم بحث کردیم.
- مقدار برگردانده‌شده صفت `Future` را با یک نوع مرتبط `Output` پیاده‌سازی می‌کند. توجه کنید که نوع `Output` برابر با `Option<String>` است، که همان نوع بازگشتی اصلی از نسخه `async fn` از `page_title` است.
- تمام کد فراخوانی‌شده در بدنه تابع اصلی در یک بلوک `async move` پیچیده شده است. به یاد بیاورید که بلوک‌ها عبارات هستند. کل این بلوک عبارتی است که از تابع برگردانده می‌شود.
- این بلوک `async` یک مقدار با نوع `Option<String>` تولید می‌کند، همان‌طور که توصیف شد. آن مقدار با نوع `Output` در نوع بازگشتی مطابقت دارد. این درست مانند بلوک‌های دیگر است که دیده‌اید.
- بدنه تابع جدید یک بلوک `async move` است به دلیل نحوه استفاده از پارامتر `url`. (ما بعداً در فصل درباره `async` در مقابل `async move` بیشتر صحبت خواهیم کرد.)

حالا می‌توانیم `page_title` را در `main` فراخوانی کنیم.

## اجرای یک تابع ناهمگام با یک زمان‌اجرا

برای شروع، عنوان یک صفحه واحد را دریافت خواهیم کرد، که در **فهرست کد 17-3** نشان داده شده است. متأسفانه، این کد هنوز کامپایل نمی‌شود.

**فایل: src/main.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
async fn main() {
    let args: Vec<String> = std::env::args().collect();
    let url = &args[1];
    match page_title(url).await {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
}
```

**فهرست کد 17-3**: فراخوانی تابع `page_title` از `main` با یک آرگومان ارائه‌شده توسط کاربر

ما از همان الگویی که برای دریافت آرگومان‌های خط فرمان در بخش "پذیرش آرگومان‌های خط فرمان" در فصل دوازدهم استفاده کردیم، پیروی می‌کنیم. سپس آرگومان URL را به `page_title` پاس می‌دهیم و نتیجه آینده را انتظار می‌کنیم. چون مقدار تولیدشده توسط آینده یک `Option<String>` است، از یک عبارت `match` استفاده می‌کنیم تا پیام‌های مختلفی چاپ کنیم تا حساب کنیم آیا صفحه عنوانی داشت یا نه.

تنها جایی که می‌توانیم از کلمه کلیدی `await` استفاده کنیم در توابع یا بلوک‌های `async` است، و **Rust** به ما اجازه نمی‌دهد تابع خاص `main` را به‌عنوان `async` علامت‌گذاری کنیم.

```
error[E0752]: `main` function is not allowed to be `async`
 --> src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
```

دلیل اینکه `main` نمی‌تواند به‌عنوان `async` علامت‌گذاری شود این است که کد ناهمگام نیاز به یک زمان‌اجرا دارد: یک کریت **Rust** که جزئیات اجرای کد ناهمگام را مدیریت می‌کند. تابع `main` یک برنامه می‌تواند یک زمان‌اجرا را مقداردهی اولیه کند، اما خودش یک زمان‌اجرا نیست. (ما کمی بعد بیشتر درباره اینکه چرا اینطور است خواهیم دید.) هر برنامه **Rust** که کد ناهمگام اجرا می‌کند حداقل یک مکان دارد که یک زمان‌اجرا که آینده‌ها را اجرا می‌کند تنظیم می‌کند.

در اینجا، و در طول بقیه این فصل، از تابع `block_on` از کریت `trpl` استفاده خواهیم کرد، که یک آینده را به‌عنوان آرگومان می‌گیرد و ریسمان کنونی را تا زمانی که این آینده به پایان برسد بلاک می‌کند. در پشت صحنه، فراخوانی `block_on` یک زمان‌اجرا را با استفاده از کریت `tokio` تنظیم می‌کند که برای اجرای آینده پاس‌داده‌شده استفاده می‌شود (رفتار `block_on` از کریت `trpl` مشابه تابع‌های `block_on` از دیگر کریت‌های زمان‌اجرا است). وقتی آینده کامل شود، `block_on` هر مقداری که آینده تولید کرده را برمی‌گرداند.

ما می‌توانستیم آینده برگردانده‌شده توسط `page_title` را مستقیماً به `block_on` پاس دهیم و، وقتی کامل شد، می‌توانستیم روی `Option<String>` حاصل `match` کنیم همان‌طور که سعی کردیم در **فهرست کد 17-3** انجام دهیم. با این حال، برای بیشتر مثال‌های این فصل (و بیشتر کد ناهمگام در جهان واقعی)، ما بیش از فقط یک فراخوانی تابع ناهمگام انجام خواهیم داد، بنابراین در عوض یک بلوک `async` پاس می‌دهیم و به‌صورت صریح نتیجه فراخوانی `page_title` را انتظار می‌کنیم، همان‌طور که در **فهرست کد 17-4** نشان داده شده است.

**فایل: src/main.rs**

```rust
fn main() {
    let args: Vec<String> = std::env::args().collect();

    trpl::block_on(async {
        let url = &args[1];
        match page_title(url).await {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
    })
}
```

**فهرست کد 17-4**: انتظار روی یک بلوک ناهمگام با `trpl::block_on`

وقتی این کد را اجرا می‌کنیم، رفتاری را که در ابتدا انتظار داشتیم دریافت می‌کنیم:

```bash
$ cargo run -- "https://www.rust-lang.org"
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
```

وای—بالاخره مقداری کد ناهمگام کارآمد داریم! اما قبل از اینکه کد برای مسابقه دادن دو سایت در برابر یکدیگر اضافه کنیم، کمی به عقب برگردیم و درباره نحوه کار آینده‌ها صحبت کنیم.

هر آینده—یعنی هر جایی که کد از کلمه کلیدی `await` استفاده می‌کند—نشان‌دهنده جایی است که کنترل به زمان‌اجرا برگردانده می‌شود. برای ساختن این کار، **Rust** باید حالت درگیر در بلوک ناهمگام را ردیابی کند تا زمان‌اجرا بتواند مقداری کار دیگر را شروع کند و سپس وقتی آماده شد دوباره برگردد تا اولین را پیش ببرد. این یک ماشین حالت نامرئی است، گویی یک شمارشگر نوشته‌اید تا حالت فعلی را در هر نقطه انتظار ذخیره کنید:

```rust
enum PageTitleFuture<'a> {
    Initial { url: &'a str },
    GetAwaitPoint { url: &'a str },
    TextAwaitPoint { response: trpl::Response },
}
```

نوشتن کد برای انتقال بین هر حالت به‌صورت دستی خسته‌کننده و مستعد خطا خواهد بود، به‌ویژه وقتی نیاز به افزودن عملکرد بیشتر و حالت‌های بیشتر به کد بعداً دارید. خوشبختانه، کامپایلر **Rust** ساختارهای داده ماشین حالت را برای کد ناهمگام به‌صورت خودکار ایجاد و مدیریت می‌کند. قوانین قرض‌گیری و مالکیت معمولی اطراف ساختارهای داده همچنان اعمال می‌شوند، و خوشبختانه، کامپایلر همچنین بررسی آن‌ها را برای ما مدیریت می‌کند و پیام‌های خطای مفیدی ارائه می‌دهد. ما بعداً در فصل چند تا از آن‌ها را بررسی خواهیم کرد.

در نهایت، چیزی باید این ماشین حالت را اجرا کند، و آن چیز یک زمان‌اجرا است. (این دلیل است که ممکن است هنگام جستجو درباره زمان‌اجراها به اشاره‌هایی به **executorها** برخورد کنید: یک executor بخشی از یک زمان‌اجرا است که مسئول اجرای کد ناهمگام است.)

هر برنامه **Rust** که کد ناهمگام اجرا می‌کند حداقل یک مکان دارد که یک زمان‌اجرا که آینده‌ها را اجرا می‌کند تنظیم می‌کند. حالا می‌توانید ببینید چرا کامپایلر ما را از ساختن خود `main` به‌عنوان یک تابع ناهمگام در **فهرست کد 17-3** منع کرد. اگر `main` یک تابع ناهمگام بود، چیز دیگری نیاز داشت تا ماشین حالت را برای هر آینده‌ای که `main` برمی‌گرداند مدیریت کند، اما `main` نقطه شروع برنامه است! در عوض، ما تابع `trpl::block_on` را در `main` فراخوانی کردیم تا یک زمان‌اجرا تنظیم کنیم و آینده برگردانده‌شده توسط بلوک ناهمگام را تا پایان اجرا کنیم.

**توجه**: برخی زمان‌اجراها ماکروهایی ارائه می‌دهند تا بتوانید یک تابع `main` ناهمگام بنویسید. آن ماکروها `async fn main() { ... }` را به یک `fn main` معمولی بازنویسی می‌کنند، که همان کاری را انجام می‌دهد که ما به‌صورت دستی در **فهرست کد 17-4** انجام دادیم: تابعی را فراخوانی می‌کند که یک آینده را مانند `trpl::block_on` به پایان اجرا می‌کند.

حالا این قطعات را کنار هم گذاشته‌ایم و می‌بینیم چگونه می‌توانیم کد هم‌زمان بنویسیم.

## مسابقه دادن دو URL در برابر یکدیگر به‌صورت هم‌زمان

در **فهرست کد 17-5**، ما `page_title` را با دو URL مختلف که از خط فرمان پاس داده شده فراخوانی می‌کنیم و آن‌ها را با انتخاب هر آینده‌ای که اول تمام می‌شود مسابقه می‌دهیم.

**فایل: src/main.rs**

```rust
use trpl::{Either, Html};

fn main() {
    let args: Vec<String> = std::env::args().collect();

    trpl::block_on(async {
        let title_fut_1 = page_title(&args[1]);
        let title_fut_2 = page_title(&args[2]);

        let (url, maybe_title) =
            match trpl::select(title_fut_1, title_fut_2).await {
                Either::Left(left) => left,
                Either::Right(right) => right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) => println!("Its page title was: '{title}'"),
            None => println!("It had no title."),
        }
    })
}

async fn page_title(url: &str) -> (&str, Option<String>) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}
```

**فهرست کد 17-5**: فراخوانی `page_title` برای دو URL برای دیدن اینکه کدام اول برمی‌گردد

ما با فراخوانی `page_title` برای هر یک از URLهای ارائه‌شده توسط کاربر شروع می‌کنیم. آینده‌های حاصل را به‌عنوان `title_fut_1` و `title_fut_2` ذخیره می‌کنیم. به یاد بیاورید، این آینده‌ها هنوز هیچ کاری نمی‌کنند، زیرا آینده‌ها تنبل هستند و ما هنوز آن‌ها را انتظار نکرده‌ایم. سپس آینده‌ها را به `trpl::select` پاس می‌دهیم، که مقداری را برمی‌گرداند که نشان می‌دهد کدام یک از آینده‌های پاس‌داده‌شده به آن اول تمام می‌شود.

**توجه**: در پشت صحنه، `trpl::select` روی یک تابع `select` کلی‌تر که در کریت `futures` تعریف شده ساخته شده است. تابع `select` از کریت `futures` می‌تواند کارهای زیادی انجام دهد که تابع `trpl::select` نمی‌تواند، اما همچنین پیچیدگی اضافی دارد که فعلاً می‌توانیم از آن صرف‌نظر کنیم.

هر آینده‌ای می‌تواند به‌طور قانونی "برنده" شود، بنابراین بازگشت یک `Result` منطقی نیست. در عوض، `trpl::select` نوعی را که قبلاً ندیده‌ایم برمی‌گرداند، یعنی `trpl::Either`. نوع `Either` تا حدی شبیه به `Result` است به این معنا که دو مورد دارد. برخلاف `Result`، هیچ مفهوم موفقیت یا شکست در `Either` وجود ندارد. در عوض، از `Left` و `Right` برای نشان دادن "یکی یا دیگری" استفاده می‌کند:

```rust
enum Either<A, B> {
    Left(A),
    Right(B),
}
```

تابع `select` اگر آرگومان اول برنده شود، `Left` را با خروجی آن آینده برمی‌گرداند، و اگر آن یکی برنده شود، `Right` را با خروجی آرگومان دوم آینده برمی‌گرداند. این با ترتیب ظاهر شدن آرگومان‌ها هنگام فراخوانی تابع مطابقت دارد: آرگومان اول سمت چپ آرگومان دوم است.

ما همچنین `page_title` را به‌روزرسانی می‌کنیم تا همان URL پاس‌داده‌شده را برگرداند. به این ترتیب، اگر صفحه‌ای که اول برمی‌گردد عنوانی نداشته باشد که بتوانیم حل کنیم، همچنان می‌توانیم یک پیام معنادار چاپ کنیم. با اطلاعات موجود، با به‌روزرسانی خروجی `println!` خود برای نشان دادن هم اینکه کدام URL اول تمام شد و هم اینکه عنوان صفحه وب در آن URL چه بود (اگر وجود داشته باشد)، به پایان می‌رسیم.

حالا یک اسکرپر وب کوچک کارآمد ساخته‌اید! چند URL انتخاب کنید و ابزار خط فرمان را اجرا کنید. ممکن است کشف کنید که برخی سایت‌ها همیشه سریع‌تر از دیگران هستند، در حالی که در موارد دیگر سایت سریع‌تر از اجرا به اجرا تغییر می‌کند. مهم‌تر اینکه، مبانی کار با آینده‌ها را آموخته‌اید، بنابراین حالا می‌توانیم عمیق‌تر به آنچه می‌توانیم با `async` انجام دهیم بپردازیم.

هر نقطه انتظار—یعنی هر جایی که کد از کلمه کلیدی `await` استفاده می‌کند—نشان‌دهنده جایی است که کنترل به زمان‌اجرا برگردانده می‌شود. برای ساختن این کار، **Rust** باید حالت درگیر در بلوک ناهمگام را ردیابی کند تا زمان‌اجرا بتواند مقداری کار دیگر را شروع کند و سپس وقتی آماده شد دوباره برگردد تا اولین را پیش ببرد. این یک ماشین حالت نامرئی است، گویی یک شمارشگر نوشته‌اید تا حالت فعلی را در هر نقطه انتظار ذخیره کنید!

نوشتن کد برای انتقال بین هر حالت به‌صورت دستی خسته‌کننده و مستعد خطا خواهد بود، به‌ویژه وقتی نیاز به افزودن عملکرد بیشتر و حالت‌های بیشتر به کد بعداً دارید. خوشبختانه، کامپایلر **Rust** ساختارهای داده ماشین حالت را برای کد ناهمگام به‌صورت خودکار ایجاد و مدیریت می‌کند. قوانین قرض‌گیری و مالکیت معمولی اطراف ساختارهای داده همچنان اعمال می‌شوند، و خوشبختانه، کامپایلر همچنین بررسی آن‌ها را برای ما مدیریت می‌کند و پیام‌های خطای مفیدی ارائه می‌دهد. ما بعداً در فصل چند تا از آن‌ها را بررسی خواهیم کرد.

در نهایت، چیزی باید این ماشین حالت را اجرا کند، و آن چیز یک زمان‌اجرا است. (این دلیل است که ممکن است هنگام جستجو درباره زمان‌اجراها به اشاره‌هایی به **executorها** برخورد کنید: یک executor بخشی از یک زمان‌اجرا است که مسئول اجرای کد ناهمگام است.)

هر برنامه **Rust** که کد ناهمگام اجرا می‌کند حداقل یک مکان دارد که یک زمان‌اجرا که آینده‌ها را اجرا می‌کند تنظیم می‌کند. حالا می‌توانید ببینید چرا کامپایلر ما را از ساختن خود `main` به‌عنوان یک تابع ناهمگام در **فهرست کد 17-3** منع کرد. اگر `main` یک تابع ناهمگام بود، چیز دیگری نیاز داشت تا ماشین حالت را برای هر آینده‌ای که `main` برمی‌گرداند مدیریت کند، اما `main` نقطه شروع برنامه است! در عوض، ما تابع `trpl::block_on` را در `main` فراخوانی کردیم تا یک زمان‌اجرا تنظیم کنیم و آینده برگردانده‌شده توسط بلوک ناهمگام را تا پایان اجرا کنیم.

حالا این قطعات را کنار هم گذاشته‌ایم و می‌بینیم چگونه می‌توانیم کد هم‌زمان بنویسیم.
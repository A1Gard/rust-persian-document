# همه مکان‌هایی که می‌توان از الگوها استفاده کرد

الگوها در چندین مکان در Rust ظاهر می‌شوند، و شما بدون اینکه متوجه باشید، از آن‌ها زیاد استفاده کرده‌اید! این بخش تمام مکان‌هایی که الگوها در آن‌ها معتبر هستند را بحث می‌کند.

## بازوهای match

همان‌طور که در فصل ششم بحث کردیم، از الگوها در بازوهای عبارت‌های `match` استفاده می‌کنیم. به‌طور رسمی، عبارت‌های `match` به‌عنوان کلمه کلیدی `match`، یک مقدار برای تطبیق، و یک یا چند بازوی تطبیق تعریف می‌شوند که شامل یک الگو و یک عبارت برای اجرا در صورتی که مقدار با الگوی آن بازو مطابقت داشته باشد، به این شکل:

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

برای مثال، در اینجا عبارت `match` از فهرست کد 6-5 آمده است که روی یک مقدار `Option<i32>` در متغیر `x` تطبیق می‌دهد:

```rust
match x {
    None => None,
    Some(i) => Some(i + 1),
}
```

الگوهای این عبارت `match`، `None` و `Some(i)` هستند که در سمت چپ هر فلش قرار دارند.

یکی از الزامات عبارت‌های `match` این است که باید جامع باشند، به این معنا که تمام احتمالات برای مقدار در عبارت `match` باید در نظر گرفته شوند. یکی از راه‌های اطمینان از پوشش همه احتمالات، داشتن یک الگوی همه‌گیر (catchall) برای بازوی آخر است: برای مثال، یک نام متغیر که با هر مقداری مطابقت دارد، هرگز شکست نمی‌خورد و بنابراین همه موارد باقی‌مانده را پوشش می‌دهد.

الگوی خاص `_` با هر چیزی مطابقت دارد، اما هرگز به یک متغیر متصل نمی‌شود، بنابراین اغلب در بازوی آخر `match` استفاده می‌شود. الگوی `_` می‌تواند مفید باشد وقتی می‌خواهید هر مقداری که مشخص نشده را نادیده بگیرید. ما الگوی `_` را با جزئیات بیشتر در بخش «نادیده گرفتن مقادیر در یک الگو» بعداً در این فصل پوشش خواهیم داد.

## عبارت‌های شرطی if let

در فصل ششم، بحث کردیم که چگونه از عبارت‌های `if let` عمدتاً به‌عنوان روشی کوتاه‌تر برای نوشتن معادل یک `match` که فقط یک مورد را تطبیق می‌دهد استفاده کنیم. به‌صورت اختیاری، `if let` می‌تواند یک `else` متناظر داشته باشد که شامل کدی برای اجرا در صورتی است که الگو در `if let` مطابقت نداشته باشد.

فهرست کد 19-1 نشان می‌دهد که همچنین می‌توان `if let`، `else if`، و `else if let` را با هم ترکیب کرد. انجام این کار انعطاف‌پذیری بیشتری نسبت به یک عبارت `match` به ما می‌دهد که در آن فقط می‌توانیم یک مقدار را با الگوها مقایسه کنیم. همچنین، Rust نیازی ندارد که شرایط در مجموعه‌ای از بازوهای `if let`، `else if`، `else if let` به یکدیگر مرتبط باشند.

کد در فهرست کد 19-1 تعیین می‌کند که رنگ پس‌زمینه شما بر اساس مجموعه‌ای از بررسی‌ها برای چندین شرط چه باشد. برای این مثال، متغیرهایی با مقادیر سخت‌کدشده ایجاد کرده‌ایم که یک برنامه واقعی ممکن است از ورودی کاربر دریافت کند.

**فایل: src/main.rs**

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("استفاده از رنگ مورد علاقه شما، {color}، به‌عنوان پس‌زمینه"); // Using your favorite color, {color}, as the background
    } else if is_tuesday {
        println!("سه‌شنبه روز سبز است!"); // Tuesday is green day!
    } else if let Ok(age) = age {
        if age > 30 {
            println!("استفاده از بنفش به‌عنوان رنگ پس‌زمینه"); // Using purple as the background color
        } else {
            println!("استفاده از نارنجی به‌عنوان رنگ پس‌زمینه"); // Using orange as the background color
        }
    } else {
        println!("استفاده از آبی به‌عنوان رنگ پس‌زمینه"); // Using blue as the background color
    }
}
```

**فهرست کد 19-1: ترکیب if let، else if، else if let، و else**

اگر کاربر رنگ مورد علاقه‌ای مشخص کند، آن رنگ به‌عنوان پس‌زمینه استفاده می‌شود. اگر رنگ مورد علاقه‌ای مشخص نشده باشد و امروز سه‌شنبه باشد، رنگ پس‌زمینه سبز است. در غیر این صورت، اگر کاربر سن خود را به‌عنوان یک رشته مشخص کند و ما بتوانیم آن را با موفقیت به یک عدد تجزیه کنیم، رنگ یا بنفش است یا نارنجی، بسته به مقدار عدد. اگر هیچ‌کدام از این شرایط اعمال نشود، رنگ پس‌زمینه آبی است.

این ساختار شرطی به ما امکان پشتیبانی از نیازهای پیچیده را می‌دهد. با مقادیر سخت‌کدشده‌ای که اینجا داریم، این مثال «استفاده از بنفش به‌عنوان رنگ پس‌زمینه» را چاپ خواهد کرد.

می‌توانید ببینید که `if let` همچنین می‌تواند متغیرهای جدیدی معرفی کند که متغیرهای موجود را به همان روشی که بازوهای `match` می‌توانند سایه بزنند: خط `if let Ok(age) = age` یک متغیر جدید `age` معرفی می‌کند که شامل مقدار داخل گونه `Ok` است و متغیر `age` موجود را سایه می‌زند. این به این معناست که باید شرط `if age > 30` را در آن بلوک قرار دهیم: نمی‌توانیم این دو شرط را به `if let Ok(age) = age && age > 30` ترکیب کنیم. متغیر جدید `age` که می‌خواهیم با 30 مقایسه کنیم تا زمانی که اسکوپ جدید با کروشه شروع نشود معتبر نیست.

نقطه ضعف استفاده از عبارت‌های `if let` این است که کامپایلر برای جامعیت بررسی نمی‌کند، در حالی که با عبارت‌های `match` این کار را می‌کند. اگر بلوک `else` آخر را حذف کنیم و بنابراین برخی موارد را مدیریت نکنیم، کامپایلر ما را از اشکال منطقی احتمالی آگاه نخواهد کرد.

## حلقه‌های شرطی while let

مشابه ساختار `if let`، حلقه شرطی `while let` به یک حلقه `while` اجازه می‌دهد تا زمانی که یک الگو همچنان مطابقت دارد اجرا شود. در فهرست کد 19-2 یک حلقه `while let` را نشان می‌دهیم که منتظر پیام‌هایی است که بین رسیمان‌ها ارسال می‌شوند، اما در این مورد به‌جای یک `Option`، یک `Result` را بررسی می‌کند.

```rust
let (tx, rx) = std::sync::mpsc::channel();
std::thread::spawn(move || {
    for val in [1, 2, 3] {
        tx.send(val).unwrap();
    }
});

while let Ok(value) = rx.recv() {
    println!("{value}");
}
```

**فهرست کد 19-2: استفاده از یک حلقه while let برای چاپ مقادیر تا زمانی که rx.recv() مقدار Ok را برمی‌گرداند**

این مثال 1، 2، و سپس 3 را چاپ می‌کند. متد `recv` اولین پیام را از سمت گیرنده کانال خارج می‌کند و یک `Ok(value)` برمی‌گرداند. وقتی در فصل شانزدهم برای اولین بار `recv` را دیدیم، خطا را مستقیماً باز کردیم یا با آن به‌عنوان یک تکرارکننده با استفاده از یک حلقه `for` تعامل کردیم. اما همان‌طور که فهرست کد 19-2 نشان می‌دهد، می‌توانیم از `while let` نیز استفاده کنیم، زیرا متد `recv` هر بار که پیامی می‌رسد `Ok` را برمی‌گرداند، تا زمانی که فرستنده وجود داشته باشد، و سپس یک `Err` تولید می‌کند وقتی سمت فرستنده قطع شود.

## حلقه‌های for

در یک حلقه `for`، مقداری که مستقیماً بعد از کلمه کلیدی `for` می‌آید یک الگو است. برای مثال، در `for x in y`، `x` الگو است. فهرست کد 19-3 نشان می‌دهد چگونه از یک الگو در یک حلقه `for` برای تجزیه (destructure) یا تفکیک یک تاپل به‌عنوان بخشی از حلقه `for` استفاده کنیم.

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{value} در شاخص {index} است"); // {value} is at index {index}
}
```

**فهرست کد 19-3: استفاده از یک الگو در یک حلقه for برای تجزیه یک تاپل**

کد در فهرست کد 19-3 خروجی زیر را چاپ خواهد کرد:

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a در شاخص 0 است
b در شاخص 1 است
c در شاخص 2 است
```

ما یک تکرارکننده را با استفاده از متد `enumerate` تطبیق می‌دهیم تا یک مقدار و شاخص آن مقدار را تولید کند، که در یک تاپل قرار می‌گیرند. اولین مقدار تولیدشده تاپل `(0, 'a')` است. وقتی این مقدار با الگوی `(index, value)` تطبیق داده می‌شود، `index` برابر 0 و `value` برابر 'a' خواهد بود، که اولین خط خروجی را چاپ می‌کند.

## عبارت‌های let

قبل از این فصل، فقط به‌صورت صریح درباره استفاده از الگوها با `match` و `if let` بحث کرده بودیم، اما در واقع، ما در مکان‌های دیگری نیز از الگوها استفاده کرده‌ایم، از جمله در عبارت‌های `let`. برای مثال، این تخصیص متغیر ساده با `let` را در نظر بگیرید:

```rust
let x = 5;
```

هر بار که از یک عبارت `let` مثل این استفاده کرده‌اید، از الگوها استفاده کرده‌اید، اگرچه ممکن است متوجه آن نشده باشید! به‌طور رسمی‌تر، یک عبارت `let` به این شکل است:

```rust
let PATTERN = EXPRESSION;
```

در عباراتی مثل `let x = 5;` که یک نام متغیر در شکاف `PATTERN` دارد، نام متغیر فقط شکل ساده‌ای از یک الگو است. Rust عبارت را با الگو مقایسه می‌کند و هر نامی که پیدا کند را تخصیص می‌دهد. بنابراین، در مثال `let x = 5;`، `x` یک الگو است که به این معناست که «هر چیزی که اینجا مطابقت دارد را به متغیر `x` متصل کن.» چون نام `x` کل الگو است، این الگو عملاً به این معناست که «همه چیز را به متغیر `x` متصل کن، هر چه که مقدار باشد.»

برای دیدن جنبه تطبیق الگو در `let` به‌صورت واضح‌تر، فهرست کد 19-4 را در نظر بگیرید، که از یک الگو با `let` برای تجزیه یک تاپل استفاده می‌کند.

```rust
let (x, y, z) = (1, 2, 3);
```

**فهرست کد 19-4: استفاده از یک الگو برای تجزیه یک تاپل و ایجاد سه متغیر به‌طور همزمان**

در اینجا، ما یک تاپل را با یک الگو تطبیق می‌دهیم. Rust مقدار `(1, 2, 3)` را با الگوی `(x, y, z)` مقایسه می‌کند و می‌بیند که مقدار با الگو مطابقت دارد، به این معنا که تعداد عناصر در هر دو یکسان است، بنابراین Rust عدد 1 را به `x`، 2 را به `y`، و 3 را به `z` متصل می‌کند. می‌توانید این الگوی تاپل را به‌عنوان سه الگوی متغیر منفرد که در داخل آن قرار گرفته‌اند در نظر بگیرید.

اگر تعداد عناصر در الگو با تعداد عناصر در تاپل مطابقت نداشته باشد، نوع کلی مطابقت نخواهد داشت و یک خطای کامپایلر دریافت خواهیم کرد. برای مثال، فهرست کد 19-5 تلاشی برای تجزیه یک تاپل با سه عنصر به دو متغیر را نشان می‌دهد، که کار نخواهد کرد.

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
let (x, y) = (1, 2, 3);
```

**فهرست کد 19-5: ساخت نادرست یک الگو که متغیرهای آن با تعداد عناصر در تاپل مطابقت ندارند**

تلاش برای کامپایل این کد منجر به این خطای نوع می‌شود:

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

برای رفع خطا، می‌توانیم یک یا چند مقدار در تاپل را با استفاده از `_` یا `..` نادیده بگیریم، همان‌طور که در بخش «نادیده گرفتن مقادیر در یک الگو» خواهید دید. اگر مشکل این باشد که تعداد متغیرهای زیادی در الگو داریم، راه‌حل این است که نوع‌ها را با حذف متغیرها مطابقت دهیم تا تعداد متغیرها برابر با تعداد عناصر در تاپل باشد.

## پارامترهای تابع

پارامترهای تابع نیز می‌توانند الگو باشند. کد در فهرست کد 19-6، که یک تابع به نام `foo` را اعلان می‌کند که یک پارامتر به نام `x` از نوع `i32` می‌گیرد، تا حالا باید آشنا به نظر برسد.

```rust
fn foo(x: i32) {
    // کد اینجا می‌آید
}
```

**فهرست کد 19-6: امضای تابع که از الگوها در پارامترها استفاده می‌کند**

بخش `x` یک الگو است! همان‌طور که با `let` کردیم، می‌توانیم یک تاپل را در آرگومان‌های یک تابع با الگو تطبیق دهیم. فهرست کد 19-7 مقادیر یک تاپل را هنگام انتقال به یک تابع تقسیم می‌کند.

**فایل: src/main.rs**

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("مکان فعلی: ({x}, {y})"); // Current location: ({x}, {y})
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

**فهرست کد 19-7: تابعی با پارامترهایی که یک تاپل را تجزیه می‌کنند**

این کد «مکان فعلی: (3, 5)» را چاپ می‌کند. مقادیر `&(3, 5)` با الگوی `&(x, y)` مطابقت دارند، بنابراین `x` مقدار 3 و `y` مقدار 5 است.

ما همچنین می‌توانیم از الگوها در لیست پارامترهای کلوژر به همان روشی که در لیست پارامترهای تابع استفاده می‌کنیم، زیرا کلوژرها شبیه توابع هستند، همان‌طور که در فصل سیزدهم بحث کردیم.

تا این مرحله، چندین روش استفاده از الگوها را دیده‌اید، اما الگوها در هر جایی که می‌توانیم از آن‌ها استفاده کنیم به یک شکل کار نمی‌کنند. در برخی مکان‌ها، الگوها باید غیرقابل‌رد (irrefutable) باشند؛ در شرایط دیگر، می‌توانند قابل‌رد (refutable) باشند. در ادامه این دو مفهوم را بحث خواهیم کرد.
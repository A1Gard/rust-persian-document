# ساخت یک وب سرور تک‌ریسمانی

ما با راه‌اندازی یک وب سرور تک‌ریسمانی شروع خواهیم کرد. قبل از شروع، بیایید نگاهی سریع به پروتکل‌های مرتبط با ساخت وب سرورها بیندازیم. جزئیات این پروتکل‌ها خارج از محدوده این کتاب است، اما یک مرور مختصر اطلاعات مورد نیاز شما را فراهم می‌کند.

دو پروتکل اصلی مرتبط با وب سرورها عبارتند از **پروتکل انتقال ابرمتن (HTTP)** و **پروتکل کنترل انتقال (TCP)**. هر دو پروتکل، پروتکل‌های درخواست-پاسخ هستند، به این معنا که یک کلاینت درخواست‌ها را آغاز می‌کند و یک سرور به درخواست‌ها گوش می‌دهد و پاسخی به کلاینت ارائه می‌دهد. محتوای این درخواست‌ها و پاسخ‌ها توسط پروتکل‌ها تعریف می‌شود.

TCP پروتکل سطح پایین‌تری است که جزئیات چگونگی انتقال اطلاعات از یک سرور به سرور دیگر را توصیف می‌کند اما مشخص نمی‌کند که آن اطلاعات چیست. HTTP روی TCP ساخته شده و محتوای درخواست‌ها و پاسخ‌ها را تعریف می‌کند. از نظر فنی، امکان استفاده از HTTP با پروتکل‌های دیگر وجود دارد، اما در اکثر قریب به اتفاق موارد، HTTP داده‌های خود را از طریق TCP ارسال می‌کند. ما با بایت‌های خام درخواست‌ها و پاسخ‌های TCP و HTTP کار خواهیم کرد.

## گوش دادن به اتصال TCP

وب سرور ما نیاز دارد به یک اتصال TCP گوش دهد، بنابراین این اولین بخشی است که روی آن کار خواهیم کرد. کتابخانه استاندارد ماژول `std::net` را ارائه می‌دهد که به ما امکان انجام این کار را می‌دهد. بیایید یک پروژه جدید به روش معمول ایجاد کنیم:

```
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```

حالا کد موجود در Listing 21-1 را در `src/main.rs` وارد کنید تا شروع کنیم. این کد در آدرس محلی `127.0.0.1:7878` برای جریان‌های TCP ورودی گوش خواهد داد. وقتی یک جریان ورودی دریافت کند، پیام «Connection established!» را چاپ خواهد کرد.

**فایل: src/main.rs**

```rust
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("اتصال برقرار شد!"); // Connection established!
    }
}
```

**Listing 21-1: گوش دادن برای جریان‌های ورودی و چاپ پیام هنگام دریافت یک جریان**

با استفاده از `TcpListener`، می‌توانیم برای اتصالات TCP در آدرس `127.0.0.1:7878` گوش دهیم. در آدرس، بخش قبل از دو نقطه یک آدرس IP است که کامپیوتر شما را نشان می‌دهد (این در هر کامپیوتری یکسان است و به‌طور خاص کامپیوتر نویسندگان را نشان نمی‌دهد)، و 7878 پورت است. ما این پورت را به دو دلیل انتخاب کرده‌ایم: HTTP معمولاً روی این پورت پذیرفته نمی‌شود، بنابراین سرور ما به احتمال زیاد با هیچ وب سرور دیگری که ممکن است روی دستگاه شما اجرا شود تداخل نخواهد داشت، و 7878 کلمه «rust» است که روی صفحه‌کلید تلفن تایپ شده است.

تابع `bind` در این سناریو مانند تابع `new` عمل می‌کند به این معنا که یک نمونه جدید `TcpListener` را برمی‌گرداند. این تابع به نام `bind` نامیده می‌شود زیرا، در شبکه، اتصال به یک پورت برای گوش دادن به‌عنوان «اتصال به یک پورت» شناخته می‌شود.

تابع `bind` یک `Result<T, E>` برمی‌گرداند، که نشان می‌دهد امکان شکست اتصال وجود دارد. برای مثال، اتصال به پورت 80 نیاز به امتیازات مدیر (کاربران غیرمدیر فقط می‌توانند روی پورت‌های بالاتر از 1023 گوش دهند)، بنابراین اگر سعی کنیم بدون مدیر بودن به پورت 80 متصل شویم، اتصال کار نخواهد کرد. همچنین، اگر دو نمونه از برنامه خود را اجرا کنیم و دو برنامه به یک پورت گوش دهند، اتصال کار نخواهد کرد. چون ما یک سرور پایه فقط برای اهداف یادگیری می‌نویسیم، نگران مدیریت این نوع خطاها نخواهیم بود؛ در عوض، از `unwrap` استفاده می‌کنیم تا برنامه را در صورت بروز خطا متوقف کنیم.

متد `incoming` روی `TcpListener` یک تکرارگر برمی‌گرداند که یک دنباله از جریان‌ها (به‌طور خاص، جریان‌های نوع `TcpStream`) به ما می‌دهد. یک جریان واحد نشان‌دهنده یک اتصال باز بین کلاینت و سرور است. اتصال نامی است برای فرآیند کامل درخواست و پاسخ که در آن کلاینت به سرور متصل می‌شود، سرور یک پاسخ تولید می‌کند، و سرور اتصال را می‌بندد. به این ترتیب، ما از `TcpStream` خواهیم خواند تا ببینیم کلاینت چه چیزی ارسال کرده و سپس پاسخ خود را به جریان می‌نویسیم تا داده‌ها را به کلاینت برگردانیم. به‌طور کلی، این حلقه `for` هر اتصال را به نوبت پردازش خواهد کرد و یک سری جریان برای مدیریت تولید می‌کند.

برای حالا، مدیریت ما از جریان شامل فراخوانی `unwrap` برای خاتمه برنامه در صورت وجود هر گونه خطا در جریان است؛ اگر خطایی وجود نداشته باشد، برنامه یک پیام چاپ می‌کند. دلیل اینکه ممکن است هنگام اتصال یک کلاینت به سرور از متد `incoming` خطا دریافت کنیم این است که ما در واقع روی اتصالات تکرار نمی‌کنیم. در عوض، روی تلاش‌های اتصال تکرار می‌کنیم. اتصال ممکن است به دلایل متعددی موفق نشود، بسیاری از آن‌ها به سیستم‌عامل وابسته هستند. برای مثال، بسیاری از سیستم‌عامل‌ها محدودیتی برای تعداد اتصالات باز همزمان که می‌توانند پشتیبانی کنند دارند؛ تلاش‌های اتصال جدید فراتر از این تعداد خطا تولید خواهند کرد تا زمانی که برخی از اتصالات باز بسته شوند.

بیایید این کد را اجرا کنیم! در ترمینال `cargo run` را فراخوانی کنید و سپس در یک مرورگر وب `127.0.0.1:7878` را بارگذاری کنید. مرورگر باید یک پیام خطا مانند «اتصال بازنشانی شد» نشان دهد زیرا سرور در حال حاضر هیچ داده‌ای برنمی‌گرداند. اما وقتی به ترمینال خود نگاه کنید، باید چندین پیام را ببینید که وقتی مرورگر به سرور متصل شد چاپ شده‌اند!

```
     Running `target/debug/hello`
اتصال برقرار شد!
اتصال برقرار شد!
اتصال برقرار شد!
```

گاهی اوقات چندین پیام برای یک درخواست مرورگر چاپ می‌شود؛ دلیل ممکن است این باشد که مرورگر در حال درخواست صفحه و همچنین درخواست منابع دیگر، مانند آیکون `favicon.ico` که در تب مرورگر ظاهر می‌شود، است.

همچنین ممکن است مرورگر چندین بار سعی کند به سرور متصل شود زیرا سرور با هیچ داده‌ای پاسخ نمی‌دهد. وقتی `stream` از حوزه خارج می‌شود و در انتهای حلقه حذف می‌شود، اتصال به‌عنوان بخشی از پیاده‌سازی `drop` بسته می‌شود. مرورگرها گاهی با اتصالات بسته با تلاش مجدد مقابله می‌کنند، زیرا مشکل ممکن است موقتی باشد.

مرورگرها همچنین گاهی چندین اتصال به سرور را بدون ارسال هیچ درخواستی باز می‌کنند، تا اگر بعداً درخواست‌هایی ارسال کنند، سریع‌تر انجام شود. وقتی این اتفاق می‌افتد، سرور ما هر اتصال را می‌بیند، صرف‌نظر از اینکه آیا درخواستی از طریق آن اتصال وجود دارد یا خیر. بسیاری از نسخه‌های مرورگرهای مبتنی بر کروم این کار را انجام می‌دهند، برای مثال؛ می‌توانید این بهینه‌سازی را با استفاده از حالت مرور خصوصی غیرفعال کنید یا از مرورگر دیگری استفاده کنید.

عامل مهم این است که ما با موفقیت به یک اتصال TCP دست پیدا کرده‌ایم!

به یاد داشته باشید که وقتی کار با یک نسخه خاص از کد تمام شد، برنامه را با فشار دادن `ctrl-c` متوقف کنید. سپس پس از هر مجموعه تغییرات کد، با فراخوانی دستور `cargo run` برنامه را دوباره راه‌اندازی کنید تا مطمئن شوید که جدیدترین کد را اجرا می‌کنید.

## خواندن درخواست

بیایید عملکرد خواندن درخواست از مرورگر را پیاده‌سازی کنیم! برای جداسازی مسائل مربوط به دریافت ابتدا یک اتصال و سپس انجام اقدامی با اتصال، یک تابع جدید برای پردازش اتصالات شروع خواهیم کرد. در این تابع جدید `handle_connection`، داده‌ها را از جریان TCP خواهیم خواند و آن را چاپ خواهیم کرد تا بتوانیم داده‌های ارسالی از مرورگر را ببینیم. کد را به‌صورت Listing 21-2 تغییر دهید.

**فایل: src/main.rs**

```rust
use std::{
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("درخواست: {:#?}", http_request); // Request: {:#?}
}
```

**Listing 21-2: خواندن از TcpStream و چاپ داده‌ها**

ما `std::io::prelude` و `std::io::BufReader` را به حوزه می‌آوریم تا به ویژگی‌ها و انواعی دسترسی پیدا کنیم که به ما امکان خواندن و نوشتن به جریان را می‌دهند. در حلقه `for` در تابع `main`، به‌جای چاپ پیامی که می‌گوید اتصالی برقرار کردیم، حالا تابع جدید `handle_connection` را فراخوانی می‌کنیم و جریان را به آن پاس می‌دهیم.

در تابع `handle_connection`، یک نمونه جدید `BufReader` ایجاد می‌کنیم که یک ارجاع به جریان را بسته‌بندی می‌کند. `BufReader` با مدیریت فراخوانی‌های متدهای ویژگی `std::io::Read` برای ما، بافرینگ را اضافه می‌کند.

ما یک متغیر به نام `http_request` ایجاد می‌کنیم تا خطوط درخواست ارسالی توسط مرورگر به سرور ما را جمع‌آوری کنیم. ما مشخص می‌کنیم که می‌خواهیم این خطوط را در یک بردار جمع‌آوری کنیم با افزودن حاشیه‌نویسی نوع `Vec<_>`.

`BufReader` ویژگی `std::io::BufRead` را پیاده‌سازی می‌کند، که متد `lines` را ارائه می‌دهد. متد `lines` یک تکرارگر از `Result<String, std::io::Error>` را با تقسیم جریان داده‌ها هرگاه یک بایت خط جدید ببیند برمی‌گرداند. برای دریافت هر `String`، ما هر `Result` را نگاشت می‌کنیم و باز می‌کنیم. `Result` ممکن است یک خطا باشد اگر داده‌ها UTF-8 معتبر نباشند یا اگر مشکلی در خواندن از جریان وجود داشته باشد. باز هم، یک برنامه تولیدی باید این خطاها را با ظرافت بیشتری مدیریت کند، اما ما برای سادگی انتخاب می‌کنیم که در مورد خطا برنامه را متوقف کنیم.

مرورگر پایان یک درخواست HTTP را با ارسال دو کاراکتر خط جدید متوالی نشان می‌دهد، بنابراین برای دریافت یک درخواست از جریان، خطوط را تا زمانی که یک خط رشته خالی باشد می‌گیریم. هنگامی که خطوط را در بردار جمع‌آوری کردیم، آن‌ها را با استفاده از قالب‌بندی دیباگ زیبا چاپ می‌کنیم تا بتوانیم نگاهی به دستورالعمل‌هایی که مرورگر وب به سرور ما ارسال می‌کند بیندازیم.

بیایید این کد را امتحان کنیم! برنامه را شروع کنید و دوباره در یک مرورگر وب درخواستی انجام دهید. توجه کنید که همچنان در مرورگر یک صفحه خطا دریافت خواهیم کرد، اما خروجی برنامه ما در ترمینال حالا باید چیزی شبیه به این به نظر برسد:

```
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
درخواست: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
```

بسته به مرورگر شما، ممکن است خروجی کمی متفاوتی دریافت کنید. حالا که داده‌های درخواست را چاپ می‌کنیم، می‌توانیم ببینیم چرا چندین اتصال از یک درخواست مرورگر دریافت می‌کنیم با نگاه کردن به مسیر بعد از `GET` در اولین خط درخواست. اگر اتصالات تکراری همه در حال درخواست `/` هستند، می‌دانیم که مرورگر به‌طور مکرر سعی در دریافت `/` دارد زیرا پاسخی از برنامه ما دریافت نمی‌کند.

بیایید این داده‌های درخواست را تجزیه کنیم تا بفهمیم مرورگر از برنامه ما چه می‌خواهد.

## نگاهی دقیق‌تر به یک درخواست HTTP

HTTP یک پروتکل مبتنی بر متن است، و یک درخواست به این فرمت است:

```
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```

خط اول خط درخواست است که اطلاعاتی درباره آنچه کلاینت درخواست می‌کند را نگه می‌دارد. بخش اول خط درخواست روش مورد استفاده را نشان می‌دهد، مانند `GET` یا `POST`، که توصیف می‌کند کلاینت چگونه این درخواست را انجام می‌دهد. کلاینت ما از یک درخواست `GET` استفاده کرد، به این معنا که در حال درخواست اطلاعات است.

بخش بعدی خط درخواست `/` است، که نشان‌دهنده شناسه منبع یکنواخت (URI) است که کلاینت درخواست می‌کند: یک URI تقریباً، اما نه کاملاً، مشابه یک مکان‌یاب منبع یکنواخت (URL) است. تفاوت بین URIها و URLها برای اهداف ما در این فصل مهم نیست، اما مشخصات HTTP از اصطلاح URI استفاده می‌کند، بنابراین می‌توانیم اینجا URI را به‌صورت ذهنی با URL جایگزین کنیم.

آخرین بخش نسخه HTTP است که کلاینت استفاده می‌کند، و سپس خط درخواست با یک دنباله CRLF پایان می‌یابد. (CRLF مخفف بازگشت واگن و تغذیه خط است، که اصطلاحاتی از دوران ماشین تحریر هستند!) دنباله CRLF همچنین می‌تواند به‌صورت `\r\n` نوشته شود، جایی که `\r` بازگشت واگن و `\n` تغذیه خط است. دنباله CRLF خط درخواست را از بقیه داده‌های درخواست جدا می‌کند. توجه کنید که وقتی CRLF چاپ می‌شود، ما یک خط جدید را می‌بینیم به‌جای `\r\n`.

با نگاه به داده‌های خط درخواست که تاکنون از اجرای برنامه خود دریافت کرده‌ایم، می‌بینیم که `GET` روش است، `/` URI درخواست است، و `HTTP/1.1` نسخه است.

پس از خط درخواست، خطوط باقی‌مانده از `Host:` به بعد هدرها هستند. درخواست‌های `GET` بدنه‌ای ندارند.

سعی کنید از یک مرورگر متفاوت درخواستی انجام دهید یا آدرس متفاوتی مانند `127.0.0.1:7878/test` درخواست کنید تا ببینید داده‌های درخواست چگونه تغییر می‌کنند.

حالا که می‌دانیم مرورگر چه چیزی درخواست می‌کند، بیایید مقداری داده برگردانیم!

## نوشتن یک پاسخ

ما قصد داریم ارسال داده در پاسخ به یک درخواست کلاینت را پیاده‌سازی کنیم. پاسخ‌ها فرمت زیر را دارند:

```
HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
```

خط اول خط وضعیت است که شامل نسخه HTTP استفاده‌شده در پاسخ، یک کد وضعیت عددی که نتیجه درخواست را خلاصه می‌کند، و یک عبارت دلیل که توضیح متنی از کد وضعیت را ارائه می‌دهد. پس از دنباله CRLF، هر هدر، یک دنباله CRLF دیگر، و بدنه پاسخ قرار دارد.

اینجا یک مثال پاسخ است که از نسخه HTTP 1.1 استفاده می‌کند، و دارای کد وضعیت 200، یک عبارت دلیل OK، بدون هدر، و بدون بدنه است:

```
HTTP/1.1 200 OK\r\n\r\n
```

کد وضعیت 200 پاسخ موفقیت استاندارد است. متن یک پاسخ HTTP موفق کوچک است. بیایید این را به جریان بنویسیم به‌عنوان پاسخ ما به یک درخواست موفق! از تابع `handle_connection`، دستور `println!` که داده‌های درخواست را چاپ می‌کرد را حذف کنید و آن را با کد موجود در Listing 21-3 جایگزین کنید.

**فایل: src/main.rs**

```rust
fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}
```

**Listing 21-3: نوشتن یک پاسخ HTTP موفق کوچک به جریان**

خط جدید اول متغیر `response` را تعریف می‌کند که داده‌های پیام موفقیت را نگه می‌دارد. سپس `as_bytes` را روی `response` ما فراخوانی می‌کنیم تا داده‌های رشته را به بایت تبدیل کنیم. متد `write_all` روی `stream` یک `&[u8]` می‌گیرد و این بایت‌ها را مستقیماً به اتصال ارسال می‌کند. چون عملیات `write_all` ممکن است شکست بخورد، ما مانند قبل روی هر نتیجه خطا از `unwrap` استفاده می‌کنیم. باز هم، در یک برنامه واقعی باید مدیریت خطا را اینجا اضافه کنید.

با این تغییرات، بیایید کد خود را اجرا کنیم و یک درخواست انجام دهیم. ما دیگر هیچ داده‌ای به ترمینال چاپ نمی‌کنیم، بنابراین جز خروجی از Cargo هیچ خروجی دیگری نخواهیم دید. وقتی `127.0.0.1:7878` را در یک مرورگر وب بارگذاری می‌کنید، باید یک صفحه خالی به‌جای خطا دریافت کنید. شما فقط یک درخواست HTTP را دریافت کرده‌اید و یک پاسخ ارسال کرده‌اید!

## بازگرداندن HTML واقعی

بیایید عملکردی را برای بازگرداندن چیزی بیشتر از یک صفحه خالی پیاده‌سازی کنیم. فایل جدید `hello.html` را در ریشه دایرکتوری پروژه خود، نه در دایرکتوری `src`، ایجاد کنید. می‌توانید هر HTML‌ای که می‌خواهید وارد کنید؛ Listing 21-4 یک امکان را نشان می‌دهد.

**فایل: hello.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>سلام!</title> <!-- Hello! -->
  </head>
  <body>
    <h1>سلام!</h1> <!-- Hello! -->
    <p>سلام از Rust</p> <!-- Hi from Rust -->
  </body>
</html>
```

**Listing 21-4: یک فایل HTML نمونه برای بازگرداندن در پاسخ**

این یک سند HTML5 حداقلی با یک سرتیتر و مقداری متن است. برای بازگرداندن این از سرور وقتی یک درخواست دریافت می‌شود، ما `handle_connection` را همان‌طور که در Listing 21-5 نشان داده شده تغییر خواهیم داد تا فایل HTML را بخوانیم، آن را به‌عنوان بدنه به پاسخ اضافه کنیم، و آن را ارسال کنیم.

**فایل: src/main.rs**

```rust
use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{}\r\nContent-Length: {}\r\n\r\n{}", status_line, length, contents);

    stream.write_all(response.as_bytes()).unwrap();
}
```

**Listing 21-5: ارسال محتوای hello.html به‌عنوان بدنه پاسخ**

ما `fs` را به بیانیه `use` اضافه کرده‌ایم تا ماژول سیستم فایل کتابخانه استاندارد را به حوزه بیاوریم. کد برای خواندن محتوای یک فایل به یک رشته باید آشنا به نظر برسد؛ ما از آن در پروژه ورودی/خروجی خود در Listing 12-4 استفاده کردیم.

سپس، از `format!` استفاده می‌کنیم تا محتوای فایل را به‌عنوان بدنه پاسخ موفقیت اضافه کنیم. برای اطمینان از یک پاسخ HTTP معتبر، هدر `Content-Length` را اضافه می‌کنیم که به اندازه بدنه پاسخ ما تنظیم شده است، در این مورد اندازه `hello.html`.

این کد را با `cargo run` اجرا کنید و `127.0.0.1:7878` را در مرورگر خود بارگذاری کنید؛ باید HTML رندرشده خود را ببینید!

در حال حاضر، ما داده‌های درخواست در `http_request` را نادیده می‌گیریم و فقط محتوای فایل HTML را به‌صورت غیرمشروط ارسال می‌کنیم. این به این معناست که اگر سعی کنید `127.0.0.1:7878/something-else` را در مرورگر خود درخواست کنید، همچنان این پاسخ HTML یکسان را دریافت خواهید کرد. در حال حاضر، سرور ما بسیار محدود است و کاری که اکثر وب سرورها انجام می‌دهند را انجام نمی‌دهد. ما می‌خواهیم پاسخ‌های خود را بسته به درخواست سفارشی کنیم و فقط فایل HTML را برای یک درخواست به‌خوبی شکل‌گرفته به `/` ارسال کنیم.

## اعتبارسنجی درخواست و پاسخ انتخابی

در حال حاضر، وب سرور ما HTML موجود در فایل را بدون توجه به آنچه کلاینت درخواست کرده برمی‌گرداند. بیایید عملکردی اضافه کنیم تا بررسی کنیم که مرورگر در حال درخواست `/` است قبل از بازگرداندن فایل HTML و اگر مرورگر چیز دیگری درخواست کند، خطا برگردانیم. برای این کار، باید `handle_connection` را همان‌طور که در Listing 21-6 نشان داده شده تغییر دهیم. این کد جدید محتوای درخواست دریافت‌شده را با آنچه می‌دانیم یک درخواست برای `/` به نظر می‌رسد بررسی می‌کند و بلوک‌های `if` و `else` را اضافه می‌کند تا درخواست‌ها را متفاوت مدیریت کند.

**فایل: src/main.rs**

```rust
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{}\r\nContent-Length: {}\r\n\r\n{}", status_line, length, contents
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // درخواست دیگری
    }
}
```

**Listing 21-6: مدیریت درخواست‌ها به / به‌صورت متفاوت از سایر درخواست‌ها**

ما فقط به خط اول درخواست HTTP نگاه خواهیم کرد، بنابراین به‌جای خواندن کل درخواست به یک بردار، `next` را فراخوانی می‌کنیم تا اولین آیتم را از تکرارگر دریافت کنیم. اولین `unwrap` از `Option` مراقبت می‌کند و اگر تکرارگر هیچ آیتمی نداشته باشد، برنامه را متوقف می‌کند. دومین `unwrap` از `Result` مراقبت می‌کند و همان اثر `unwrap` را دارد که در `map` اضافه‌شده در Listing 21-2 بود.

سپس، ما `request_line` را بررسی می‌کنیم تا ببینیم آیا برابر با خط درخواست یک درخواست `GET` به مسیر `/` است یا خیر. اگر باشد، بلوک `if` محتوای فایل HTML ما را برمی‌گرداند.

اگر `request_line` برابر با درخواست `GET` به مسیر `/` نباشد، به این معناست که درخواست دیگری دریافت کرده‌ایم. ما به‌زودی کدی به بلوک `else` اضافه خواهیم کرد تا به همه درخواست‌های دیگر پاسخ دهیم.

این کد را حالا اجرا کنید و `127.0.0.1:7878` را درخواست کنید؛ باید HTML موجود در `hello.html` را دریافت کنید. اگر هر درخواست دیگری انجام دهید، مانند `127.0.0.1:7878/something-else`، یک خطای اتصال مانند آن‌هایی که هنگام اجرای کد در Listing 21-1 و Listing 21-2 دیدید دریافت خواهید کرد.

حالا بیایید کد موجود در Listing 21-7 را به بلوک `else` اضافه کنیم تا پاسخی با کد وضعیت 404 برگردانیم، که نشان می‌دهد محتوا برای درخواست یافت نشد. همچنین مقداری HTML برای یک صفحه برای رندر در مرورگر برمی‌گردانیم که پاسخ را به کاربر نهایی نشان می‌دهد.

**فایل: src/main.rs**

```rust
    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{}\r\nContent-Length: {}\r\n\r\n{}", status_line, length, contents
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
```

**Listing 21-7: پاسخ با کد وضعیت 404 و یک صفحه خطا اگر چیزی غیر از / درخواست شده باشد**

در اینجا، پاسخ ما یک خط وضعیت با کد وضعیت 404 و عبارت دلیل `NOT FOUND` دارد. بدنه پاسخ HTML موجود در فایل `404.html` خواهد بود. شما باید یک فایل `404.html` در کنار `hello.html` برای صفحه خطا ایجاد کنید؛ باز هم آزاد هستید که هر HTML‌ای که می‌خواهید استفاده کنید یا از HTML نمونه در Listing 21-8 استفاده کنید.

**فایل: 404.html**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>سلام!</title> <!-- Hello! -->
  </head>
  <body>
    <h1>اوپس!</h1> <!-- Oops! -->
    <p>متاسفم، نمی‌دانم شما چه چیزی درخواست کرده‌اید.</p> <!-- Sorry, I don't know what you're asking for. -->
  </body>
</html>
```

**Listing 21-8: محتوای نمونه برای صفحه‌ای که با هر پاسخ 404 ارسال می‌شود**

با این تغییرات، سرور خود را دوباره اجرا کنید. درخواست `127.0.0.1:7878` باید محتوای `hello.html` را برگرداند، و هر درخواست دیگر، مانند `127.0.0.1:7878/foo`، باید HTML خطا را از `404.html` برگرداند.

## کمی بازسازی

در حال حاضر، بلوک‌های `if` و `else` تکرار زیادی دارند: هر دو فایل‌ها را می‌خوانند و محتوای فایل‌ها را به جریان می‌نویسند. تنها تفاوت‌ها خط وضعیت و نام فایل هستند. بیایید کد را با بیرون کشیدن این تفاوت‌ها به خطوط جداگانه `if` و `else` که مقادیر خط وضعیت و نام فایل را به متغیرها اختصاص می‌دهند، مختصرتر کنیم؛ سپس می‌توانیم از این متغیرها به‌صورت غیرمشروط در کد برای خواندن فایل و نوشتن پاسخ استفاده کنیم. Listing 21-9 کد نتیجه‌ای را نشان می‌دهد که پس از جایگزینی بلوک‌های بزرگ `if` و `else` به دست می‌آید.

**فایل: src/main.rs**

```rust
// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{}\r\nContent-Length: {}\r\n\r\n{}", status_line, length, contents);

    stream.write_all(response.as_bytes()).unwrap();
}
```

**Listing 21-9: بازسازی بلوک‌های if و else برای شامل فقط کدی که بین دو مورد متفاوت است**

حالا بلوک‌های `if` و `else` فقط مقادیر مناسب برای خط وضعیت و نام فایل را در یک تاپل برمی‌گردانند؛ ما سپس از تخریب ساختار برای اختصاص این دو مقدار به `status_line` و `filename` با استفاده از یک الگو در بیانیه `let` استفاده می‌کنیم، همان‌طور که در فصل نوزدهم بحث کردیم.

کد قبلاً تکراری حالا خارج از بلوک‌های `if` و `else` است و از متغیرهای `status_line` و `filename` استفاده می‌کند. این باعث می‌شود دیدن تفاوت بین دو مورد آسان‌تر شود، و به این معناست که فقط یک مکان برای به‌روزرسانی کد داریم اگر بخواهیم نحوه خواندن فایل و نوشتن پاسخ را تغییر دهیم. رفتار کد در Listing 21-9 همانند Listing 21-7 خواهد بود.

عالی! ما حالا یک وب سرور ساده در حدود 40 خط کد Rust داریم که به یک درخواست با یک صفحه محتوا پاسخ می‌دهد و به همه درخواست‌های دیگر با یک پاسخ 404 پاسخ می‌دهد.

در حال حاضر، سرور ما در یک ریسمان واحد اجرا می‌شود، به این معنا که فقط می‌تواند یک درخواست را در یک زمان ارائه دهد. بیایید بررسی کنیم که چگونه این می‌تواند مشکل‌ساز باشد با شبیه‌سازی برخی درخواست‌های کند. سپس آن را برطرف خواهیم کرد تا سرور ما بتواند چندین درخواست را به‌صورت همزمان مدیریت کند.
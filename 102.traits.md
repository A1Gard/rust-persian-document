# ترییت‌ها: تعریف رفتار مشترک

ترییت (trait) قابلیت‌هایی را که یک نوع خاص دارد و می‌تواند با نوع‌های دیگر به اشتراک بگذارد، تعریف می‌کند. ما می‌توانیم از ترییت‌ها برای تعریف رفتار مشترک به‌صورت انتزاعی استفاده کنیم. همچنین می‌توانیم از محدودیت‌های ترییت (trait bounds) استفاده کنیم تا مشخص کنیم که یک نوع Generic می‌تواند هر نوع باشد که رفتار خاصی دارد.

> **توجه**: ترییت‌ها مشابه ویژگی‌ای هستند که در زبان‌های دیگر اغلب **رابط‌ها (interfaces)** نامیده می‌شوند، اگرچه تفاوت‌هایی دارند.

## تعریف یک ترییت

رفتار یک نوع شامل متدهایی است که می‌توانیم روی آن نوع فراخوانی کنیم. نوع‌های مختلف می‌توانند رفتار یکسانی داشته باشند اگر بتوانیم همان متدها را روی همه آن نوع‌ها فراخوانی کنیم. تعریف‌های ترییت راهی برای گروه‌بندی امضاهای متدها هستند تا مجموعه‌ای از رفتارهای لازم برای دستیابی به یک هدف خاص را تعریف کنند.

برای مثال، فرض کنید چندین ساختار داریم که انواع و مقادیر مختلفی از متن را نگه می‌دارند: یک ساختار `NewsArticle` که یک خبر را در یک مکان خاص نگه می‌دارد و یک `SocialPost` که می‌تواند حداکثر 280 کاراکتر داشته باشد همراه با متادیتایی که نشان می‌دهد آیا پست جدید، بازپست، یا پاسخ به پست دیگری است.

ما می‌خواهیم یک کتابخانه جمع‌آوری رسانه به نام `aggregator` بسازیم که بتواند خلاصه‌هایی از داده‌هایی که ممکن است در یک نمونه `NewsArticle` یا `SocialPost` ذخیره شده باشند را نمایش دهد. برای این کار، به یک خلاصه از هر نوع نیاز داریم و این خلاصه را با فراخوانی متد `summarize` روی یک نمونه درخواست خواهیم کرد. **جدول 10-12** تعریف یک ترییت عمومی `Summary` را نشان می‌دهد که این رفتار را بیان می‌کند.

**فایل: src/lib.rs**

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

**جدول 10-12**: یک ترییت `Summary` که شامل رفتاری است که توسط متد `summarize` ارائه می‌شود

در اینجا، ما یک ترییت را با استفاده از کلمه‌کلیدی `trait` و سپس نام ترییت، که در این مورد `Summary` است، اعلام می‌کنیم. همچنین ترییت را به‌عنوان `pub` اعلام می‌کنیم تا کریت‌هایی که به این کریت وابسته هستند نیز بتوانند از این ترییت استفاده کنند، همان‌طور که در چند مثال خواهیم دید. داخل کروشه‌ها، امضاهای متدهایی را اعلام می‌کنیم که رفتارهای نوع‌هایی که این ترییت را پیاده‌سازی می‌کنند را توصیف می‌کنند، که در این مورد `fn summarize(&self) -> String` است.

بعد از امضای متد، به‌جای ارائه یک پیاده‌سازی در داخل کروشه‌ها، از یک سمی‌کالن استفاده می‌کنیم. هر نوع که این ترییت را پیاده‌سازی می‌کند باید رفتار سفارشی خود را برای بدنه متد ارائه دهد. کامپایلر اطمینان حاصل خواهد کرد که هر نوع که ترییت `Summary` را دارد، متد `summarize` را دقیقاً با این امضا تعریف کرده باشد.

یک ترییت می‌تواند چندین متد در بدنه خود داشته باشد: امضاهای متدها یک خط در میان فهرست می‌شوند و هر خط با یک سمی‌کالن پایان می‌یابد.

## پیاده‌سازی یک ترییت روی یک نوع

اکنون که امضاهای مورد نظر متدهای ترییت `Summary` را تعریف کردیم، می‌توانیم آن را روی نوع‌ها در جمع‌آوری‌کننده رسانه خود پیاده‌سازی کنیم. **جدول 10-13** پیاده‌سازی ترییت `Summary` را روی ساختار `NewsArticle` نشان می‌دهد که از تیتر، نویسنده، و مکان برای ایجاد مقدار بازگشتی `summarize` استفاده می‌کند. برای ساختار `SocialPost`، ما `summarize` را به‌عنوان نام کاربری به دنبال کل متن پست تعریف می‌کنیم، با این فرض که محتوای پست از قبل به 280 کاراکتر محدود شده است.

**فایل: src/lib.rs**

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

**جدول 10-13**: پیاده‌سازی ترییت `Summary` روی نوع‌های `NewsArticle` و `SocialPost`

پیاده‌سازی یک ترییت روی یک نوع مشابه پیاده‌سازی متدهای معمولی است. تفاوت این است که بعد از `impl`، نام ترییتی که می‌خواهیم پیاده‌سازی کنیم را قرار می‌دهیم، سپس از کلمه‌کلیدی `for` استفاده می‌کنیم و نام نوع که می‌خواهیم ترییت را برای آن پیاده‌سازی کنیم مشخص می‌کنیم. در بلاک `impl`، امضاهای متدهایی که تعریف ترییت مشخص کرده را قرار می‌دهیم. به‌جای افزودن یک سمی‌کالن بعد از هر امضا، از کروشه‌ها استفاده می‌کنیم و بدنه متد را با رفتار خاصی که می‌خواهیم متدهای ترییت برای نوع خاص داشته باشند پر می‌کنیم.

اکنون که کتابخانه ترییت `Summary` را روی `NewsArticle` و `SocialPost` پیاده‌سازی کرده است، کاربران کریت می‌توانند متدهای ترییت را روی نمونه‌های `NewsArticle` و `SocialPost` به همان روشی که متدهای معمولی را فراخوانی می‌کنیم، فراخوانی کنند. تنها تفاوت این است که کاربر باید ترییت را به همراه نوع‌ها به حوزه (scope) بیاورد. در اینجا مثالی از نحوه استفاده یک کریت باینری از کریت کتابخانه `aggregator` ما آورده شده است:

```rust
use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new social post: {}", post.summarize());
}
```

این کد چاپ می‌کند: `1 new post: horse_ebooks: of course, as you probably already know, people`.

کریت‌های دیگری که به کریت `aggregator` وابسته هستند نیز می‌توانند ترییت `Summary` را به حوزه بیاورند تا `Summary` را روی نوع‌های خودشان پیاده‌سازی کنند. یک محدودیت که باید توجه داشت این است که ما فقط می‌توانیم یک ترییت را روی یک نوع پیاده‌سازی کنیم اگر یا ترییت یا نوع، یا هر دو، محلی (local) برای کریت ما باشند. برای مثال، ما می‌توانیم ترییت‌های کتابخانه استاندارد مانند `Display` را روی یک نوع سفارشی مانند `SocialPost` به‌عنوان بخشی از قابلیت کریت `aggregator` خود پیاده‌سازی کنیم، زیرا نوع `SocialPost` محلی برای کریت `aggregator` ما است. همچنین می‌توانیم `Summary` را روی `Vec<T>` در کریت `aggregator` خود پیاده‌سازی کنیم، زیرا ترییت `Summary` محلی برای کریت `aggregator` ما است.

اما نمی‌توانیم ترییت‌های خارجی را روی نوع‌های خارجی پیاده‌سازی کنیم. برای مثال، نمی‌توانیم ترییت `Display` را روی `Vec<T>` در کریت `aggregator` خود پیاده‌سازی کنیم، زیرا `Display` و `Vec<T>` هر دو در کتابخانه استاندارد تعریف شده‌اند و محلی برای کریت `aggregator` ما نیستند. این محدودیت بخشی از خاصیتی به نام **انسجام (coherence)** است، و به‌طور خاص‌تر قانون یتیم (orphan rule)، که به این دلیل نام‌گذاری شده است که نوع والد وجود ندارد. این قانون تضمین می‌کند که کد دیگران نمی‌تواند کد شما را خراب کند و بالعکس. بدون این قانون، دو کریت می‌توانستند همان ترییت را برای همان نوع پیاده‌سازی کنند، و **Rust** نمی‌دانست کدام پیاده‌سازی را استفاده کند.

## پیاده‌سازی‌های پیش‌فرض

گاهی اوقات مفید است که برای برخی یا همه متدهای یک ترییت رفتار پیش‌فرض داشته باشیم به‌جای اینکه برای همه متدها روی هر نوع پیاده‌سازی لازم باشد. سپس، وقتی ترییت را روی یک نوع خاص پیاده‌سازی می‌کنیم، می‌توانیم رفتار پیش‌فرض هر متد را نگه داریم یا آن را بازنویسی کنیم.

در **جدول 10-14**، ما یک رشته پیش‌فرض برای متد `summarize` ترییت `Summary` مشخص می‌کنیم به‌جای اینکه فقط امضای متد را تعریف کنیم، همان‌طور که در **جدول 10-12** کردیم.

**فایل: src/lib.rs**

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

**جدول 10-14**: تعریف یک ترییت `Summary` با یک پیاده‌سازی پیش‌فرض برای متد `summarize`

برای استفاده از یک پیاده‌سازی پیش‌فرض برای خلاصه کردن نمونه‌های `NewsArticle`، یک بلاک `impl` خالی با `impl Summary for NewsArticle {}` مشخص می‌کنیم.

اگرچه دیگر متد `summarize` را مستقیماً روی `NewsArticle` تعریف نمی‌کنیم، یک پیاده‌سازی پیش‌فرض ارائه کرده‌ایم و مشخص کرده‌ایم که `NewsArticle` ترییت `Summary` را پیاده‌سازی می‌کند. در نتیجه، همچنان می‌توانیم متد `summarize` را روی یک نمونه از `NewsArticle` فراخوانی کنیم، مانند این:

```rust
let article = NewsArticle {
    headline: String::from("Penguins win the Stanley Cup Championship!"),
    location: String::from("Pittsburgh, PA, USA"),
    author: String::from("Iceburgh"),
    content: String::from(
        "The Pittsburgh Penguins once again are the best \
         hockey team in the NHL.",
    ),
};

println!("New article available! {}", article.summarize());
```

این کد چاپ می‌کند: `New article available! (Read more...)`.

ایجاد یک پیاده‌سازی پیش‌فرض نیازی به تغییر چیزی در پیاده‌سازی `Summary` روی `SocialPost` در **جدول 10-13** ندارد. دلیلش این است که نحو برای بازنویسی یک پیاده‌سازی پیش‌فرض همان نحو برای پیاده‌سازی یک متد ترییت است که پیاده‌سازی پیش‌فرض ندارد.

پیاده‌سازی‌های پیش‌فرض می‌توانند متدهای دیگر در همان ترییت را فراخوانی کنند، حتی اگر آن متدهای دیگر پیاده‌سازی پیش‌فرض نداشته باشند. به این ترتیب، یک ترییت می‌تواند قابلیت‌های مفید زیادی ارائه دهد و فقط نیاز داشته باشد که پیاده‌سازها بخش کوچکی از آن را مشخص کنند. برای مثال، می‌توانیم ترییت `Summary` را طوری تعریف کنیم که یک متد `summarize_author` داشته باشد که پیاده‌سازی آن لازم است، و سپس یک متد `summarize` تعریف کنیم که یک پیاده‌سازی پیش‌فرض دارد و متد `summarize_author` را فراخوانی می‌کند:

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

برای استفاده از این نسخه از `Summary`، فقط باید `summarize_author` را هنگام پیاده‌سازی ترییت روی یک نوع تعریف کنیم:

```rust
impl Summary for SocialPost {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

بعد از اینکه `summarize_author` را تعریف کردیم، می‌توانیم `summarize` را روی نمونه‌های ساختار `SocialPost` فراخوانی کنیم، و پیاده‌سازی پیش‌فرض `summarize` تعریف `summarize_author` که ما ارائه کرده‌ایم را فراخوانی خواهد کرد. چون `summarize_author` را پیاده‌سازی کرده‌ایم، ترییت `Summary` رفتار متد `summarize` را به ما داده است بدون اینکه نیاز باشد کد بیشتری بنویسیم. این به این شکل است:

```rust
let post = SocialPost {
    username: String::from("horse_ebooks"),
    content: String::from(
        "of course, as you probably already know, people",
    ),
    reply: false,
    repost: false,
};

println!("1 new social post: {}", post.summarize());
```

این کد چاپ می‌کند: `1 new post: (Read more from @horse_ebooks...)`.

توجه داشته باشید که امکان فراخوانی پیاده‌سازی پیش‌فرض از یک پیاده‌سازی بازنویسی‌شده همان متد وجود ندارد.

## ترییت‌ها به‌عنوان پارامتر

اکنون که می‌دانید چگونه ترییت‌ها را تعریف و پیاده‌سازی کنید، می‌توانیم بررسی کنیم که چگونه از ترییت‌ها برای تعریف توابعی استفاده کنیم که نوع‌های مختلفی را می‌پذیرند. ما از ترییت `Summary` که روی نوع‌های `NewsArticle` و `SocialPost` در **جدول 10-13** پیاده‌سازی کردیم استفاده خواهیم کرد تا یک تابع `notify` تعریف کنیم که متد `summarize` را روی پارامتر `item` خود فراخوانی می‌کند، که از نوعی است که ترییت `Summary` را پیاده‌سازی می‌کند. برای این کار، از نحو `impl Trait` استفاده می‌کنیم، مانند این:

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

به‌جای یک نوع مشخص برای پارامتر `item`، ما کلمه‌کلیدی `impl` و نام ترییت را مشخص می‌کنیم. این پارامتر هر نوع که ترییت مشخص‌شده را پیاده‌سازی کند می‌پذیرد. در بدنه `notify`، می‌توانیم هر متدی را روی `item` فراخوانی کنیم که از ترییت `Summary` می‌آید، مانند `summarize`. ما می‌توانیم `notify` را فراخوانی کنیم و هر نمونه‌ای از `NewsArticle` یا `SocialPost` را به آن پاس دهیم. کدی که تابع را با هر نوع دیگر، مانند `String` یا `i32`، فراخوانی کند، کامپایل نخواهد شد زیرا آن نوع‌ها `Summary` را پیاده‌سازی نکرده‌اند.

## نحو محدودیت ترییت

نحو `impl Trait` برای موارد ساده خوب کار می‌کند اما در واقع یک شکر نحوی برای شکل طولانی‌تر شناخته‌شده به نام **محدودیت ترییت (trait bound)** است؛ به این شکل است:

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

این شکل طولانی‌تر معادل مثال در بخش قبلی است اما پرمخاطب‌تر است. ما محدودیت‌های ترییت را با اعلام پارامتر نوع Generic بعد از یک دونقطه و داخل کروشه‌ها قرار می‌دهیم.

نحو `impl Trait` راحت است و کد را در موارد ساده مختصرتر می‌کند، در حالی که نحو کامل محدودیت ترییت می‌تواند در موارد دیگر پیچیدگی بیشتری را بیان کند. برای مثال، می‌توانیم دو پارامتر داشته باشیم که `Summary` را پیاده‌سازی کنند. انجام این کار با نحو `impl Trait` به این شکل است:

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

استفاده از `impl Trait` مناسب است اگر بخواهیم این تابع اجازه دهد `item1` و `item2` نوع‌های متفاوتی داشته باشند (تا زمانی که هر دو نوع `Summary` را پیاده‌سازی کنند). اما اگر بخواهیم هر دو پارامتر نوع یکسانی داشته باشند، باید از یک محدودیت ترییت استفاده کنیم، مانند این:

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

نوع Generic `T` که به‌عنوان نوع پارامترهای `item1` و `item2` مشخص شده، تابع را محدود می‌کند به‌گونه‌ای که نوع مشخص مقداری که به‌عنوان آرگومان برای `item1` و `item2` پاس می‌شود باید یکسان باشد.

## مشخص کردن چندین محدودیت ترییت با نحو `+`

ما همچنین می‌توانیم بیش از یک محدودیت ترییت مشخص کنیم. فرض کنید می‌خواهیم `notify` از فرمت‌بندی نمایش (display formatting) و همچنین `summarize` روی `item` استفاده کند: ما در تعریف `notify` مشخص می‌کنیم که `item` باید هر دو `Display` و `Summary` را پیاده‌سازی کند. می‌توانیم این کار را با استفاده از نحو `+` انجام دهیم:

```rust
pub fn notify(item: &(impl Summary + Display)) {
```

نحو `+` همچنین با محدودیت‌های ترییت روی نوع‌های Generic معتبر است:

```rust
pub fn notify<T: Summary + Display>(item: &T) {
```

با مشخص شدن دو محدودیت ترییت، بدنه `notify` می‌تواند `summarize` را فراخوانی کند و از `{}` برای فرمت‌بندی `item` استفاده کند.

## محدودیت‌های ترییت واضح‌تر با بندهای `where`

استفاده از محدودیت‌های ترییت زیاد معایبی دارد. هر Generic محدودیت‌های ترییت خود را دارد، بنابراین توابعی با چندین پارامتر نوع Generic می‌توانند اطلاعات زیادی از محدودیت‌های ترییت بین نام تابع و لیست پارامترهای آن داشته باشند، که باعث می‌شود امضای تابع سخت‌خوان شود. به همین دلیل، **Rust** نحو جایگزینی برای مشخص کردن محدودیت‌های ترییت داخل یک بند `where` بعد از امضای تابع دارد. بنابراین، به‌جای نوشتن این:

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

می‌توانیم از یک بند `where` استفاده کنیم، مانند این:

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
```

امضای این تابع کمتر شلوغ است: نام تابع، لیست پارامترها، و نوع بازگشتی نزدیک به هم هستند، مشابه تابعی بدون محدودیت‌های ترییت زیاد.

## برگرداندن نوع‌هایی که ترییت‌ها را پیاده‌سازی می‌کنند

ما همچنین می‌توانیم از نحو `impl Trait` در موقعیت بازگشتی برای برگرداندن مقداری از نوعی که یک ترییت را پیاده‌سازی می‌کند استفاده کنیم، همان‌طور که در اینجا نشان داده شده است:

```rust
fn returns_summarizable() -> impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    }
}
```

با استفاده از `impl Summary` برای نوع بازگشتی، ما مشخص می‌کنیم که تابع `returns_summarizable` نوعی را برمی‌گرداند که ترییت `Summary` را پیاده‌سازی می‌کند بدون اینکه نوع مشخص را نام ببریم. در این مورد، `returns_summarizable` یک `SocialPost` برمی‌گرداند، اما کدی که این تابع را فراخوانی می‌کند نیازی به دانستن آن ندارد.

امکان مشخص کردن نوع بازگشتی فقط توسط ترییتی که پیاده‌سازی می‌کند به‌ویژه در زمینه کلوژرها و تکرارگرها (iterators) که در فصل سیزدهم پوشش می‌دهیم مفید است. کلوژرها و تکرارگرها نوع‌هایی ایجاد می‌کنند که فقط کامپایلر می‌داند یا نوع‌هایی که مشخص کردن آن‌ها بسیار طولانی است. نحو `impl Trait` به شما اجازه می‌دهد به‌صورت مختصر مشخص کنید که یک تابع نوعی را برمی‌گرداند که ترییت `Iterator` را پیاده‌سازی می‌کند بدون نیاز به نوشتن یک نوع بسیار طولانی.

با این حال، شما فقط می‌توانید از `impl Trait` استفاده کنید اگر یک نوع واحد را برمی‌گردانید. برای مثال، این کد که یا یک `NewsArticle` یا یک `SocialPost` را با نوع بازگشتی مشخص‌شده به‌عنوان `impl Summary` برمی‌گرداند، کار نخواهد کرد:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            repost: false,
        }
    }
}
```

برگرداندن یا یک `NewsArticle` یا یک `SocialPost` به دلیل محدودیت‌هایی در نحوه پیاده‌سازی نحو `impl Trait` در کامپایلر مجاز نیست. ما در بخش «استفاده از اشیاء ترییت که امکان استفاده از مقادیر نوع‌های مختلف را می‌دهند» در فصل هجدهم نحوه نوشتن تابعی با این رفتار را پوشش خواهیم داد.

## استفاده از محدودیت‌های ترییت برای پیاده‌سازی مشروط متدها

با استفاده از یک محدودیت ترییت با یک بلاک `impl` که از پارامترهای نوع Generic استفاده می‌کند، می‌توانیم متدها را به‌صورت مشروط برای نوع‌هایی که ترییت‌های مشخص‌شده را پیاده‌سازی می‌کنند پیاده‌سازی کنیم. برای مثال، نوع `Pair<T>` در **جدول 10-15** همیشه تابع `new` را برای برگرداندن یک نمونه جدید از `Pair<T>` پیاده‌سازی می‌کند (به خاطر بیاورید از بخش «تعریف متدها» در فصل پنجم که `Self` یک نام مستعار نوع برای نوع بلاک `impl` است، که در این مورد `Pair<T>` است). اما در بلاک `impl` بعدی، `Pair<T>` فقط متد `cmp_display` را پیاده‌سازی می‌کند اگر نوع داخلی آن `T` ترییت `PartialOrd` را که امکان مقایسه را فراهم می‌کند و ترییت `Display` را که امکان چاپ را فراهم می‌کند پیاده‌سازی کرده باشد.

**فایل: src/lib.rs**

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

**جدول 10-15**: پیاده‌سازی مشروط متدها روی یک نوع Generic بسته به محدودیت‌های ترییت

ما همچنین می‌توانیم یک ترییت را به‌صورت مشروط برای هر نوع که یک ترییت دیگر را پیاده‌سازی می‌کند پیاده‌سازی کنیم. پیاده‌سازی‌های یک ترییت روی هر نوع که محدودیت‌های ترییت را برآورده کند، **پیاده‌سازی‌های عمومی (blanket implementations)** نامیده می‌شوند و به‌طور گسترده در کتابخانه استاندارد **Rust** استفاده می‌شوند. برای مثال، کتابخانه استاندارد ترییت `ToString` را روی هر نوع که ترییت `Display` را پیاده‌سازی می‌کند پیاده‌سازی می‌کند. بلاک `impl` در کتابخانه استاندارد شبیه به این کد است:

```rust
impl<T: Display> ToString for T {
    // --قطعه کد حذف شده--
}
```

چون کتابخانه استاندارد این پیاده‌سازی عمومی را دارد، ما می‌توانیم متد `to_string` تعریف‌شده توسط ترییت `ToString` را روی هر نوع که ترییت `Display` را پیاده‌سازی می‌کند فراخوانی کنیم. برای مثال، می‌توانیم اعداد صحیح را به مقادیر رشته‌ای متناظرشان تبدیل کنیم مانند این چون اعداد صحیح `Display` را پیاده‌سازی می‌کنند:

```rust
let s = 3.to_string();
```

پیاده‌سازی‌های عمومی در مستندات ترییت در بخش «پیاده‌سازها (Implementors)» ظاهر می‌شوند.

ترییت‌ها و محدودیت‌های ترییت به ما اجازه می‌دهند کدی بنویسیم که از پارامترهای نوع Generic برای کاهش تکرار استفاده می‌کند اما همچنین به کامپایلر مشخص می‌کند که می‌خواهیم نوع Generic رفتار خاصی داشته باشد. سپس کامپایلر می‌تواند از اطلاعات محدودیت ترییت برای بررسی اینکه همه نوع‌های مشخص استفاده‌شده با کد ما رفتار درست را ارائه می‌دهند استفاده کند. در زبان‌های تایپ پویا، اگر متدی را روی نوعی فراخوانی کنیم که آن متد را تعریف نکرده باشد، در زمان اجرا خطا دریافت می‌کنیم. اما **Rust** این خطاها را به زمان کامپایل منتقل می‌کند تا مجبور شویم مشکلات را قبل از اینکه کد ما حتی بتواند اجرا شود رفع کنیم. علاوه بر این، نیازی به نوشتن کدی که رفتار را در زمان اجرا بررسی می‌کند نداریم زیرا قبلاً در زمان کامپایل بررسی کرده‌ایم. این کار عملکرد را بهبود می‌بخشد بدون اینکه انعطاف‌پذیری Generic‌ها را از دست بدهیم.
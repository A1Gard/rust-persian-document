# به `panic!` یا نه به `panic!`

چگونه تصمیم می‌گیرید که چه زمانی باید `panic!` را فراخوانی کنید و چه زمانی باید `Result` را برگردانید؟ وقتی کد دچار `panic!` می‌شود، هیچ راهی برای بازیابی وجود ندارد. می‌توانید برای هر موقعیت خطایی، چه قابل بازیابی باشد و چه نباشد، `panic!` را فراخوانی کنید، اما در این صورت، شما به‌جای کد فراخواننده تصمیم می‌گیرید که یک موقعیت غیرقابل بازیابی است. وقتی انتخاب می‌کنید که یک مقدار `Result` برگردانید، به کد فراخواننده گزینه‌هایی می‌دهید. کد فراخواننده می‌تواند تصمیم بگیرد که به روشی مناسب برای موقعیت خود تلاش کند تا خطا را بازیابی کند، یا ممکن است تصمیم بگیرد که مقدار `Err` در این مورد غیرقابل بازیابی است، بنابراین می‌تواند `panic!` را فراخوانی کند و خطای قابل بازیابی شما را به یک خطای غیرقابل بازیابی تبدیل کند. بنابراین، برگرداندن `Result` یک انتخاب پیش‌فرض خوب است وقتی تابعی را تعریف می‌کنید که ممکن است شکست بخورد.

در موقعیت‌هایی مانند مثال‌ها، کدهای پروتوتایپ، و تست‌ها، نوشتن کدی که به‌جای برگرداندن `Result` دچار `panic!` می‌شود مناسب‌تر است. بیایید بررسی کنیم چرا، سپس موقعیت‌هایی را بحث کنیم که کامپایلر نمی‌تواند تشخیص دهد شکست غیرممکن است، اما شما به‌عنوان یک انسان می‌توانید. این فصل با چند دستورالعمل کلی درباره اینکه آیا باید در کد کتابخانه‌ای `panic!` کنید یا خیر، به پایان می‌رسد.

## مثال‌ها، کدهای پروتوتایپ، و تست‌ها

وقتی در حال نوشتن یک مثال برای نشان دادن یک مفهوم هستید، افزودن کد مدیریت خطای قوی می‌تواند مثال را کمتر واضح کند. در مثال‌ها، فرض بر این است که فراخوانی متدی مانند `unwrap` که ممکن است دچار `panic!` شود، به‌عنوان یک جای‌نگهدار برای روشی است که می‌خواهید برنامه شما خطاها را مدیریت کند، که می‌تواند بسته به کاری که بقیه کد شما انجام می‌دهد متفاوت باشد.

به‌طور مشابه، متدهای `unwrap` و `expect` هنگام پروتوتایپ کردن بسیار مفید هستند، قبل از اینکه آماده باشید تصمیم بگیرید چگونه خطاها را مدیریت کنید. آن‌ها نشانه‌های واضحی در کد شما باقی می‌گذارند برای زمانی که آماده هستید برنامه خود را قوی‌تر کنید.

اگر یک فراخوانی متد در یک تست شکست بخورد، شما می‌خواهید کل تست شکست بخورد، حتی اگر آن متد عملکردی که در حال تست است نباشد. از آنجا که `panic!` روشی است که یک تست به‌عنوان شکست علامت‌گذاری می‌شود، فراخوانی `unwrap` یا `expect` دقیقاً همان چیزی است که باید رخ دهد.

## مواردی که اطلاعات بیشتری نسبت به کامپایلر دارید

همچنین مناسب است که از `unwrap` یا `expect` استفاده کنید وقتی منطقی دارید که تضمین می‌کند `Result` یک مقدار `Ok` خواهد داشت، اما این منطق چیزی نیست که کامپایلر بفهمد. شما همچنان یک مقدار `Result` خواهید داشت که باید مدیریت کنید: عملیاتی که فراخوانی می‌کنید همچنان به‌طور کلی امکان شکست دارد، حتی اگر در موقعیت خاص شما از نظر منطقی غیرممکن باشد. اگر با بررسی دستی کد بتوانید مطمئن شوید که هرگز واریانت `Err` نخواهید داشت، استفاده از `unwrap` کاملاً قابل قبول است، و حتی بهتر است که دلیل اینکه فکر می‌کنید هرگز واریانت `Err` نخواهید داشت را در متن `expect` مستند کنید. در اینجا یک مثال آورده شده است:

```rust
use std::net::IpAddr;

// این کد یک آدرس IP هاردکد شده را تجزیه می‌کند!
let home: IpAddr = "127.0.0.1"
    .parse()
    .expect("Hardcoded IP address should be valid");
```

ما یک نمونه `IpAddr` با تجزیه یک رشته هاردکد شده ایجاد می‌کنیم. می‌بینیم که `127.0.0.1` یک آدرس IP معتبر است، بنابراین استفاده از `expect` در اینجا قابل قبول است. با این حال، داشتن یک رشته هاردکد شده و معتبر نوع بازگشتی متد `parse` را تغییر نمی‌دهد: ما همچنان یک مقدار `Result` دریافت می‌کنیم، و کامپایلر همچنان ما را مجبور می‌کند که `Result` را طوری مدیریت کنیم که گویی واریانت `Err` ممکن است، زیرا کامپایلر به اندازه کافی هوشمند نیست که ببیند این رشته همیشه یک آدرس IP معتبر است. اگر رشته آدرس IP از کاربر دریافت می‌شد به‌جای اینکه در برنامه هاردکد شده باشد و بنابراین احتمال شکست وجود داشت، قطعاً می‌خواستیم `Result` را به روش قوی‌تری مدیریت کنیم. ذکر این فرض که این آدرس IP هاردکد شده است، ما را ترغیب می‌کند که در آینده، اگر نیاز باشد آدرس IP را از منبع دیگری بگیریم، `expect` را به کد مدیریت خطای بهتری تغییر دهیم.

## دستورالعمل‌های مدیریت خطا

توصیه می‌شود که کد شما وقتی ممکن است به یک **حالت بد** (bad state) برسد، دچار `panic!` شود. در این زمینه، یک **حالت بد** زمانی است که برخی فرض‌ها، تضمین‌ها، قراردادها، یا شرایط تغییرناپذیر شکسته شده‌اند، مانند وقتی مقادیر نامعتبر، مقادیر متناقض، یا مقادیر گم‌شده به کد شما منتقل می‌شوند—به علاوه یک یا چند مورد از موارد زیر:

- **حالت بد** چیزی است که غیرمنتظره است، برخلاف چیزی که احتمالاً به‌صورت گهگاهی رخ می‌دهد، مانند ورود داده توسط کاربر در فرمت اشتباه.
- کد شما پس از این نقطه نیاز دارد که به نبودن در این **حالت بد** وابسته باشد، به‌جای اینکه در هر مرحله مشکل را بررسی کند.
- راه خوبی برای کدگذاری این اطلاعات در نوع‌هایی که استفاده می‌کنید وجود ندارد. ما مثالی از این موضوع را در بخش «کدگذاری حالت‌ها و رفتارها به‌عنوان نوع‌ها» در فصل هجدهم بررسی خواهیم کرد.

اگر کسی کد شما را فراخوانی کند و مقادیری را منتقل کند که منطقی نیستند، بهتر است اگر می‌توانید یک خطا برگردانید تا کاربر کتابخانه بتواند تصمیم بگیرد در این مورد چه کند. با این حال، در مواردی که ادامه دادن ممکن است ناامن یا مضر باشد، بهترین انتخاب ممکن است فراخوانی `panic!` و هشدار به شخصی که از کتابخانه شما استفاده می‌کند درباره باگ در کدشان باشد تا بتوانند آن را در طول توسعه رفع کنند. به‌طور مشابه، `panic!` اغلب مناسب است اگر شما کدی خارجی را فراخوانی می‌کنید که خارج از کنترل شماست و حالتی نامعتبر برمی‌گرداند که هیچ راهی برای رفع آن ندارید.

با این حال، وقتی شکست مورد انتظار است، برگرداندن یک `Result` به‌جای فراخوانی `panic!` مناسب‌تر است. مثال‌هایی شامل تجزیه‌کننده‌ای که داده‌های نادرست دریافت می‌کند یا درخواستی HTTP که وضعیتی را برمی‌گرداند که نشان می‌دهد شما به محدودیت نرخ رسیده‌اید. در این موارد، برگرداندن یک `Result` نشان می‌دهد که شکست یک امکان مورد انتظار است که کد فراخواننده باید تصمیم بگیرد چگونه آن را مدیریت کند.

وقتی کد شما عملیاتی را انجام می‌دهد که اگر با مقادیر نامعتبر فراخوانی شود ممکن است کاربر را در معرض خطر قرار دهد، کد شما باید ابتدا بررسی کند که مقادیر معتبر هستند و اگر مقادیر معتبر نباشند، دچار `panic!` شود. این عمدتاً به دلایل ایمنی است: تلاش برای عملیات روی داده‌های نامعتبر می‌تواند کد شما را در برابر آسیب‌پذیری‌ها قرار دهد. این دلیل اصلی است که کتابخانه استاندارد اگر شما سعی کنید به حافظه‌ای خارج از محدوده دسترسی کنید، `panic!` را فراخوانی می‌کند: تلاش برای دسترسی به حافظه‌ای که متعلق به ساختار داده فعلی نیست، یک مشکل امنیتی رایج است. توابع اغلب **قراردادهایی** دارند: رفتار آن‌ها فقط در صورتی تضمین می‌شود که ورودی‌ها شرایط خاصی را برآورده کنند. وقتی قرارداد نقض می‌شود، `panic!` منطقی است زیرا نقض قرارداد همیشه نشان‌دهنده یک باگ در سمت فراخواننده است، و این نوع خطایی نیست که بخواهید کد فراخواننده به‌صورت صریح مدیریت کند. در واقع، هیچ راه معقولی برای کد فراخواننده برای بازیابی وجود ندارد؛ برنامه‌نویسان فراخواننده نیاز دارند که کد را اصلاح کنند. قراردادهای یک تابع، به‌ویژه وقتی نقض آن‌ها باعث `panic!` می‌شود، باید در مستندات API تابع توضیح داده شوند.

با این حال، داشتن بررسی‌های خطای زیاد در همه توابع شما می‌تواند طولانی و آزاردهنده باشد. خوشبختانه، می‌توانید از سیستم نوع **Rust** (و در نتیجه بررسی نوع توسط کامپایلر) استفاده کنید تا بسیاری از بررسی‌ها را برای شما انجام دهد. اگر تابع شما پارامتری با نوع خاصی داشته باشد، می‌توانید با منطق کد خود پیش بروید با این اطمینان که کامپایلر قبلاً تضمین کرده است که شما یک مقدار معتبر دارید. برای مثال، اگر یک نوع به‌جای یک `Option` داشته باشید، برنامه شما انتظار دارد چیزی داشته باشد به‌جای هیچ‌چیز. کد شما سپس نیازی به مدیریت دو مورد برای واریانت‌های `Some` و `None` ندارد: فقط یک مورد برای داشتن قطعی یک مقدار خواهد داشت. کدی که سعی کند هیچ‌چیز به تابع شما منتقل کند حتی کامپایل نخواهد شد، بنابراین تابع شما نیازی به بررسی این مورد در زمان اجرا ندارد. مثال دیگر استفاده از یک نوع عدد صحیح بدون علامت مانند `u32` است که تضمین می‌کند پارامتر هرگز منفی نیست.

## ایجاد نوع‌های سفارشی برای اعتبارسنجی

بیایید ایده استفاده از سیستم نوع **Rust** برای اطمینان از داشتن یک مقدار معتبر را یک گام جلوتر ببریم و به ایجاد یک نوع سفارشی برای اعتبارسنجی نگاه کنیم. بازی حدس زدن در فصل دوم را به خاطر بیاورید که در آن کد ما از کاربر می‌خواست عددی بین 1 و 100 حدس بزند. ما هرگز بررسی نکردیم که حدس کاربر بین این اعداد باشد قبل از اینکه آن را با عدد مخفی خود مقایسه کنیم؛ فقط بررسی کردیم که حدس مثبت باشد. در این مورد، عواقب چندان جدی نبودند: خروجی ما از «بیش از حد بالا» یا «بیش از حد پایین» همچنان درست بود. اما افزودن این امکان که کاربر را به سمت حدس‌های معتبر هدایت کنیم و رفتار متفاوتی داشته باشیم وقتی کاربر عددی خارج از محدوده حدس می‌زند در مقابل وقتی کاربر، برای مثال، حروف تایپ می‌کند، یک بهبود مفید خواهد بود.

یک راه برای انجام این کار این است که حدس را به‌عنوان یک `i32` به‌جای فقط یک `u32` تجزیه کنیم تا امکان اعداد منفی فراهم شود، و سپس بررسی کنیم که عدد در محدوده باشد، مانند این:

**فایل: src/main.rs**

```rust
loop {
    // --قطعه کد حذف شده--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
        // --قطعه کد حذف شده--
    }
}
```

عبارت `if` بررسی می‌کند که آیا مقدار ما خارج از محدوده است، به کاربر درباره مشکل اطلاع می‌دهد، و `continue` را فراخوانی می‌کند تا تکرار بعدی حلقه را شروع کند و یک حدس دیگر بخواهد. بعد از عبارت `if`، می‌توانیم با مقایسه‌های بین `guess` و عدد مخفی ادامه دهیم با این اطمینان که `guess` بین 1 و 100 است.

با این حال، این راه‌حل ایده‌آل نیست: اگر کاملاً حیاتی بود که برنامه فقط روی مقادیر بین 1 و 100 کار کند، و بسیاری از توابع این نیاز را داشتند، داشتن چنین بررسی‌ای در هر تابع خسته‌کننده می‌بود (و ممکن بود روی عملکرد تأثیر بگذارد).

به‌جای آن، می‌توانیم یک نوع جدید در یک ماژول اختصاصی بسازیم و اعتبارسنجی‌ها را در یک تابع برای ایجاد یک نمونه از نوع قرار دهیم به‌جای تکرار اعتبارسنجی‌ها در همه جا. به این ترتیب، توابع می‌توانند با اطمینان از نوع جدید در امضاهای خود استفاده کنند و از مقادیر دریافتی استفاده کنند. **جدول 9-13** یک روش برای تعریف یک نوع `Guess` را نشان می‌دهد که فقط در صورتی نمونه‌ای از `Guess` ایجاد می‌کند که تابع `new` مقداری بین 1 و 100 دریافت کند.

**فایل: src/guessing_game.rs**

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    // این تابع یک نمونه جدید از Guess ایجاد می‌کند!
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    // این متد مقدار Guess را برمی‌گرداند!
    pub fn value(&self) -> i32 {
        self.value
    }
}
```

**جدول 9-13**: نوع `Guess` که فقط با مقادیر بین 1 و 100 ادامه می‌دهد

ابتدا یک ماژول جدید به نام `guessing_game` ایجاد می‌کنیم. سپس یک ساختار به نام `Guess` در آن ماژول تعریف می‌کنیم که یک فیلد به نام `value` دارد که یک `i32` را نگه می‌دارد. اینجا جایی است که عدد ذخیره خواهد شد.

سپس یک تابع مرتبط به نام `new` روی `Guess` پیاده‌سازی می‌کنیم که نمونه‌هایی از مقادیر `Guess` ایجاد می‌کند. تابع `new` تعریف شده است که یک پارامتر به نام `value` از نوع `i32` دارد و یک `Guess` برمی‌گرداند. کد در بدنه تابع `new` مقدار `value` را آزمایش می‌کند تا مطمئن شود بین 1 و 100 است. اگر `value` این آزمایش را نگذراند، یک فراخوانی `panic!` انجام می‌دهیم که به برنامه‌نویسی که کد فراخواننده را می‌نویسد هشدار می‌دهد که باگی دارند که باید رفع کنند، زیرا ایجاد یک `Guess` با مقداری خارج از این محدوده قرارداد تابع `Guess::new` را نقض می‌کند. شرایطی که `Guess::new` ممکن است در آن‌ها `panic!` کند باید در مستندات API عمومی آن بحث شود؛ ما قراردادهای مستندسازی که احتمال `panic!` را نشان می‌دهند در مستندات API که در فصل چهاردهم ایجاد می‌کنید، پوشش خواهیم داد. اگر `value` آزمایش را بگذراند، یک `Guess` جدید با فیلد `value` تنظیم‌شده روی پارامتر `value` ایجاد می‌کنیم و `Guess` را برمی‌گردانیم.

در ادامه، یک متد به نام `value` پیاده‌سازی می‌کنیم که `self` را قرض می‌گیرد، هیچ پارامتر دیگری ندارد، و یک `i32` برمی‌گرداند. این نوع متد گاهی اوقات **getter** نامیده می‌شود زیرا هدفش دریافت برخی داده‌ها از فیلدهایش و برگرداندن آن است. این متد عمومی ضروری است زیرا فیلد `value` ساختار `Guess` خصوصی است. مهم است که فیلد `value` خصوصی باشد تا کدی که از ساختار `Guess` استفاده می‌کند اجازه نداشته باشد `value` را مستقیماً تنظیم کند: کد خارج از ماژول `guessing_game` باید از تابع `Guess::new` برای ایجاد یک نمونه از `Guess` استفاده کند، در نتیجه هیچ راهی برای یک `Guess` وجود ندارد که مقداری داشته باشد که توسط شرایط در تابع `Guess::new` بررسی نشده باشد.

تابعی که پارامتری دارد یا فقط اعداد بین 1 و 100 را برمی‌گرداند، می‌تواند در امضای خود اعلام کند که یک `Guess` می‌گیرد یا برمی‌گرداند به‌جای یک `i32` و نیازی به انجام هیچ بررسی اضافی در بدنه خود ندارد.

## خلاصه

ویژگی‌های مدیریت خطای **Rust** طراحی شده‌اند تا به شما کمک کنند کد قوی‌تری بنویسید. ماکروی `panic!` نشان می‌دهد که برنامه شما در حالتی است که نمی‌تواند مدیریت کند و به شما اجازه می‌دهد به فرآیند بگویید که به‌جای تلاش برای ادامه با مقادیر نامعتبر یا نادرست، متوقف شود. انوم `Result` از سیستم نوع **Rust** استفاده می‌کند تا نشان دهد که عملیات‌ها ممکن است به روشی شکست بخورند که کد شما بتواند از آن بازیابی کند. می‌توانید از `Result` برای گفتن به کدی که کد شما را فراخوانی می‌کند استفاده کنید که باید موفقیت یا شکست احتمالی را مدیریت کند. استفاده از `panic!` و `Result` در موقعیت‌های مناسب کد شما را در برابر مشکلات اجتناب‌ناپذیر قابل اعتمادتر می‌کند.

اکنون که روش‌های مفیدی که کتابخانه استاندارد از Generic‌ها با انوم‌های `Option` و `Result` استفاده می‌کند را دیده‌اید، درباره اینکه Generic‌ها چگونه کار می‌کنند و چگونه می‌توانید از آن‌ها در کد خود استفاده کنید، صحبت خواهیم کرد.
## تعریف یک شمارش

در حالی که ساختارها به شما راهی برای گروه‌بندی فیلدها و داده‌های مرتبط، مانند یک `Rectangle` با عرض و ارتفاع آن، ارائه می‌دهند، شمارش‌ها (enums) به شما امکان می‌دهند بگویید یک مقدار یکی از مجموعه‌ای از مقادیر ممکن است. برای مثال، ممکن است بخواهیم بگوییم `Rectangle` یکی از مجموعه‌ای از اشکال ممکن است که شامل `Circle` و `Triangle` نیز می‌شود. برای این کار، Rust به ما اجازه می‌دهد این امکانات را به‌عنوان یک شمارش کدگذاری کنیم.

بیایید به موقعیتی نگاه کنیم که ممکن است بخواهیم در کد بیان کنیم و ببینیم چرا شمارش‌ها در این مورد مفید و مناسب‌تر از ساختارها هستند. فرض کنید نیاز داریم با آدرس‌های IP کار کنیم. در حال حاضر، دو استاندارد اصلی برای آدرس‌های IP استفاده می‌شود: نسخه چهار (IPv4) و نسخه شش (IPv6). از آنجا که این‌ها تنها امکانات برای یک آدرس IP هستند که برنامه ما با آن‌ها مواجه خواهد شد، می‌توانیم تمام انواع ممکن را برشمریم، که از اینجا نام «شمارش» گرفته شده است.

هر آدرس IP می‌تواند یا یک آدرس نسخه چهار باشد یا یک آدرس نسخه شش، اما نه هر دو به‌طور همزمان. این ویژگی آدرس‌های IP باعث می‌شود ساختار داده‌ای شمارش مناسب باشد، زیرا مقدار یک شمارش فقط می‌تواند یکی از انواع آن باشد. هر دو آدرس نسخه چهار و نسخه شش اساساً آدرس‌های IP هستند، بنابراین وقتی کد با موقعیت‌هایی سروکار دارد که برای هر نوع آدرس IP اعمال می‌شود، باید به‌عنوان یک نوع یکسان در نظر گرفته شوند.

ما می‌توانیم این مفهوم را در کد با تعریف یک شمارش `IpAddrKind` و فهرست کردن انواع ممکنی که یک آدرس IP می‌تواند باشد، یعنی `V4` و `V6`، بیان کنیم. این‌ها انواع (variants) شمارش هستند:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

`IpAddrKind` حالا یک نوع داده سفارشی است که می‌توانیم در جاهای دیگر کدمان از آن استفاده کنیم.

### مقادیر شمارش

ما می‌توانیم نمونه‌هایی از هر یک از دو نوع `IpAddrKind` به این صورت ایجاد کنیم:

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

توجه کنید که انواع شمارش تحت شناسه آن فضای نام‌گذاری شده‌اند، و ما از دو نقطه (double colon) برای جداسازی این دو استفاده می‌کنیم. این مفید است زیرا حالا هر دو مقدار `IpAddrKind::V4` و `IpAddrKind::V6` از یک نوع هستند: `IpAddrKind`. سپس می‌توانیم، برای مثال، تابعی تعریف کنیم که هر `IpAddrKind` را بپذیرد:

```rust
fn route(ip_kind: IpAddrKind) {}
```

و می‌توانیم این تابع را با هر یک از انواع فراخوانی کنیم:

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

استفاده از شمارش‌ها مزایای بیشتری دارد. با فکر کردن بیشتر درباره نوع آدرس IP ما، در حال حاضر راهی برای ذخیره داده واقعی آدرس IP نداریم؛ فقط می‌دانیم چه نوع است. با توجه به اینکه در فصل پنجم درباره ساختارها یاد گرفتید، ممکن است وسوسه شوید که این مشکل را با ساختارها حل کنید، همان‌طور که در لیست ۶-۱ نشان داده شده است.

```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```

**لیست ۶-۱:** ذخیره داده و نوع `IpAddrKind` یک آدرس IP با استفاده از یک ساختار

در اینجا، ما یک ساختار `IpAddr` تعریف کردیم که دو فیلد دارد: یک فیلد `kind` از نوع `IpAddrKind` (شمارشی که قبلاً تعریف کردیم) و یک فیلد `address` از نوع `String`. ما دو نمونه از این ساختار داریم. اولی `home` است، و مقدار `IpAddrKind::V4` را به‌عنوان `kind` با داده آدرس مرتبط `127.0.0.1` دارد. نمونه دوم `loopback` است. این نمونه نوع دیگر `IpAddrKind` را به‌عنوان مقدار `kind` خود دارد، یعنی `V6`، و آدرس `::1` به آن مرتبط است. ما از یک ساختار برای بسته‌بندی مقادیر `kind` و `address` با هم استفاده کردیم، بنابراین حالا نوع با مقدار مرتبط است.

با این حال، نمایش همان مفهوم فقط با استفاده از یک شمارش مختصرتر است: به‌جای یک شمارش داخل یک ساختار، می‌توانیم داده را مستقیماً در هر نوع شمارش قرار دهیم. این تعریف جدید از شمارش `IpAddr` می‌گوید که هر دو نوع `V4` و `V6` مقادیر `String` مرتبط خواهند داشت:

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

ما داده را مستقیماً به هر نوع شمارش متصل می‌کنیم، بنابراین نیازی به یک ساختار اضافی نیست. در اینجا، همچنین درک یک جزئیات دیگر از نحوه کار شمارش‌ها آسان‌تر است: نام هر نوع شمارش که تعریف می‌کنیم، خود به یک تابع سازنده تبدیل می‌شود که یک نمونه از شمارش را می‌سازد. یعنی، `IpAddr::V4()` یک فراخوانی تابع است که یک آرگومان `String` می‌گیرد و یک نمونه از نوع `IpAddr` برمی‌گرداند. ما به‌صورت خودکار این تابع سازنده را به‌عنوان نتیجه تعریف شمارش دریافت می‌کنیم.

مزیت دیگری برای استفاده از شمارش به‌جای ساختار وجود دارد: هر نوع می‌تواند نوع‌ها و مقادیر داده‌ای متفاوتی داشته باشد. آدرس‌های IP نسخه چهار همیشه چهار مؤلفه عددی خواهند داشت که مقادیر بین ۰ و ۲۵۵ دارند. اگر بخواهیم آدرس‌های `V4` را به‌عنوان چهار مقدار `u8` ذخیره کنیم اما همچنان آدرس‌های `V6` را به‌عنوان یک مقدار `String` بیان کنیم، با یک ساختار نمی‌توانستیم این کار را انجام دهیم. شمارش‌ها این مورد را به‌راحتی مدیریت می‌کنند:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

ما چندین راه مختلف برای تعریف ساختارهای داده‌ای برای ذخیره آدرس‌های IP نسخه چهار و شش نشان دادیم. با این حال، همان‌طور که مشخص است، تمایل به ذخیره آدرس‌های IP و کدگذاری نوع آن‌ها آن‌قدر رایج است که کتابخانه استاندارد تعریفی دارد که می‌توانیم از آن استفاده کنیم! بیایید ببینیم کتابخانه استاندارد چگونه `IpAddr` را تعریف می‌کند: دقیقاً همان شمارش و انواع را که ما تعریف و استفاده کردیم دارد، اما داده آدرس را در داخل انواع به‌صورت دو ساختار مختلف که برای هر نوع متفاوت تعریف شده‌اند، جای‌گذاری می‌کند:

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

این کد نشان می‌دهد که می‌توانید هر نوع داده‌ای را داخل یک نوع شمارش قرار دهید: برای مثال، رشته‌ها، نوع‌های عددی، یا ساختارها. حتی می‌توانید شمارش دیگری را شامل کنید! همچنین، نوع‌های کتابخانه استاندارد اغلب خیلی پیچیده‌تر از چیزی که ممکن است خودتان بسازید نیستند.

توجه کنید که حتی اگر کتابخانه استاندارد شامل تعریفی برای `IpAddr` باشد، ما همچنان می‌توانیم تعریف خودمان را ایجاد و استفاده کنیم بدون هیچ تعارضی، زیرا تعریف کتابخانه استاندارد را به حوزه (scope) خودمان وارد نکرده‌ایم. در فصل هفتم بیشتر درباره وارد کردن نوع‌ها به حوزه صحبت خواهیم کرد.

بیایید به مثال دیگری از یک شمارش در لیست ۶-۲ نگاه کنیم: این یکی انواع مختلفی از داده‌ها را در انواع خود جای داده است.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

**لیست ۶-۲:** یک شمارش `Message` که هر نوع آن مقادیر و نوع‌های مختلفی از داده‌ها را ذخیره می‌کند

این شمارش چهار نوع با نوع‌های مختلف دارد:

- `Quit` هیچ داده‌ای مرتبط با آن ندارد.
- `Move` شامل فیلدهای نام‌گذاری‌شده است، مانند یک ساختار.
- `Write` شامل یک `String` تکی است.
- `ChangeColor` شامل سه مقدار `i32` است.

تعریف یک شمارش با انواعی مانند آن‌هایی که در لیست ۶-۲ هستند شبیه به تعریف انواع مختلف تعریف‌های ساختار است، با این تفاوت که شمارش از کلمه‌کلیدی `struct` استفاده نمی‌کند و همه انواع تحت نوع `Message` گروه‌بندی شده‌اند. ساختارهای زیر می‌توانند همان داده‌هایی را که انواع شمارش قبلی نگه می‌دارند، نگه دارند:

```rust
struct QuitMessage; // ساختار شبه‌واحد
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // ساختار تاپلی
struct ChangeColorMessage(i32, i32, i32); // ساختار تاپلی
```

اما اگر از ساختارهای مختلف استفاده کنیم، که هر کدام نوع خاص خود را دارند، نمی‌توانیم به‌راحتی تابعی تعریف کنیم که هر یک از این انواع پیام‌ها را بپذیرد، همان‌طور که با شمارش `Message` تعریف‌شده در لیست ۶-۲، که یک نوع واحد است، می‌توانستیم.

یک شباهت دیگر بین شمارش‌ها و ساختارها وجود دارد: همان‌طور که می‌توانیم با استفاده از `impl` متدهایی روی ساختارها تعریف کنیم، می‌توانیم متدهایی روی شمارش‌ها نیز تعریف کنیم. در اینجا یک متد به نام `call` آورده شده است که می‌توانیم روی شمارش `Message` خود تعریف کنیم:

```rust
impl Message {
    fn call(&self) {
        // بدنه متد اینجا تعریف می‌شود
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

بدنه متد از `self` برای گرفتن مقداری که متد روی آن فراخوانی شده استفاده می‌کند. در این مثال، ما یک متغیر `m` ایجاد کردیم که مقدار `Message::Write(String::from("hello"))` را دارد، و این همان چیزی است که `self` در بدنه متد `call` خواهد بود وقتی `m.call()` اجرا شود.

بیایید به شمارش دیگری در کتابخانه استاندارد که بسیار رایج و مفید است نگاه کنیم: `Option`.

### شمارش `Option` و مزایای آن نسبت به مقادیر نال

این بخش یک مطالعه موردی از `Option` را بررسی می‌کند، که شمارش دیگری است که توسط کتابخانه استاندارد تعریف شده است. نوع `Option` سناریوی بسیار رایجی را کدگذاری می‌کند که در آن یک مقدار می‌تواند یا چیزی باشد یا هیچ‌چیز.

برای مثال، اگر اولین مورد را از یک لیست غیرخالی درخواست کنید، یک مقدار دریافت خواهید کرد. اگر اولین مورد را از یک لیست خالی درخواست کنید، هیچ‌چیز دریافت خواهید کرد. بیان این مفهوم از نظر سیستم نوع به این معناست که کامپایلر می‌تواند بررسی کند آیا شما تمام مواردی را که باید مدیریت کنید، مدیریت کرده‌اید؛ این قابلیت می‌تواند از باگ‌هایی که در زبان‌های برنامه‌نویسی دیگر بسیار رایج هستند جلوگیری کند.

طراحی زبان برنامه‌نویسی اغلب از نظر ویژگی‌هایی که شامل می‌کنید در نظر گرفته می‌شود، اما ویژگی‌هایی که حذف می‌کنید نیز مهم هستند. Rust ویژگی نال (null) را که بسیاری از زبان‌های دیگر دارند، ندارد. نال مقداری است که به این معناست که هیچ مقداری آنجا نیست. در زبان‌هایی با نال، متغیرها همیشه می‌توانند در یکی از دو حالت باشند: نال یا غیرنال.

در ارائه ۲۰۰۹ خود به نام «ارجاعات نال: اشتباه میلیارد دلاری»، تونی هوآر، مخترع نال، این را می‌گوید:

> من آن را اشتباه میلیارد دلاری خودم می‌نامم. در آن زمان، من در حال طراحی اولین سیستم نوع جامع برای ارجاعات در یک زبان شیءگرا بودم. هدفم این بود که اطمینان حاصل کنم تمام استفاده از ارجاعات کاملاً ایمن باشد، با بررسی‌هایی که به‌صورت خودکار توسط کامپایلر انجام می‌شود. اما نتوانستم در برابر وسوسه قرار دادن یک ارجاع نال مقاومت کنم، صرفاً به این دلیل که پیاده‌سازی آن خیلی آسان بود. این منجر به خطاها، آسیب‌پذیری‌ها و خرابی‌های سیستمی بی‌شماری شده است، که احتمالاً در چهل سال گذشته یک میلیارد دلار درد و آسیب ایجاد کرده است.

مشکل با مقادیر نال این است که اگر سعی کنید از یک مقدار نال به‌عنوان یک مقدار غیرنال استفاده کنید، نوعی خطا دریافت خواهید کرد. چون این ویژگی نال یا غیرنال بودن در همه جا وجود دارد، ایجاد این نوع خطا بسیار آسان است.

با این حال، مفهومی که نال سعی در بیان آن دارد همچنان مفید است: نال مقداری است که به دلیلی در حال حاضر نامعتبر یا غایب است.

مشکل واقعاً در مفهوم نیست بلکه در پیاده‌سازی خاص آن است. به همین دلیل، Rust نال ندارد، اما یک شمارش دارد که می‌تواند مفهوم حضور یا عدم حضور یک مقدار را کدگذاری کند. این شمارش `Option<T>` است، و توسط کتابخانه استاندارد به این صورت تعریف شده است:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

شمارش `Option<T>` آن‌قدر مفید است که حتی در پیش‌نیاز (prelude) گنجانده شده است؛ نیازی نیست آن را به‌صورت صریح به حوزه وارد کنید. انواع آن نیز در پیش‌نیاز گنجانده شده‌اند: می‌توانید از `Some` و `None` مستقیماً بدون پیشوند `Option::` استفاده کنید. شمارش `Option<T>` همچنان فقط یک شمارش معمولی است، و `Some(T)` و `None` همچنان انواع نوع `Option<T>` هستند.

نحو `<T>` ویژگی‌ای از Rust است که هنوز درباره آن صحبت نکرده‌ایم. این یک پارامتر نوع عمومی (generic type parameter) است، و ما در فصل دهم درباره عمومی‌ها با جزئیات بیشتری صحبت خواهیم کرد. فعلاً، فقط باید بدانید که `<T>` به این معناست که نوع `Some` از شمارش `Option` می‌تواند یک قطعه داده از هر نوع را نگه دارد، و هر نوع مشخصی که به‌جای `T` استفاده شود، نوع کلی `Option<T>` را به یک نوع متفاوت تبدیل می‌کند. در اینجا چند مثال از استفاده از مقادیر `Option` برای نگه داشتن نوع‌های عددی و نوع‌های کاراکتری آورده شده است:

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

نوع `some_number` برابر `Option<i32>` است. نوع `some_char` برابر `Option<char>` است، که یک نوع متفاوت است. Rust می‌تواند این نوع‌ها را استنباط کند زیرا ما مقداری را در نوع `Some` مشخص کرده‌ایم. برای `absent_number`، Rust از ما می‌خواهد نوع کلی `Option` را مشخص کنیم: کامپایلر نمی‌تواند نوع متناظر نوع `Some` را فقط با نگاه کردن به مقدار `None` استنباط کند. در اینجا، ما به Rust می‌گوییم که منظورمان این است که `absent_number` از نوع `Option<i32>` باشد.

وقتی یک مقدار `Some` داریم، می‌دانیم که یک مقدار وجود دارد و مقدار در داخل `Some` نگه داشته شده است. وقتی یک مقدار `None` داریم، به某معنایی همان معنای نال را دارد: ما مقدار معتبری نداریم. پس چرا داشتن `Option<T>` بهتر از داشتن نال است؟

به‌طور خلاصه، چون `Option<T>` و `T` (که `T` می‌تواند هر نوع باشد) نوع‌های متفاوتی هستند، کامپایلر به ما اجازه نمی‌دهد از یک مقدار `Option<T>` به‌عنوان یک مقدار معتبر قطعی استفاده کنیم. برای مثال، این کد کامپایل نمی‌شود، زیرا سعی دارد یک `i8` را با یک `Option<i8>` جمع کند:

**این کد کامپایل نمی‌شود!**

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

اگر این کد را اجرا کنیم، پیامی خطا مانند این دریافت می‌کنیم:

```bash
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
  = help: the following other types implement trait `Add<Rhs>`:
            `&i8` implements `Add<i8>`
            `&i8` implements `Add`
            `i8` implements `Add<&i8>`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
```

شدید! در واقع، این پیام خطا به این معناست که Rust نمی‌فهمد چگونه یک `i8` و یک `Option<i8>` را جمع کند، زیرا آن‌ها نوع‌های متفاوتی هستند. وقتی در Rust مقداری از نوع `i8` داریم، کامپایلر اطمینان می‌دهد که همیشه یک مقدار معتبر داریم. می‌توانیم با اطمینان ادامه دهیم بدون نیاز به بررسی نال بودن قبل از استفاده از آن مقدار. فقط وقتی یک `Option<i8>` (یا هر نوع مقدار دیگری که با آن کار می‌کنیم) داریم، باید نگران احتمال نداشتن مقدار باشیم، و کامپایلر اطمینان می‌دهد که ما این مورد را قبل از استفاده از مقدار مدیریت کنیم.

به عبارت دیگر، باید یک `Option<T>` را به یک `T` تبدیل کنید قبل از اینکه بتوانید عملیات‌های `T` را با آن انجام دهید. به‌طور کلی، این کمک می‌کند یکی از رایج‌ترین مشکلات نال را بگیرید: فرض اینکه چیزی نال نیست وقتی در واقع نال است.

حذف خطر فرض نادرست یک مقدار غیرنال به شما کمک می‌کند تا در کد خود اطمینان بیشتری داشته باشید. برای داشتن مقداری که ممکن است نال باشد، باید صراحتاً انتخاب کنید که نوع آن مقدار `Option<T>` باشد. سپس، وقتی از آن مقدار استفاده می‌کنید، باید صراحتاً مورد نال بودن مقدار را مدیریت کنید. هر جایی که یک مقدار نوعی دارد که `Option<T>` نیست، می‌توانید با اطمینان فرض کنید که مقدار نال نیست. این یک تصمیم طراحی عمدی برای Rust بود تا فراگیری نال را محدود کند و ایمنی کد Rust را افزایش دهد.

پس چگونه مقدار `T` را از نوع `Some` خارج می‌کنید وقتی مقداری از نوع `Option<T>` دارید تا بتوانید از آن مقدار استفاده کنید؟ شمارش `Option<T>` تعداد زیادی متد دارد که در موقعیت‌های مختلف مفید هستند؛ می‌توانید آن‌ها را در مستندات آن بررسی کنید. آشنا شدن با متدهای روی `Option<T>` در سفر شما با Rust بسیار مفید خواهد بود.

به‌طور کلی، برای استفاده از یک مقدار `Option<T>`، می‌خواهید کدی داشته باشید که هر نوع را مدیریت کند. می‌خواهید کدی داشته باشید که فقط وقتی مقدار `Some(T)` دارید اجرا شود، و این کد اجازه دارد از `T` داخلی استفاده کند. می‌خواهید کد دیگری فقط در صورتی اجرا شود که مقدار `None` دارید، و آن کد مقدار `T` در دسترس ندارد. عبارت `match` یک ساختار کنترل جریان است که دقیقاً این کار را با شمارش‌ها انجام می‌دهد: بسته به اینکه کدام نوع شمارش را دارد، کد متفاوتی اجرا می‌کند، و آن کد می‌تواند از داده داخل مقدار تطبیق‌یافته استفاده کند.


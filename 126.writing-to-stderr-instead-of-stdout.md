# نوشتن پیام‌های خطا به خروجی خطای استاندارد به جای خروجی استاندارد

در حال حاضر، تمام خروجی‌مان را با استفاده از ماکرو `println!` به ترمینال می‌نویسیم. در اکثر ترمینال‌ها، دو نوع خروجی وجود دارد: **خروجی استاندارد (stdout)** برای اطلاعات عمومی و **خطای استاندارد (stderr)** برای پیام‌های خطا. این تمایز به کاربران اجازه می‌دهد خروجی موفق یک برنامه را به یک فایل هدایت کنند اما همچنان پیام‌های خطا را روی صفحه ببینند.

ماکرو `println!` فقط قادر به چاپ به خروجی استاندارد است، بنابراین باید از چیز دیگری برای چاپ به خطای استاندارد استفاده کنیم.

## بررسی اینکه خطاها کجا نوشته می‌شوند

ابتدا بیایید مشاهده کنیم که محتوای چاپ‌شده توسط `minigrep` در حال حاضر به خروجی استاندارد نوشته می‌شود، از جمله پیام‌های خطایی که می‌خواهیم به جای آن به خطای استاندارد نوشته شوند. این کار را با هدایت جریان خروجی استاندارد به یک فایل انجام خواهیم داد در حالی که عمداً یک خطا ایجاد می‌کنیم. جریان خطای استاندارد را هدایت نخواهیم کرد، بنابراین هر محتوایی که به خطای استاندارد ارسال شود همچنان روی صفحه نمایش داده خواهد شد.

برنامه‌های خط فرمان انتظار می‌رود پیام‌های خطا را به جریان خطای استاندارد ارسال کنند تا حتی اگر جریان خروجی استاندارد را به یک فایل هدایت کنیم، همچنان پیام‌های خطا را روی صفحه ببینیم. برنامه ما در حال حاضر رفتار درستی ندارد: قرار است ببینیم که پیام خطا را به جای صفحه به یک فایل ذخیره می‌کند!

برای نشان دادن این رفتار، برنامه را با `>` و مسیر فایل `output.txt` اجرا خواهیم کرد که می‌خواهیم جریان خروجی استاندارد را به آن هدایت کنیم. هیچ آرگومانی پاس نخواهیم داد، که باید باعث خطا شود:

```bash
$ cargo run > output.txt
```

نحو `>` به پوسته می‌گوید که محتوای خروجی استاندارد را به جای صفحه به `output.txt` بنویسد. ما پیام خطایی که انتظار داشتیم روی صفحه چاپ شود را ندیدیم، بنابراین باید به این معنی باشد که در فایل قرار گرفته است. این چیزی است که `output.txt` شامل می‌شود:

```
Problem parsing arguments: not enough arguments
```

بله، پیام خطای ما به خروجی استاندارد چاپ می‌شود. برای پیام‌های خطا مانند این، بسیار مفیدتر است که به خطای استاندارد چاپ شوند تا فقط داده‌های حاصل از اجرای موفق در فایل قرار گیرند. بیایید این را تغییر دهیم.

## چاپ خطاها به خطای استاندارد

ما از کد موجود در **جدول 12-24** برای تغییر نحوه چاپ پیام‌های خطا استفاده خواهیم کرد. به دلیل بازسازی‌ای که قبلاً در این فصل انجام دادیم، تمام کدی که پیام‌های خطا را چاپ می‌کند در یک تابع، یعنی `main`، قرار دارد. کتابخانه استاندارد ماکرو `eprintln!` را فراهم می‌کند که به جریان خطای استاندارد چاپ می‌کند، بنابراین بیایید دو جایی که از `println!` برای چاپ خطاها استفاده می‌کردیم را به `eprintln!` تغییر دهیم.

**فایل: src/main.rs**

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

**جدول 12-24**: نوشتن پیام‌های خطا به خطای استاندارد به جای خروجی استاندارد با استفاده از `eprintln!`

حالا بیایید برنامه را دوباره به همان روش اجرا کنیم، بدون هیچ آرگومانی و با هدایت خروجی استاندارد با `>`:

```bash
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

حالا خطا را روی صفحه می‌بینیم و `output.txt` هیچ چیزی شامل نمی‌شود، که رفتار مورد انتظار از برنامه‌های خط فرمان است.

بیایید برنامه را دوباره با آرگومان‌هایی که باعث خطا نمی‌شوند اما همچنان خروجی استاندارد را به یک فایل هدایت می‌کنیم، اجرا کنیم:

```bash
$ cargo run -- to poem.txt > output.txt
```

ما هیچ خروجی‌ای به ترمینال نخواهیم دید، و `output.txt` نتایج ما را شامل خواهد شد:

**فایل: output.txt**

```
Are you nobody, too?
How dreary to be somebody!
```

این نشان می‌دهد که ما حالا از خروجی استاندارد برای خروجی موفق و خطای استاندارد برای خروجی خطا به‌صورت مناسب استفاده می‌کنیم.

## خلاصه

این فصل برخی از مفاهیم اصلی که تاکنون آموخته‌اید را مرور کرد و نحوه انجام عملیات ورودی/خروجی رایج در **Rust** را پوشش داد. با استفاده از آرگومان‌های خط فرمان، فایل‌ها، متغیرهای محیطی، و ماکرو `eprintln!` برای چاپ خطاها، شما حالا آماده نوشتن برنامه‌های خط فرمان هستید. با ترکیب مفاهیم فصول قبلی، کد شما به‌خوبی سازمان‌دهی خواهد شد، داده‌ها را به‌طور مؤثر در ساختارهای داده مناسب ذخیره خواهد کرد، خطاها را به‌خوبی مدیریت خواهد کرد، و به‌خوبی تست خواهد شد.

در ادامه، برخی از ویژگی‌های **Rust** که تحت تأثیر زبان‌های تابعی هستند را بررسی خواهیم کرد: بسته‌بندی‌ها (closures) و تکرارسازها (iterators).
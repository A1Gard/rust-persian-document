# توابع و کلوژرهای پیشرفته

این بخش برخی از ویژگی‌های پیشرفته مرتبط با توابع و کلوژرها را بررسی می‌کند، از جمله اشاره‌گرهای تابع و بازگرداندن کلوژرها.

## اشاره‌گرهای تابع

ما درباره نحوه پاس دادن کلوژرها به توابع صحبت کرده‌ایم؛ شما همچنین می‌توانید توابع معمولی را به توابع پاس دهید! این تکنیک زمانی مفید است که بخواهید تابعی که قبلاً تعریف کرده‌اید را پاس دهید به‌جای اینکه یک کلوژر جدید تعریف کنید. توابع به نوع `fn` (با `f` کوچک) تبدیل می‌شوند، که نباید با ویژگی کلوژر `Fn` اشتباه گرفته شود. نوع `fn` به‌عنوان **اشاره‌گر تابع (function pointer)** شناخته می‌شود. پاس دادن توابع با اشاره‌گرهای تابع به شما امکان می‌دهد از توابع به‌عنوان آرگومان برای توابع دیگر استفاده کنید.

نحو برای مشخص کردن اینکه یک پارامتر یک اشاره‌گر تابع است، شبیه به کلوژرهاست، همان‌طور که در Listing 20-28 نشان داده شده است، جایی که ما یک تابع `add_one` تعریف کرده‌ایم که 1 به پارامتر خود اضافه می‌کند. تابع `do_twice` دو پارامتر می‌گیرد: یک اشاره‌گر تابع به هر تابعی که یک پارامتر `i32` می‌گیرد و یک `i32` برمی‌گرداند، و یک مقدار `i32`. تابع `do_twice` تابع `f` را دو بار فراخوانی می‌کند، مقدار `arg` را به آن پاس می‌دهد، سپس نتایج دو فراخوانی تابع را با هم جمع می‌کند. تابع `main` تابع `do_twice` را با آرگومان‌های `add_one` و 5 فراخوانی می‌کند.

**فایل: src/main.rs**

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("پاسخ برابر است با: {}", answer); // The answer is: {}
}
```

**Listing 20-28: استفاده از نوع fn برای پذیرش یک اشاره‌گر تابع به‌عنوان آرگومان**

این کد «پاسخ برابر است با: 12» را چاپ می‌کند. ما مشخص می‌کنیم که پارامتر `f` در `do_twice` یک `fn` است که یک پارامتر از نوع `i32` می‌گیرد و یک `i32` برمی‌گرداند. سپس می‌توانیم `f` را در بدنه `do_twice` فراخوانی کنیم. در `main`، می‌توانیم نام تابع `add_one` را به‌عنوان آرگومان اول به `do_twice` پاس دهیم.

برخلاف کلوژرها، `fn` یک نوع است، نه یک ویژگی، بنابراین ما `fn` را مستقیماً به‌عنوان نوع پارامتر مشخص می‌کنیم به‌جای اینکه یک پارامتر نوع Generic با یکی از ویژگی‌های کلوژر (`Fn`) به‌عنوان قید ویژگی اعلان کنیم.

اشاره‌گرهای تابع هر سه ویژگی کلوژر (`Fn`، `FnMut`، و `FnOnce`) را پیاده‌سازی می‌کنند، به این معنا که همیشه می‌توانید یک اشاره‌گر تابع را به‌عنوان آرگومان برای تابعی که انتظار یک کلوژر دارد پاس دهید. بهتر است توابع را با استفاده از یک نوع Generic و یکی از ویژگی‌های کلوژر بنویسید تا توابع شما بتوانند هم توابع و هم کلوژرها را بپذیرند.

با این حال، یک مثال از جایی که ممکن است بخواهید فقط `fn` را بپذیرید و نه کلوژرها، زمانی است که با کد خارجی که کلوژر ندارد تعامل می‌کنید: توابع C می‌توانند توابع را به‌عنوان آرگومان بپذیرند، اما C کلوژر ندارد.

به‌عنوان مثالی از جایی که می‌توانید از یک کلوژر تعریف‌شده به‌صورت داخلی یا یک تابع نام‌گذاری‌شده استفاده کنید، بیایید به استفاده از متد `map` که توسط ویژگی `Iterator` در کتابخانه استاندارد ارائه شده است نگاه کنیم. برای استفاده از متد `map` برای تبدیل یک بردار از اعداد به یک بردار از رشته‌ها، می‌توانیم از یک کلوژر استفاده کنیم، همان‌طور که در Listing 20-29 نشان داده شده است.

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> =
    list_of_numbers.iter().map(|i| i.to_string()).collect();
```

**Listing 20-29: استفاده از یک کلوژر با متد map برای تبدیل اعداد به رشته‌ها**

یا می‌توانیم یک تابع را به‌عنوان آرگومان به `map` به‌جای کلوژر نام‌گذاری کنیم. Listing 20-30 نشان می‌دهد که این چگونه به نظر می‌رسد.

```rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> =
    list_of_numbers.iter().map(ToString::to_string).collect();
```

**Listing 20-30: استفاده از متد String::to_string برای تبدیل اعداد به رشته‌ها**

توجه کنید که باید از نحو کاملاً مشخص که در بخش «ویژگی‌های پیشرفته» درباره آن صحبت کردیم استفاده کنیم زیرا چندین تابع به نام `to_string` در دسترس هستند.

در اینجا، ما از تابع `to_string` که در ویژگی `ToString` تعریف شده است استفاده می‌کنیم، که کتابخانه استاندارد آن را برای هر نوعی که `Display` را پیاده‌سازی می‌کند، پیاده‌سازی کرده است.

از بخش «مقادیر انوم» در فصل ششم به یاد بیاورید که نام هر واریانت انوم که تعریف می‌کنیم همچنین به یک تابع مقداردهنده تبدیل می‌شود. ما می‌توانیم از این توابع مقداردهنده به‌عنوان اشاره‌گرهای تابع که ویژگی‌های کلوژر را پیاده‌سازی می‌کنند استفاده کنیم، به این معنا که می‌توانیم توابع مقداردهنده را به‌عنوان آرگومان برای متدهایی که کلوژرها را می‌پذیرند مشخص کنیم، همان‌طور که در Listing 20-31 دیده می‌شود.

```rust
enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
```

**Listing 20-31: استفاده از مقداردهنده‌های انوم با متد map برای ایجاد نمونه‌های Status از اعداد**

در اینجا ما نمونه‌های `Status::Value` را با استفاده از هر مقدار `u32` در محدوده‌ای که `map` روی آن فراخوانی شده است، با استفاده از تابع مقداردهنده `Status::Value` ایجاد می‌کنیم. برخی افراد این سبک را ترجیح می‌دهند و برخی دیگر استفاده از کلوژرها را ترجیح می‌دهند. هر دو به کد یکسانی کامپایل می‌شوند، بنابراین از هر سبکی که برای شما واضح‌تر است استفاده کنید.

## بازگرداندن کلوژرها

کلوژرها توسط ویژگی‌ها نمایش داده می‌شوند، به این معنا که نمی‌توانید کلوژرها را مستقیماً برگردانید. در اکثر مواردی که ممکن است بخواهید یک ویژگی را برگردانید، می‌توانید به‌جای آن از نوع مشخصی که ویژگی را پیاده‌سازی می‌کند به‌عنوان مقدار بازگشتی تابع استفاده کنید. با این حال، معمولاً نمی‌توانید این کار را با کلوژرها انجام دهید زیرا آن‌ها نوع مشخصی که قابل بازگشت باشد ندارند. اگر کلوژری مقادیری را از حوزه خود ضبط کند، اجازه استفاده از اشاره‌گر تابع `fn` به‌عنوان نوع بازگشتی را ندارید، برای مثال.

در عوض، معمولاً از نحو `impl Trait` که در فصل دهم آموختیم استفاده خواهید کرد. می‌توانید هر نوع تابعی را با استفاده از `Fn`، `FnOnce` و `FnMut` برگردانید. برای مثال، کد در Listing 20-32 به‌خوبی کار خواهد کرد.

```rust
fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}
```

**Listing 20-32: بازگرداندن یک کلوژر از یک تابع با استفاده از نحو impl Trait**

با این حال، همان‌طور که در بخش «استنباط و حاشیه‌نویسی نوع کلوژر» در فصل سیزدهم اشاره کردیم، هر کلوژر نوع خاص خود را دارد. اگر نیاز به کار با چندین تابع داشته باشید که امضای یکسانی دارند اما پیاده‌سازی‌های متفاوتی دارند، باید از یک شیء ویژگی برای آن‌ها استفاده کنید. ببینید اگر کدی مانند آنچه در Listing 20-33 نشان داده شده است بنویسید چه اتفاقی می‌افتد.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{}", output);
    }
}

fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
    move |x| x + init
}
```

**Listing 20-33: ایجاد یک Vec<T> از کلوژرهای تعریف‌شده توسط توابعی که impl Fn را برمی‌گردانند**

در اینجا دو تابع داریم، `returns_closure` و `returns_initialized_closure`، که هر دو `impl Fn(i32) -> i32` را برمی‌گردانند. توجه کنید که کلوژرهایی که آن‌ها برمی‌گردانند متفاوت هستند، حتی اگر نوع یکسانی را پیاده‌سازی کنند. اگر سعی کنیم این را کامپایل کنیم، Rust به ما اطلاع می‌دهد که کار نخواهد کرد:

```
$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
    error[E0308]: mismatched types
    --> src/main.rs:4:9
    |
    4  |         returns_initialized_closure(123)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
    ...
    12 | fn returns_closure() -> impl Fn(i32) -> i32 {
    |                         ------------------- the expected opaque type
    ...
    16 | fn returns_initialized_closure(init: i32) -> impl Fn(i32) -> i32 {
    |                                              ------------------- the found opaque type
    |
    = note: expected opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:12:25>)
                found opaque type `impl Fn(i32) -> i32` (opaque type at <src/main.rs:16:46>)
    = note: distinct uses of `impl Trait` result in different opaque types

    For more information about this error, try `rustc --explain E0308`.
    error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
```

پیام خطا به ما می‌گوید که هرگاه `impl Trait` را برمی‌گردانیم، Rust یک نوع مات (opaque type) منحصربه‌فرد ایجاد می‌کند، نوعی که نمی‌توانیم جزئیات آنچه Rust برای ما ساخته است را ببینیم. بنابراین، حتی اگر این توابع هر دو کلوژرهایی را برمی‌گردانند که ویژگی یکسانی، `Fn(i32) -> i32`، را پیاده‌سازی می‌کنند، انواع مات تولیدشده توسط Rust برای هر یک متفاوت هستند. (این شبیه به این است که Rust چگونه انواع مشخص متفاوتی برای بلوک‌های async متفاوت تولید می‌کند حتی وقتی نوع خروجی یکسانی دارند، همان‌طور که در بخش «کار با هر تعداد Future» در فصل هفدهم دیدیم.) ما چند بار راه‌حلی برای این مشکل دیده‌ایم: می‌توانیم از یک شیء ویژگی استفاده کنیم، همان‌طور که در Listing 20-34 نشان داده شده است.

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |x| x + init)
}
```

**Listing 20-34: ایجاد یک Vec<T> از کلوژرهای تعریف‌شده توسط توابعی که Box<dyn Fn> را برمی‌گردانند تا نوع یکسانی داشته باشند**

این کد به‌خوبی کامپایل خواهد شد. برای اطلاعات بیشتر درباره اشیاء ویژگی، به بخش «استفاده از اشیاء ویژگی که امکان مقادیر از انواع مختلف را فراهم می‌کنند» در فصل هجدهم مراجعه کنید.

در ادامه، به ماکروها نگاه خواهیم کرد!
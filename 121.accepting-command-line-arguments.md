# پذیرش آرگومان‌های خط فرمان

بیایید یک پروژه جدید با استفاده از `cargo new`، همان‌طور که همیشه انجام می‌دهیم، ایجاد کنیم. پروژه ما را `minigrep` می‌نامیم تا از ابزار `grep` که ممکن است قبلاً روی سیستم شما وجود داشته باشد متمایز شود.

```bash
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

اولین کار این است که `minigrep` را قادر کنیم تا دو آرگومان خط فرمان را بپذیرد: مسیر فایل و رشته‌ای که باید جستجو شود. یعنی می‌خواهیم بتوانیم برنامه‌مان را با `cargo run` اجرا کنیم، با دو خط تیره برای نشان دادن اینکه آرگومان‌های بعدی برای برنامه ما هستند نه برای `cargo`، یک رشته برای جستجو، و یک مسیر به فایلی که باید در آن جستجو شود، مانند زیر:

```bash
$ cargo run -- searchstring example-filename.txt
```

در حال حاضر، برنامه تولیدشده توسط `cargo new` نمی‌تواند آرگومان‌هایی که به آن می‌دهیم را پردازش کند. برخی کتابخانه‌های موجود در crates.io می‌توانند به نوشتن برنامه‌ای که آرگومان‌های خط فرمان را می‌پذیرد کمک کنند، اما چون شما تازه در حال یادگیری این مفهوم هستید، بیایید این قابلیت را خودمان پیاده‌سازی کنیم.

## خواندن مقادیر آرگومان‌ها

برای اینکه `minigrep` بتواند مقادیر آرگومان‌های خط فرمانی که به آن پاس می‌دهیم را بخواند، به تابع `std::env::args` که در کتابخانه استاندارد **Rust** ارائه شده است نیاز داریم. این تابع یک تکرارساز (iterator) از آرگومان‌های خط فرمان پاس‌شده به `minigrep` برمی‌گرداند. ما در فصل سیزدهم به‌طور کامل درباره تکرارسازها صحبت خواهیم کرد. برای حالا، فقط باید دو جزئیات درباره تکرارسازها بدانید: تکرارسازها مجموعه‌ای از مقادیر را تولید می‌کنند، و می‌توانیم متد `collect` را روی یک تکرارساز فراخوانی کنیم تا آن را به یک مجموعه، مانند یک بردار (vector)، تبدیل کنیم که شامل همه عناصری است که تکرارساز تولید می‌کند.

کد موجود در **جدول 12-1** به برنامه `minigrep` شما اجازه می‌دهد هر آرگومان خط فرمانی که به آن پاس داده شده را بخواند و سپس مقادیر را در یک بردار جمع‌آوری کند.

**فایل: src/main.rs**

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::env::args().collect();
    dbg!(args);
}
```

**جدول 12-1**: جمع‌آوری آرگومان‌های خط فرمان در یک بردار و چاپ آن‌ها

ابتدا ماژول `std::env` را با یک دستور `use` به حوزه می‌آوریم تا بتوانیم از تابع `args` آن استفاده کنیم. توجه کنید که تابع `std::env::args` در دو سطح ماژول تو در تو قرار دارد. همان‌طور که در فصل هفتم بحث کردیم، در مواردی که تابع مورد نظر در بیش از یک ماژول تو در تو است، ترجیح داده‌ایم ماژول والد را به حوزه بیاوریم تا خود تابع. با این کار، می‌توانیم به‌راحتی از توابع دیگر `std::env` استفاده کنیم. همچنین این کار کمتر مبهم است نسبت به افزودن `use std::env::args` و سپس فراخوانی تابع فقط با `args`، چون `args` ممکن است به‌راحتی با یک تابع تعریف‌شده در ماژول کنونی اشتباه گرفته شود.

### تابع `args` و یونیکد نامعتبر

توجه کنید که `std::env::args` اگر هر آرگومانی شامل یونیکد نامعتبر باشد وحشت می‌کند. اگر برنامه شما نیاز به پذیرش آرگومان‌هایی با یونیکد نامعتبر دارد، به‌جای آن از `std::env::args_os` استفاده کنید. آن تابع یک تکرارساز برمی‌گرداند که مقادیر `OsString` به‌جای مقادیر `String` تولید می‌کند. ما اینجا برای سادگی از `std::env::args` استفاده کرده‌ایم چون مقادیر `OsString` در هر پلتفرم متفاوت هستند و کار با آن‌ها نسبت به مقادیر `String` پیچیده‌تر است.

در خط اول `main`، ما `env::args` را فراخوانی می‌کنیم و بلافاصله از `collect` استفاده می‌کنیم تا تکرارساز را به یک بردار شامل همه مقادیر تولیدشده توسط تکرارساز تبدیل کنیم. می‌توانیم از تابع `collect` برای ایجاد انواع مختلفی از مجموعه‌ها استفاده کنیم، بنابراین نوع `args` را به‌صراحت حاشیه‌نویسی می‌کنیم تا مشخص کنیم که یک بردار از رشته‌ها می‌خواهیم. اگرچه در **Rust** به‌ندرت نیاز به حاشیه‌نویسی نوع دارید، `collect` یکی از توابعی است که اغلب نیاز به حاشیه‌نویسی دارد چون **Rust** نمی‌تواند نوع مجموعه‌ای که می‌خواهید را استنباط کند.

در نهایت، بردار را با استفاده از ماکرو دیباگ چاپ می‌کنیم. بیایید کد را ابتدا بدون هیچ آرگومانی و سپس با دو آرگومان اجرا کنیم:

```bash
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
```

توجه کنید که اولین مقدار در بردار `"target/debug/minigrep"` است، که نام باینری ما است. این با رفتار لیست آرگومان‌ها در C مطابقت دارد، که به برنامه‌ها اجازه می‌دهد از نامی که با آن فراخوانی شده‌اند در اجرای خود استفاده کنند. اغلب داشتن دسترسی به نام برنامه راحت است در صورتی که بخواهید آن را در پیام‌ها چاپ کنید یا رفتار برنامه را بر اساس اینکه چه نام مستعار خط فرمانی برای فراخوانی برنامه استفاده شده تغییر دهید. اما برای اهداف این فصل، ما آن را نادیده می‌گیریم و فقط دو آرگومانی که نیاز داریم ذخیره می‌کنیم.

## ذخیره مقادیر آرگومان‌ها در متغیرها

برنامه در حال حاضر می‌تواند به مقادیر مشخص‌شده به‌عنوان آرگومان‌های خط فرمان دسترسی پیدا کند. حالا باید مقادیر دو آرگومان را در متغیرها ذخیره کنیم تا بتوانیم از این مقادیر در بقیه برنامه استفاده کنیم. این کار را در **جدول 12-2** انجام می‌دهیم.

**فایل: src/main.rs**

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}
```

**جدول 12-2**: ایجاد متغیرهایی برای نگهداری آرگومان پرس‌وجو و مسیر فایل

همان‌طور که وقتی بردار را چاپ کردیم دیدیم، نام برنامه اولین مقدار در بردار در `args[0]` را اشغال می‌کند، بنابراین ما آرگومان‌ها را از ایندکس 1 شروع می‌کنیم. اولین آرگومانی که `minigrep` می‌گیرد رشته‌ای است که ما به دنبال آن هستیم، بنابراین ما یک ارجاع به اولین آرگومان را در متغیر `query` قرار می‌دهیم. دومین آرگومان مسیر فایل خواهد بود، بنابراین ما یک ارجاع به دومین آرگومان را در متغیر `file_path` قرار می‌دهیم.

ما به‌طور موقت مقادیر این متغیرها را چاپ می‌کنیم تا ثابت کنیم که کد همان‌طور که ما قصد داریم کار می‌کند. بیایید این برنامه را دوباره با آرگومان‌های `test` و `sample.txt` اجرا کنیم:

```bash
$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```

عالی است، برنامه کار می‌کند! مقادیر آرگومان‌هایی که نیاز داریم به درستی در متغیرها ذخیره می‌شوند. بعداً مقداری مدیریت خطا اضافه خواهیم کرد تا با موقعیت‌های خطای احتمالی خاص، مانند زمانی که کاربر هیچ آرگومانی ارائه نمی‌دهد، برخورد کنیم؛ برای حالا، ما این موقعیت را نادیده می‌گیریم و به جای آن روی افزودن قابلیت‌های خواندن فایل کار می‌کنیم.


## نوع‌های داده

هر مقدار در Rust دارای یک نوع داده خاص است که به Rust می‌گوید چه نوع داده‌ای مشخص شده است تا بداند چگونه با آن داده کار کند. ما به دو زیرمجموعه نوع داده نگاه خواهیم کرد: مقیاس‌پذیر (scalar) و ترکیبی (compound).

به خاطر داشته باشید که Rust یک زبان با تایپ استاتیک است، به این معنی که باید نوع تمام متغیرها را در زمان کامپایل بداند. کامپایلر معمولاً می‌تواند نوع مورد نظر ما را بر اساس مقدار و نحوه استفاده از آن استنتاج کند. در مواردی که چندین نوع ممکن است، مانند وقتی که در بخش «مقایسه حدس با عدد مخفی» در فصل دوم یک `String` را با استفاده از `parse` به نوع عددی تبدیل کردیم، باید یک حاشیه‌نویسی نوع اضافه کنیم، مانند این:

```rust
let guess: u32 = "42".parse().expect("عدد نیست!");
```

اگر حاشیه‌نویسی نوع `: u32` را که در کد بالا نشان داده شده اضافه نکنیم، Rust خطای زیر را نمایش خواهد داد، که به این معنی است که کامپایلر به اطلاعات بیشتری از ما نیاز دارد تا بداند کدام نوع را می‌خواهیم استفاده کنیم:

```bash
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("عدد نیست!");
  |         ^^^^^        ----- نوع باید در این نقطه مشخص باشد
  |
  = note: نمی‌توان شرط `<_ as FromStr>::Err == _` را برآورده کرد
help: در نظر بگیرید که به `guess` یک نوع صریح بدهید
  |
2 |     let guess: /* نوع */ = "42".parse().expect("عدد نیست!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
```

برای نوع‌های داده دیگر، حاشیه‌نویسی‌های نوع متفاوتی خواهید دید.

### نوع‌های مقیاس‌پذیر

نوع مقیاس‌پذیر یک مقدار واحد را نشان می‌دهد. Rust چهار نوع مقیاس‌پذیر اصلی دارد: اعداد صحیح، اعداد ممیز شناور، بولین‌ها، و کاراکترها. ممکن است این‌ها را از زبان‌های برنامه‌نویسی دیگر بشناسید. بیایید به نحوه کار آن‌ها در Rust بپردازیم.

#### نوع‌های صحیح

یک عدد صحیح، عددی بدون جزء کسری است. ما در فصل دوم از یک نوع صحیح، نوع `u32`، استفاده کردیم. این اعلان نوع نشان می‌دهد که مقداری که با آن مرتبط است باید یک عدد صحیح بدون علامت (نوع‌های صحیح با علامت با `i` شروع می‌شوند به‌جای `u`) باشد که ۳۲ بیت فضا اشغال می‌کند. جدول ۳-۱ نوع‌های صحیح داخلی در Rust را نشان می‌دهد. ما می‌توانیم از هر یک از این واریانت‌ها برای اعلان نوع یک مقدار صحیح استفاده کنیم.

**جدول ۳-۱: نوع‌های صحیح در Rust**

| طول       | با علامت | بدون علامت |
|------------|----------|-------------|
| ۸ بیت      | `i8`     | `u8`        |
| ۱۶ بیت     | `i16`    | `u16`       |
| ۳۲ بیت     | `i32`    | `u32`       |
| ۶۴ بیت     | `i64`    | `u64`       |
| ۱۲۸ بیت    | `i128`   | `u128`      |
| معماری    | `isize`  | `usize`     |

هر واریانت می‌تواند با علامت یا بدون علامت باشد و اندازه صریحی دارد. با علامت و بدون علامت به این اشاره دارد که آیا ممکن است عدد منفی باشد—به عبارت دیگر، آیا عدد نیاز به علامت (با علامت) دارد یا همیشه مثبت خواهد بود و بنابراین می‌تواند بدون علامت نشان داده شود (بدون علامت). این مانند نوشتن اعداد روی کاغذ است: وقتی علامت مهم است، عدد با علامت مثبت یا منفی نشان داده می‌شود؛ اما وقتی می‌توان فرض کرد عدد مثبت است، بدون علامت نشان داده می‌شود. اعداد با علامت با استفاده از نمایش مکمل دو (two’s complement) ذخیره می‌شوند.

هر واریانت با علامت می‌تواند اعداد از `−(2^(n−1))` تا `2^(n−1) − 1` را ذخیره کند، که `n` تعداد بیت‌های استفاده‌شده توسط آن واریانت است. بنابراین یک `i8` می‌تواند اعداد از `−(2^7)` تا `2^7 − 1` را ذخیره کند، که برابر است با `−128` تا `127`. واریانت‌های بدون علامت می‌توانند اعداد از `0` تا `2^n − 1` را ذخیره کنند، بنابراین یک `u8` می‌تواند اعداد از `0` تا `2^8 − 1` را ذخیره کند، که برابر است با `0` تا `255`.

علاوه بر این، نوع‌های `isize` و `usize` به معماری کامپیوتری که برنامه شما روی آن اجرا می‌شود بستگی دارند، که در جدول به‌عنوان «معماری» مشخص شده است: ۶۴ بیت اگر روی معماری ۶۴ بیتی باشید و ۳۲ بیت اگر روی معماری ۳۲ بیتی باشید.

می‌توانید لیترال‌های صحیح را به هر یک از فرم‌های نشان‌داده‌شده در جدول ۳-۲ بنویسید. توجه کنید که لیترال‌های عددی که می‌توانند چندین نوع عددی باشند، اجازه استفاده از پسوند نوع، مانند `57u8`، را برای مشخص کردن نوع دارند. لیترال‌های عددی همچنین می‌توانند از `_` به‌عنوان جداکننده بصری برای خواناتر کردن عدد استفاده کنند، مانند `1_000`، که همان مقدار `1000` را خواهد داشت.

**جدول ۳-۲: لیترال‌های صحیح در Rust**

| لیترال‌های عددی | مثال              |
|-------------------|-------------------|
| دسیمال          | `98_222`         |
| هگزادسیمال      | `0xff`           |
| اکتال           | `0o77`           |
| باینری          | `0b1111_0000`    |
| بایت (فقط `u8`) | `b'A'`           |

پس چگونه می‌دانید کدام نوع صحیح را استفاده کنید؟ اگر مطمئن نیستید، پیش‌فرض‌های Rust معمولاً نقاط شروع خوبی هستند: نوع‌های صحیح به‌طور پیش‌فرض به `i32` تنظیم می‌شوند. موقعیت اصلی که از `isize` یا `usize` استفاده می‌کنید، هنگام ایندکس کردن نوعی مجموعه است.

**توضیح اضافی:** نوع‌های `isize` و `usize` برای کارهایی مانند ایندکس آرایه‌ها یا شمارش آیتم‌ها در یک مجموعه مناسب هستند، زیرا اندازه آن‌ها با معماری سیستم هماهنگ است.

##### سرریز صحیح (Integer Overflow)

فرض کنید یک متغیر از نوع `u8` دارید که می‌تواند مقادیر بین `0` تا `255` را نگه دارد. اگر سعی کنید متغیر را به مقداری خارج از این محدوده، مانند `256`، تغییر دهید، سرریز صحیح (integer overflow) رخ می‌دهد، که می‌تواند به یکی از دو رفتار منجر شود. وقتی در حالت دیباگ کامپایل می‌کنید، Rust بررسی‌هایی برای سرریز صحیح شامل می‌کند که اگر این رفتار رخ دهد، باعث می‌شود برنامه شما در زمان اجرا پنیک (panic) کند. Rust وقتی برنامه با خطا خارج می‌شود از اصطلاح پنیک کردن استفاده می‌کند؛ ما درباره پنیک‌ها در بخش «خطاهای غیرقابل‌بازیابی با panic!» در فصل نهم بیشتر بحث خواهیم کرد.

وقتی در حالت رها (release) با پرچم `--release` کامپایل می‌کنید، Rust بررسی‌هایی برای سرریز صحیح که باعث پنیک می‌شوند شامل نمی‌کند. در عوض، اگر سرریز رخ دهد، Rust پیچش مکمل دو (two’s complement wrapping) را انجام می‌دهد. به‌طور خلاصه، مقادیر بزرگ‌تر از حداکثر مقداری که نوع می‌تواند نگه دارد، به حداقل مقادیر نوع «پیچیده» می‌شوند. در مورد یک `u8`، مقدار `256` به `0` تبدیل می‌شود، مقدار `257` به `1` تبدیل می‌شود، و غیره. برنامه پنیک نمی‌کند، اما متغیر مقداری خواهد داشت که احتمالاً آن چیزی نیست که انتظار داشتید. تکیه بر رفتار پیچش سرریز صحیح به‌عنوان یک خطا در نظر گرفته می‌شود.

برای مدیریت صریح امکان سرریز، می‌توانید از این خانواده‌های متد که توسط کتابخانه استاندارد برای نوع‌های عددی اولیه ارائه شده‌اند استفاده کنید:

- پیچش در همه حالت‌ها با متدهای `wrapping_*`، مانند `wrapping_add`.
- بازگشت مقدار `None` در صورت سرریز با متدهای `checked_*`.
- بازگشت مقدار و یک بولین که نشان می‌دهد آیا سرریز رخ داده است با متدهای `overflowing_*`.
- اشباع در حداقل یا حداکثر مقادیر نوع با متدهای `saturating_*`.

**توضیح اضافی:** این متدها به شما امکان می‌دهند سرریز را به روشی کنترل‌شده مدیریت کنید، مثلاً با استفاده از `checked_add` برای بررسی سرریز یا `saturating_add` برای محدود کردن نتیجه به حداکثر مقدار نوع.

#### نوع‌های ممیز شناور

Rust همچنین دو نوع اولیه برای اعداد ممیز شناور دارد، که اعدادی با نقطه اعشار هستند. نوع‌های ممیز شناور Rust شامل `f32` و `f64` هستند، که به ترتیب ۳۲ بیت و ۶۴ بیت اندازه دارند. نوع پیش‌فرض `f64` است زیرا در CPUهای مدرن، تقریباً همان سرعت `f32` را دارد اما دقت بیشتری ارائه می‌دهد. همه نوع‌های ممیز شناور با علامت هستند.

اینجا یک مثال است که اعداد ممیز شناور را در عمل نشان می‌دهد:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

اعداد ممیز شناور طبق استاندارد IEEE-754 نشان داده می‌شوند.

**توضیح اضافی:** استاندارد IEEE-754 روشی استاندارد برای نمایش اعداد ممیز شناور در کامپیوترهاست، که شامل بخش‌هایی برای علامت، توان، و کسر است.

#### عملیات عددی

Rust از عملیات ریاضی پایه‌ای که برای همه نوع‌های عددی انتظار دارید پشتیبانی می‌کند: جمع، تفریق، ضرب، تقسیم، و باقی‌مانده. تقسیم صحیح به سمت صفر به نزدیک‌ترین عدد صحیح کوتاه می‌شود. کد زیر نشان می‌دهد چگونه از هر عملیات عددی در یک عبارت `let` استفاده کنید:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    // جمع
    let sum = 5 + 10;

    // تفریق
    let difference = 95.5 - 4.3;

    // ضرب
    let product = 4 * 30;

    // تقسیم
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // نتیجه -1

    // باقی‌مانده
    let remainder = 43 % 5;
}
```

هر عبارت در این عبارات از یک عملگر ریاضی استفاده می‌کند و به یک مقدار واحد ارزیابی می‌شود، که سپس به یک متغیر متصل می‌شود. پیوست B لیستی از تمام عملگرهایی که Rust ارائه می‌دهد را شامل می‌شود.

#### نوع بولین

مانند اکثر زبان‌های برنامه‌نویسی دیگر، نوع بولین در Rust دو مقدار ممکن دارد: `true` و `false`. بولین‌ها یک بایت اندازه دارند. نوع بولین در Rust با `bool` مشخص می‌شود. برای مثال:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let t = true;

    let f: bool = false; // با حاشیه‌نویسی نوع صریح
}
```

روش اصلی استفاده از مقادیر بولین از طریق شرطی‌ها، مانند عبارت `if`، است. ما نحوه کار عبارات `if` در Rust را در بخش «جریان کنترل» پوشش خواهیم داد.

#### نوع کاراکتر

نوع `char` در Rust ابتدایی‌ترین نوع الفبایی زبان است. در اینجا چند مثال از اعلان مقادیر `char` آورده شده است:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // با حاشیه‌نویسی نوع صریح
    let heart_eyed_cat = '😻';
}
```

توجه کنید که لیترال‌های `char` با نقل‌قول‌های تکی مشخص می‌شوند، در مقابل لیترال‌های رشته‌ای که از نقل‌قول‌های دوتایی استفاده می‌کنند. نوع `char` در Rust چهار بایت اندازه دارد و یک مقدار اسکالر یونیکد را نشان می‌دهد، به این معنی که می‌تواند خیلی بیشتر از فقط ASCII را نشان دهد. حروف دارای علامت؛ کاراکترهای چینی، ژاپنی، و کره‌ای؛ ایموجی‌ها؛ و فضاهای عرض صفر همگی مقادیر `char` معتبر در Rust هستند. مقادیر اسکالر یونیکد از `U+0000` تا `U+D7FF` و `U+E000` تا `U+10FFFF` شامل می‌شوند. با این حال، مفهوم «کاراکتر» در یونیکد واقعاً یک مفهوم نیست، بنابراین شهود انسانی شما درباره اینکه «کاراکتر» چیست ممکن است با آنچه در Rust یک `char` است مطابقت نداشته باشد. ما این موضوع را در بخش «ذخیره متن کدگذاری‌شده با UTF-8 با رشته‌ها» در فصل هشتم با جزئیات بحث خواهیم کرد.

**توضیح اضافی:** نوع `char` در Rust بسیار انعطاف‌پذیر است زیرا از یونیکد پشتیبانی می‌کند، اما باید توجه داشت که یک `char` همیشه یک واحد کد یونیکد (Unicode code point) است و ممکن است همیشه با یک «کاراکتر» بصری (مانند ایموجی‌های ترکیبی) مطابقت نداشته باشد.

### نوع‌های ترکیبی

نوع‌های ترکیبی می‌توانند چندین مقدار را در یک نوع گروه‌بندی کنند. Rust دو نوع ترکیبی اولیه دارد: تاپل‌ها و آرایه‌ها.

#### نوع تاپل

تاپل راهی عمومی برای گروه‌بندی تعدادی مقدار با نوع‌های مختلف در یک نوع ترکیبی است. تاپل‌ها طول ثابتی دارند: پس از اعلان، نمی‌توانند در اندازه رشد کنند یا کوچک شوند.

ما یک تاپل را با نوشتن لیستی از مقادیر جدا شده با کاما در داخل پرانتز ایجاد می‌کنیم. هر موقعیت در تاپل دارای یک نوع است، و نوع‌های مقادیر مختلف در تاپل لازم نیست یکسان باشند. ما در این مثال حاشیه‌نویسی‌های نوع اختیاری اضافه کرده‌ایم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

متغیر `tup` به کل تاپل متصل می‌شود زیرا تاپل به‌عنوان یک عنصر ترکیبی واحد در نظر گرفته می‌شود. برای به‌دست آوردن مقادیر جداگانه از یک تاپل، می‌توانیم از تطبیق الگو برای ساختارگشایی (destructure) مقدار تاپل استفاده کنیم، مانند این:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("مقدار y برابر است با: {y}");
}
```

این برنامه ابتدا یک تاپل ایجاد می‌کند و آن را به متغیر `tup` متصل می‌کند. سپس از یک الگو با `let` استفاده می‌کند تا `tup` را بگیرد و آن را به سه متغیر جداگانه، `x`، `y`، و `z`، تبدیل کند. این فرآیند ساختارگشایی نامیده می‌شود زیرا تاپل واحد را به سه بخش تقسیم می‌کند. در نهایت، برنامه مقدار `y` را چاپ می‌کند، که `6.4` است.

همچنین می‌توانیم مستقیماً به یک عنصر تاپل با استفاده از یک نقطه (`.`) و سپس ایندکس مقداری که می‌خواهیم به آن دسترسی پیدا کنیم، دسترسی داشته باشیم. برای مثال:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

این برنامه تاپل `x` را ایجاد می‌کند و سپس هر عنصر تاپل را با استفاده از ایندکس‌های مربوطه دسترسی می‌کند. مانند اکثر زبان‌های برنامه‌نویسی، ایندکس اول در تاپل `0` است.

تاپل بدون هیچ مقداری نام خاصی دارد، به نام واحد (unit). این مقدار و نوع مربوطه‌اش هر دو به‌صورت `()` نوشته می‌شوند و نشان‌دهنده یک مقدار خالی یا یک نوع بازگشت خالی هستند. عباراتی که مقدار دیگری برنمی‌گردانند، به‌صورت ضمنی مقدار واحد را برمی‌گردانند.

**توضیح اضافی:** تاپل‌ها برای گروه‌بندی مقادیر مرتبط با نوع‌های مختلف مفید هستند، مانند ذخیره اطلاعات یک رکورد کوچک (مثلاً مختصات یک نقطه یا مشخصات یک شیء).

#### نوع آرایه

راه دیگر برای داشتن مجموعه‌ای از چندین مقدار با یک آرایه است. برخلاف تاپل، هر عنصر یک آرایه باید نوع یکسانی داشته باشد. برخلاف آرایه‌ها در برخی زبان‌های دیگر، آرایه‌ها در Rust طول ثابتی دارند.

مقادیر در یک آرایه را به‌عنوان لیستی جدا شده با کاما در داخل کروشه‌ها می‌نویسیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

آرایه‌ها وقتی مفید هستند که بخواهید داده‌های شما روی پشته (stack) تخصیص یابد، همان‌طور که نوع‌های دیگری که تا حالا دیده‌ایم، به‌جای هیپ (heap) (ما درباره پشته و هیپ در فصل چهارم بیشتر بحث خواهیم کرد) یا وقتی بخواهید مطمئن شوید همیشه تعداد ثابتی از عناصر دارید. با این حال، آرایه به اندازه نوع بردار (vector) انعطاف‌پذیر نیست. بردار یک نوع مجموعه مشابه است که توسط کتابخانه استاندارد ارائه شده و اجازه رشد یا کوچک شدن در اندازه را دارد. اگر مطمئن نیستید که از آرایه استفاده کنید یا بردار، احتمالاً باید از بردار استفاده کنید. فصل هشتم درباره بردارها با جزئیات بیشتری بحث می‌کند.

با این حال، آرایه‌ها وقتی می‌دانید تعداد عناصر نیازی به تغییر ندارد، مفیدتر هستند. برای مثال، اگر از نام‌های ماه‌ها در یک برنامه استفاده می‌کردید، احتمالاً از یک آرایه به‌جای بردار استفاده می‌کردید زیرا می‌دانید همیشه ۱۲ عنصر خواهد داشت:

```rust
let months = ["ژانویه", "فوریه", "مارس", "آوریل", "مه", "ژوئن", "ژوئیه",
              "اوت", "سپتامبر", "اکتبر", "نوامبر", "دسامبر"];
```

نوع یک آرایه را با استفاده از کروشه‌ها با نوع هر عنصر، یک سمی‌کالن، و سپس تعداد عناصر در آرایه می‌نویسید، مانند این:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

در اینجا، `i32` نوع هر عنصر است. بعد از سمی‌کالن، عدد `5` نشان می‌دهد که آرایه شامل پنج عنصر است.

همچنین می‌توانید یک آرایه را طوری مقداردهی کنید که هر عنصر مقدار یکسانی داشته باشد با مشخص کردن مقدار اولیه، به دنبال یک سمی‌کالن، و سپس طول آرایه در کروشه‌ها، همان‌طور که اینجا نشان داده شده است:

```rust
let a = [3; 5];
```

آرایه‌ای به نام `a` شامل ۵ عنصر خواهد بود که همگی در ابتدا به مقدار `3` تنظیم می‌شوند. این همان نوشتن `let a = [3, 3, 3, 3, 3];` است اما به روشی مختصرتر.

**توضیح اضافی:** این سینتکس برای مقداردهی آرایه‌ها به مقادیر یکسان بسیار مفید است، مثلاً برای ایجاد یک آرایه پر از صفر یا یک مقدار ثابت دیگر.

##### دسترسی به عناصر آرایه

آرایه یک تکه حافظه واحد با اندازه ثابت و شناخته‌شده است که می‌تواند روی پشته تخصیص یابد. می‌توانید به عناصر یک آرایه با استفاده از ایندکس‌گذاری دسترسی پیدا کنید، مانند این:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

در این مثال، متغیر به نام `first` مقدار `1` را می‌گیرد زیرا این مقدار در ایندکس `[0]` در آرایه است. متغیر به نام `second` مقدار `2` را از ایندکس `[1]` در آرایه می‌گیرد.

##### دسترسی نامعتبر به عنصر آرایه

بیایید ببینیم اگر سعی کنید به عنصری از آرایه دسترسی پیدا کنید که از انتهای آرایه گذشته است، چه اتفاقی می‌افتد. فرض کنید این کد را اجرا کنید، مشابه بازی حدس در فصل دوم، تا یک ایندکس آرایه از کاربر بگیرید:

**نام فایل:** `src/main.rs`

**این کد پنیک می‌کند!**

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("لطفاً یک ایندکس آرایه وارد کنید.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("خطا در خواندن خط");

    let index: usize = index
        .trim()
        .parse()
        .expect("ایندکس واردشده عدد نبود");

    let element = a[index];

    println!("مقدار عنصر در ایندکس {index} برابر است با: {element}");
}
```

این کد با موفقیت کامپایل می‌شود. اگر این کد را با استفاده از `cargo run` اجرا کنید و `0`، `1`، `2`، `3`، یا `4` را وارد کنید، برنامه مقدار مربوطه را در آن ایندکس در آرایه چاپ خواهد کرد. اگر به‌جای آن عددی فراتر از انتهای آرایه، مانند `10`، وارد کنید، خروجی مانند این را خواهید دید:

```bash
thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

برنامه در نقطه استفاده از یک مقدار نامعتبر در عملیات ایندکس‌گذاری با یک خطای زمان اجرا مواجه شد. برنامه با یک پیام خطا خارج شد و عبارت `println!` نهایی را اجرا نکرد. وقتی سعی می‌کنید با استفاده از ایندکس‌گذاری به یک عنصر دسترسی پیدا کنید، Rust بررسی می‌کند که ایندکسی که مشخص کرده‌اید کمتر از طول آرایه باشد. اگر ایندکس بزرگ‌تر یا برابر با طول باشد، Rust پنیک می‌کند. این بررسی باید در زمان اجرا انجام شود، به‌ویژه در این مورد، زیرا کامپایلر نمی‌تواند بداند کاربر وقتی کد را بعداً اجرا می‌کند چه مقداری وارد خواهد کرد.

این مثالی از اصول ایمنی حافظه Rust در عمل است. در بسیاری از زبان‌های سطح پایین، این نوع بررسی انجام نمی‌شود، و وقتی ایندکس نادرستی ارائه می‌دهید، ممکن است به حافظه نامعتبر دسترسی پیدا کنید. Rust با خروج فوری به‌جای اجازه دادن به دسترسی به حافظه و ادامه دادن، شما را از این نوع خطا محافظت می‌کند. فصل نهم درباره مدیریت خطای Rust و نحوه نوشتن کد خوانا و ایمن که نه پنیک می‌کند و نه اجازه دسترسی به حافظه نامعتبر را می‌دهد، بیشتر بحث می‌کند.


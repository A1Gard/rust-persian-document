## نوع برش (Slice)

برش‌ها (slices) به شما امکان می‌دهند به یک توالی پیوسته از عناصر در یک مجموعه ارجاع دهید، به‌جای کل مجموعه. برش نوعی ارجاع است، بنابراین مالکیتی ندارد.

در اینجا یک مسئله برنامه‌نویسی کوچک آورده شده است: تابعی بنویسید که یک رشته از کلمات جدا شده با فاصله می‌گیرد و اولین کلمه‌ای که در آن رشته پیدا می‌کند را برمی‌گرداند. اگر تابع در رشته فاصله‌ای پیدا نکند، کل رشته باید یک کلمه باشد، بنابراین کل رشته باید برگردانده شود.

بیایید بررسی کنیم که چگونه امضای این تابع را بدون استفاده از برش‌ها می‌نوشتیم، تا مشکلی که برش‌ها حل می‌کنند را درک کنیم:

```rust
fn first_word(s: &String) -> ?
```

تابع `first_word` یک `&String` به‌عنوان پارامتر دارد. ما نیازی به مالکیت نداریم، بنابراین این مشکلی ندارد. (در Rust اصولی، توابع مالکیت آرگومان‌هایشان را نمی‌گیرند مگر اینکه لازم باشد، و دلایل این موضوع با ادامه کار روشن‌تر خواهد شد!) اما چه چیزی باید برگردانیم؟ ما واقعاً راهی برای صحبت درباره بخشی از یک رشته نداریم. با این حال، می‌توانیم ایندکس انتهای کلمه را که با یک فاصله مشخص شده است، برگردانیم. بیایید این را امتحان کنیم، همان‌طور که در لیست ۴-۷ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

**لیست ۴-۷:** تابع `first_word` که یک مقدار ایندکس بایت را در پارامتر `String` برمی‌گرداند

چون باید رشته را عنصر به عنصر بررسی کنیم و ببینیم آیا مقداری یک فاصله است، `String` خود را با استفاده از متد `as_bytes` به یک آرایه از بایت‌ها تبدیل می‌کنیم.

```rust
    let bytes = s.as_bytes();
```

سپس، با استفاده از متد `iter` یک تکرارگر (iterator) روی آرایه بایت‌ها ایجاد می‌کنیم:

```rust
    for (i, &item) in bytes.iter().enumerate() {
```

درباره تکرارگرها در فصل سیزدهم با جزئیات بیشتری بحث خواهیم کرد. فعلاً بدانید که `iter` متدی است که هر عنصر را در یک مجموعه برمی‌گرداند و `enumerate` نتیجه `iter` را بسته‌بندی می‌کند و هر عنصر را به‌عنوان بخشی از یک تاپل برمی‌گرداند. عنصر اول تاپل برگشتی از `enumerate` ایندکس است، و عنصر دوم ارجاعی به عنصر است. این کمی راحت‌تر از محاسبه ایندکس توسط خودمان است.

چون متد `enumerate` یک تاپل برمی‌گرداند، می‌توانیم از الگوها برای تجزیه (destructure) آن تاپل استفاده کنیم. در فصل ششم درباره الگوها بیشتر بحث خواهیم کرد. در حلقه `for`، الگویی مشخص می‌کنیم که `i` برای ایندکس در تاپل و `&item` برای بایت تک در تاپل دارد. چون از `.iter().enumerate()` یک ارجاع به عنصر دریافت می‌کنیم، در الگو از `&` استفاده می‌کنیم.

درون حلقه `for`، با استفاده از سینتکس لفظ بایت، به دنبال بایتی که نشان‌دهنده فاصله است می‌گردیم. اگر فاصله‌ای پیدا کنیم، موقعیت را برمی‌گردانیم. در غیر این صورت، طول رشته را با استفاده از `s.len()` برمی‌گردانیم.

```rust
        if item == b' ' {
            return i;
        }
    }

    s.len()
```

حالا راهی برای پیدا کردن ایندکس انتهای اولین کلمه در رشته داریم، اما مشکلی وجود دارد. ما یک `usize` را به‌تنهایی برمی‌گردانیم، اما این فقط در زمینه `&String` معنادار است. به عبارت دیگر، چون این یک مقدار جدا از `String` است، هیچ تضمینی وجود ندارد که در آینده همچنان معتبر باشد. برنامه در لیست ۴-۸ را در نظر بگیرید که از تابع `first_word` از لیست ۴-۷ استفاده می‌کند.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word مقدار 5 را می‌گیرد

    s.clear(); // این String را خالی می‌کند، و آن را برابر با "" می‌کند

    // `word` هنوز اینجا مقدار 5 را دارد، اما `s` دیگر هیچ محتوایی ندارد
    // که بتوانیم به‌طور معناداری با مقدار 5 از آن استفاده کنیم، بنابراین `word` حالا
    // کاملاً نامعتبر است!
}
```

**لیست ۴-۸:** ذخیره نتیجه فراخوانی تابع `first_word` و سپس تغییر محتوای `String`

این برنامه بدون هیچ خطایی کامپایل می‌شود و اگر بعد از فراخوانی `s.clear()` از `word` استفاده کنیم، باز هم همین‌طور خواهد بود. چون `word` اصلاً به وضعیت `s` متصل نیست، `word` همچنان مقدار ۵ را نگه می‌دارد. می‌توانستیم از مقدار ۵ با متغیر `s` برای استخراج اولین کلمه استفاده کنیم، اما این یک باگ می‌بود چون محتوای `s` از زمانی که ۵ را در `word` ذخیره کردیم، تغییر کرده است.

نگرانی درباره اینکه ایندکس در `word` با داده در `s` همگام نباشد، خسته‌کننده و مستعد خطاست! مدیریت این ایندکس‌ها حتی شکننده‌تر می‌شود اگر بخواهیم یک تابع `second_word` بنویسیم. امضای آن باید این‌گونه باشد:

```rust
fn second_word(s: &String) -> (usize, usize) {
```

حالا باید یک ایندکس شروع و یک ایندکس پایان را ردیابی کنیم، و حتی مقادیر بیشتری داریم که از داده‌ای در یک حالت خاص محاسبه شده‌اند اما اصلاً به آن حالت متصل نیستند. سه متغیر غیرمرتبط داریم که باید همگام نگه داشته شوند.

خوشبختانه، Rust راه‌حلی برای این مشکل دارد: برش‌های رشته‌ای (string slices).

### برش‌های رشته‌ای

یک برش رشته‌ای ارجاعی به بخشی از یک `String` است و به این شکل است:

```rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
```

به‌جای ارجاع به کل `String`، `hello` ارجاعی به بخشی از `String` است که در بخش اضافی `[0..5]` مشخص شده است. ما برش‌ها را با استفاده از یک محدوده در کروشه‌ها با مشخص کردن `[starting_index..ending_index]` ایجاد می‌کنیم، که در آن `starting_index` اولین موقعیت در برش و `ending_index` یک واحد بیشتر از آخرین موقعیت در برش است. در داخل، ساختار داده برش موقعیت شروع و طول برش را ذخیره می‌کند، که برابر با `ending_index` منهای `starting_index` است. بنابراین، در مورد `let world = &s[6..11];`، `world` یک برش خواهد بود که شامل یک اشاره‌گر به بایت در ایندکس ۶ از `s` با مقدار طول ۵ است.

<img src="img/trpl04-07.svg">

شکل ۴-۷ این را در یک دیاگرام نشان می‌دهد.

> **شکل ۴-۷:** برش رشته‌ای که به بخشی از یک `String` ارجاع می‌دهد

> **توضیح شکل:** سه جدول: جدولی که داده پشته `s` را نشان می‌دهد، که به بایت در ایندکس ۰ در جدولی از داده رشته `"hello world"` روی هیپ اشاره می‌کند. جدول سوم داده پشته برش `world` را نشان می‌دهد، که مقدار طول ۵ دارد و به بایت ۶ جدول داده هیپ اشاره می‌کند.

با سینتکس محدوده `..` در Rust، اگر بخواهید از ایندکس ۰ شروع کنید، می‌توانید مقدار قبل از دو نقطه را حذف کنید. به عبارت دیگر، این‌ها برابرند:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

به همین ترتیب، اگر برش شما شامل آخرین بایت `String` باشد، می‌توانید عدد انتهایی را حذف کنید. این یعنی این‌ها برابرند:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

همچنین می‌توانید هر دو مقدار را حذف کنید تا برشی از کل رشته بگیرید. بنابراین این‌ها برابرند:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> **توجه:** ایندکس‌های محدوده برش رشته‌ای باید در مرزهای کاراکتر معتبر UTF-8 رخ دهند. اگر سعی کنید یک برش رشته‌ای در وسط یک کاراکتر چندبایتی ایجاد کنید، برنامه شما با خطا خارج خواهد شد. برای معرفی برش‌های رشته‌ای، در این بخش فرض می‌کنیم فقط با ASCII کار می‌کنیم؛ بحث جامع‌تر درباره مدیریت UTF-8 در بخش «ذخیره متن کدگذاری‌شده UTF-8 با رشته‌ها» در فصل هشتم است.

با در نظر گرفتن این اطلاعات، بیایید `first_word` را بازنویسی کنیم تا یک برش برگرداند. نوع که نشان‌دهنده «برش رشته‌ای» است به‌صورت `&str` نوشته می‌شود:

**نام فایل:** `src/main.rs`

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

ما ایندکس انتهای کلمه را همان‌طور که در لیست ۴-۷ انجام دادیم، با جستجوی اولین رخداد یک فاصله، به دست می‌آوریم. وقتی فاصله‌ای پیدا کردیم، یک برش رشته‌ای با استفاده از ابتدای رشته و ایندکس فاصله به‌عنوان ایندکس‌های شروع و پایان برمی‌گردانیم.

حالا وقتی `first_word` را فراخوانی می‌کنیم، یک مقدار واحد که به داده زیرین متصل است، دریافت می‌کنیم. این مقدار از یک ارجاع به نقطه شروع برش و تعداد عناصر در برش تشکیل شده است.

بازگرداندن یک برش برای یک تابع `second_word` نیز کار خواهد کرد:

```rust
fn second_word(s: &String) -> &str {
```

حالا یک API مستقیم داریم که به‌سختی می‌توان آن را خراب کرد، زیرا کامپایلر اطمینان می‌دهد که ارجاعات به `String` معتبر باقی می‌مانند. باگ در برنامه لیست ۴-۸ را به خاطر بیاورید، وقتی ایندکس انتهای اولین کلمه را گرفتیم اما سپس رشته را خالی کردیم و ایندکس ما نامعتبر شد؟ آن کد از نظر منطقی نادرست بود اما هیچ خطای فوری نشان نمی‌داد. مشکلات بعداً ظاهر می‌شدند اگر سعی می‌کردیم از ایندکس اولین کلمه با یک رشته خالی استفاده کنیم. برش‌ها این باگ را غیرممکن می‌کنند و خیلی زودتر به ما اطلاع می‌دهند که مشکلی در کدمان داریم. استفاده از نسخه برش `first_word` یک خطای زمان کامپایل تولید خواهد کرد:

**نام فایل:** `src/main.rs`

**این کد کامپایل نمی‌شود!**

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // خطا!

    println!("کلمه اول: {word}");
}
```

این خطای کامپایلر است:

```bash
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
```

از قوانین قرض‌گیری به یاد بیاورید که اگر یک ارجاع غیرقابل‌تغییر به چیزی داشته باشیم، نمی‌توانیم همزمان یک ارجاع قابل‌تغییر بگیریم. چون `clear` نیاز به کوتاه کردن `String` دارد، باید یک ارجاع قابل‌تغییر بگیرد. `println!` بعد از فراخوانی `clear` از ارجاع در `word` استفاده می‌کند، بنابراین ارجاع غیرقابل‌تغییر در آن نقطه باید همچنان فعال باشد. Rust اجازه نمی‌دهد ارجاع قابل‌تغییر در `clear` و ارجاع غیرقابل‌تغییر در `word` همزمان وجود داشته باشند، و کامپایل شکست می‌خورد. نه‌تنها Rust استفاده از API ما را آسان‌تر کرده، بلکه یک دسته کامل از خطاها را در زمان کامپایل حذف کرده است!

### رشته‌های لفظی به‌عنوان برش‌ها

به یاد بیاورید که گفتیم رشته‌های لفظی در داخل باینری ذخیره می‌شوند. حالا که درباره برش‌ها می‌دانیم، می‌توانیم رشته‌های لفظی را به‌درستی درک کنیم:

```rust
let s = "Hello, world!";
```

نوع `s` در اینجا `&str` است: این یک برش است که به نقطه خاصی از باینری اشاره می‌کند. این همچنین دلیلی است که رشته‌های لفظی غیرقابل‌تغییر هستند؛ `&str` یک ارجاع غیرقابل‌تغییر است.

### برش‌های رشته‌ای به‌عنوان پارامترها

دانستن اینکه می‌توانید برش‌هایی از لفظ‌ها و مقادیر `String` بگیرید، ما را به یک بهبود دیگر در `first_word` هدایت می‌کند، و آن امضای آن است:

```rust
fn first_word(s: &String) -> &str {
```

یک Rustacean با تجربه‌تر امضایی را که در لیست ۴-۹ نشان داده شده است می‌نویسد، زیرا به ما امکان می‌دهد از همان تابع هم روی مقادیر `&String` و هم روی مقادیر `&str` استفاده کنیم.

```rust
fn first_word(s: &str) -> &str {
```

**لیست ۴-۹:** بهبود تابع `first_word` با استفاده از یک برش رشته‌ای برای نوع پارامتر `s`

اگر یک برش رشته‌ای داشته باشیم، می‌توانیم آن را مستقیماً پاس دهیم. اگر یک `String` داشته باشیم، می‌توانیم یک برش از `String` یا یک ارجاع به `String` پاس دهیم. این انعطاف‌پذیری از اجبارهای ارجاع‌زدایی (deref coercions) بهره می‌برد، ویژگی‌ای که در بخش «اجبارهای ارجاع‌زدایی ضمنی با توابع و متدها» در فصل پانزدهم پوشش خواهیم داد.

تعریف یک تابع برای گرفتن یک برش رشته‌ای به‌جای یک ارجاع به یک `String`، API ما را عمومی‌تر و مفیدتر می‌کند بدون اینکه هیچ عملکردی را از دست بدهیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` روی برش‌های `String` کار می‌کند، چه جزئی و چه کامل.
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` همچنین روی ارجاعات به `String` کار می‌کند، که معادل
    // برش‌های کامل `String` هستند.
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` روی برش‌های رشته‌های لفظی کار می‌کند، چه جزئی و چه
    // کامل.
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // چون رشته‌های لفظی خودشان *هستند* برش‌های رشته‌ای،
    // این هم بدون سینتکس برش کار می‌کند!
    let word = first_word(my_string_literal);
}
```

### برش‌های دیگر

برش‌های رشته‌ای، همان‌طور که ممکن است تصور کنید، مختص رشته‌ها هستند. اما یک نوع برش عمومی‌تر نیز وجود دارد. این آرایه را در نظر بگیرید:

```rust
let a = [1, 2, 3, 4, 5];
```

همان‌طور که ممکن است بخواهیم به بخشی از یک رشته ارجاع دهیم، ممکن است بخواهیم به بخشی از یک آرایه ارجاع دهیم. این کار را این‌گونه انجام می‌دهیم:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

این برش نوع `&[i32]` دارد. مانند برش‌های رشته‌ای، با ذخیره یک ارجاع به اولین عنصر و یک طول کار می‌کند. از این نوع برش برای انواع دیگر مجموعه‌ها استفاده خواهید کرد. این مجموعه‌ها را وقتی در فصل هشتم درباره بردارها (vectors) صحبت کنیم، با جزئیات بحث خواهیم کرد.

### خلاصه

مفاهیم مالکیت، قرض‌گیری، و برش‌ها ایمنی حافظه را در برنامه‌های Rust در زمان کامپایل تضمین می‌کنند. زبان Rust به شما کنترلی بر استفاده از حافظه می‌دهد، همان‌طور که زبان‌های برنامه‌نویسی سیستمی دیگر این کار را می‌کنند، اما داشتن مالک داده که به‌صورت خودکار داده را وقتی مالک از محدوده خارج می‌شود پاک‌سازی می‌کند، یعنی نیازی به نوشتن و اشکال‌زدایی کد اضافی برای این کنترل ندارید.

مالکیت روی نحوه کار بسیاری از بخش‌های دیگر Rust تأثیر می‌گذارد، بنابراین در ادامه کتاب بیشتر درباره این مفاهیم صحبت خواهیم کرد. بیایید به فصل پنجم برویم و درباره گروه‌بندی قطعات داده در یک ساختار (struct) صحبت کنیم.

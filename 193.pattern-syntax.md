# سینتکس الگو

در این بخش، تمام سینتکس‌های معتبری که در الگوها می‌توان استفاده کرد را جمع‌آوری می‌کنیم و بحث می‌کنیم که چرا و چه زمانی ممکن است بخواهید از هر یک استفاده کنید.

## تطبیق با مقادیر لفظی (Literals)

همان‌طور که در فصل ششم دیدید، می‌توانید الگوها را مستقیماً با مقادیر لفظی تطبیق دهید. کد زیر چند مثال ارائه می‌دهد:

```rust
let x = 1;

match x {
    1 => println!("یک"), // one
    2 => println!("دو"), // two
    3 => println!("سه"), // three
    _ => println!("هر چیز دیگری"), // anything
}
```

این کد «یک» را چاپ می‌کند زیرا مقدار در `x` برابر 1 است. این سینتکس زمانی مفید است که بخواهید کد شما عملی را انجام دهد اگر مقدار خاصی دریافت کند.

## تطبیق با متغیرهای نام‌گذاری‌شده

متغیرهای نام‌گذاری‌شده الگوهای غیرقابل‌رد هستند که با هر مقداری مطابقت دارند، و ما در این کتاب بارها از آن‌ها استفاده کرده‌ایم. با این حال، وقتی از متغیرهای نام‌گذاری‌شده در عبارت‌های `match`، `if let`، یا `while let` استفاده می‌کنید، پیچیدگی‌ای وجود دارد. از آنجا که هر یک از این نوع عبارت‌ها یک اسکوپ جدید شروع می‌کنند، متغیرهایی که به‌عنوان بخشی از الگو در داخل عبارت اعلان می‌شوند، متغیرهایی با همان نام در خارج از عبارت را سایه می‌زنند، همان‌طور که در مورد همه متغیرها صادق است. در Listing 19-11، ما یک متغیر به نام `x` با مقدار `Some(5)` و یک متغیر `y` با مقدار 10 اعلان می‌کنیم. سپس یک عبارت `match` روی مقدار `x` ایجاد می‌کنیم. به الگوهای موجود در بازوهای `match` و `println!` در انتها نگاه کنید و سعی کنید قبل از اجرای این کد یا خواندن ادامه، حدس بزنید کد چه چیزی چاپ خواهد کرد.

**فایل: src/main.rs**

```rust
let x = Some(5);
let y = 10;

match x {
    Some(50) => println!("50 دریافت شد"), // Got 50
    Some(y) => println!("تطبیق یافت، y = {y}"), // Matched, y = {y}
    _ => println!("حالت پیش‌فرض، x = {x:?}"), // Default case, x = {x:?}
}

println!("در انتها: x = {x:?}, y = {y}"); // at the end: x = {x:?}, y = {y}
```

**Listing 19-11: یک عبارت match با بازویی که یک متغیر جدید معرفی می‌کند و متغیر y موجود را سایه می‌زند**

بیایید بررسی کنیم که وقتی عبارت `match` اجرا می‌شود چه اتفاقی می‌افتد. الگو در بازوی اول `match` با مقدار تعریف‌شده `x` مطابقت ندارد، بنابراین کد ادامه می‌یابد.

الگو در بازوی دوم `match` یک متغیر جدید به نام `y` معرفی می‌کند که با هر مقداری داخل یک مقدار `Some` مطابقت خواهد داشت. چون ما در یک اسکوپ جدید داخل عبارت `match` هستیم، این یک متغیر `y` جدید است، نه متغیر `y` که در ابتدا با مقدار 10 اعلان کردیم. این اتصال `y` جدید با هر مقداری داخل یک `Some` مطابقت خواهد داشت، که همان چیزی است که در `x` داریم. بنابراین، این `y` جدید به مقدار داخلی `Some` در `x` متصل می‌شود. آن مقدار 5 است، بنابراین عبارت برای آن بازو اجرا می‌شود و «تطبیق یافت، y = 5» را چاپ می‌کند.

اگر `x` به‌جای `Some(5)` یک مقدار `None` بود، الگوهای دو بازوی اول مطابقت نداشتند، بنابراین مقدار با زیرخط (underscore) مطابقت می‌یافت. ما متغیر `x` را در الگوی بازوی زیرخط معرفی نکردیم، بنابراین `x` در عبارت همچنان `x` خارجی است که سایه‌زده نشده است. در این مورد فرضی، `match` «حالت پیش‌فرض، x = None» را چاپ می‌کرد.

وقتی عبارت `match` تمام می‌شود، اسکوپ آن پایان می‌یابد، و اسکوپ `y` داخلی نیز همین‌طور. آخرین `println!` «در انتها: x = Some(5), y = 10» را تولید می‌کند.

برای ایجاد یک عبارت `match` که مقادیر `x` و `y` خارجی را مقایسه کند، به‌جای معرفی یک متغیر جدید که متغیر `y` موجود را سایه بزند، باید از یک شرط نگهبان تطبیق (match guard) استفاده کنیم. ما بعداً در بخش «شرط‌های اضافی با نگهبان‌های تطبیق» درباره نگهبان‌های تطبیق صحبت خواهیم کرد.

## الگوهای چندگانه

می‌توانید با استفاده از سینتکس `|`، که عملگر الگوی یا (or) است، چندین الگو را تطبیق دهید. برای مثال، در کد زیر مقدار `x` را با بازوهای `match` تطبیق می‌دهیم، که اولین آن‌ها یک گزینه یا دارد، به این معنا که اگر مقدار `x` با هر یک از مقادیر در آن بازو مطابقت داشته باشد، کد آن بازو اجرا خواهد شد:

```rust
let x = 1;

match x {
    1 | 2 => println!("یک یا دو"), // one or two
    3 => println!("سه"), // three
    _ => println!("هر چیز دیگری"), // anything
}
```

این کد «یک یا دو» را چاپ می‌کند.

## تطبیق با محدوده‌های مقادیر با ..=

سینتکس `..=` به ما امکان می‌دهد تا با یک محدوده شامل مقادیر تطبیق دهیم. در کد زیر، وقتی یک الگو با هر یک از مقادیر درون محدوده داده‌شده مطابقت داشته باشد، آن بازو اجرا خواهد شد:

```rust
let x = 5;

match x {
    1..=5 => println!("یک تا پنج"), // one through five
    _ => println!("چیز دیگری"), // something else
}
```

اگر `x` برابر 1، 2، 3، 4، یا 5 باشد، بازوی اول مطابقت خواهد داشت. این سینتکس برای مقادیر چندگانه تطبیق راحت‌تر از استفاده از عملگر `|` برای بیان همان ایده است؛ اگر بخواهیم از `|` استفاده کنیم، باید `1 | 2 | 3 | 4 | 5` را مشخص کنیم. مشخص کردن یک محدوده بسیار کوتاه‌تر است، به‌خصوص اگر بخواهیم، مثلاً، با هر عددی بین 1 تا 1000 تطبیق دهیم!

کامپایلر در زمان کامپایل بررسی می‌کند که محدوده خالی نباشد، و چون تنها نوع‌هایی که Rust می‌تواند تشخیص دهد که یک محدوده خالی است یا نه، مقادیر عددی و کاراکتری هستند، محدوده‌ها فقط با مقادیر عددی یا کاراکتری مجاز هستند.

اینجا یک مثال با استفاده از محدوده‌های مقادیر کاراکتری آورده شده است:

```rust
let x = 'c';

match x {
    'a'..='j' => println!("حرف ASCII اولیه"), // early ASCII letter
    'k'..='z' => println!("حرف ASCII پایانی"), // late ASCII letter
    _ => println!("چیز دیگری"), // something else
}
```

Rust می‌تواند تشخیص دهد که 'c' در محدوده الگوی اول قرار دارد و «حرف ASCII اولیه» را چاپ می‌کند.

## تجزیه (Destructuring) برای تفکیک مقادیر

ما همچنین می‌توانیم از الگوها برای تجزیه ساختارها، شمارش‌ها، و تاپل‌ها استفاده کنیم تا از بخش‌های مختلف این مقادیر استفاده کنیم. بیایید هر مقدار را بررسی کنیم.

### تجزیه ساختارها

Listing 19-12 یک ساختار `Point` با دو فیلد `x` و `y` را نشان می‌دهد که می‌توانیم با استفاده از یک الگو با یک عبارت `let` آن را تفکیک کنیم.

**فایل: src/main.rs**

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

**Listing 19-12: تجزیه فیلدهای یک ساختار به متغیرهای جداگانه**

این کد متغیرهای `a` و `b` را ایجاد می‌کند که با مقادیر فیلدهای `x` و `y` از ساختار `p` مطابقت دارند. این مثال نشان می‌دهد که نام متغیرها در الگو لازم نیست با نام فیلدهای ساختار مطابقت داشته باشد. با این حال، معمول است که نام متغیرها را با نام فیلدها مطابقت دهیم تا به خاطر آوردن اینکه کدام متغیر از کدام فیلد آمده آسان‌تر باشد. به دلیل این استفاده رایج، و چون نوشتن `let Point { x: x, y: y } = p;` شامل تکرار زیادی است، Rust یک میانبر برای الگوهایی که فیلدهای ساختار را تطبیق می‌دهند ارائه می‌دهد: فقط باید نام فیلد ساختار را فهرست کنید، و متغیرهای ایجادشده از الگو نام‌های یکسانی خواهند داشت. Listing 19-13 به همان روش کد در Listing 19-12 رفتار می‌کند، اما متغیرهای ایجادشده در الگوی `let` به‌جای `a` و `b`، `x` و `y` هستند.

**فایل: src/main.rs**

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

**Listing 19-13: تجزیه فیلدهای ساختار با استفاده از میانبر فیلد ساختار**

این کد متغیرهای `x` و `y` را ایجاد می‌کند که با فیلدهای `x` و `y` متغیر `p` مطابقت دارند. نتیجه این است که متغیرهای `x` و `y` شامل مقادیر ساختار `p` هستند.

ما همچنین می‌توانیم با مقادیر لفظی به‌عنوان بخشی از الگوی ساختار به‌جای ایجاد متغیر برای همه فیلدها تجزیه کنیم. این کار به ما امکان می‌دهد برخی از فیلدها را برای مقادیر خاص آزمایش کنیم در حالی که متغیرهایی برای تجزیه سایر فیلدها ایجاد می‌کنیم.

در Listing 19-14، یک عبارت `match` داریم که مقادیر `Point` را به سه مورد جدا می‌کند: نقاطی که مستقیماً روی محور x قرار دارند (که وقتی `y = 0` درست است)، روی محور y (وقتی `x = 0`)، یا روی هیچ‌کدام از محورها.

**فایل: src/main.rs**

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("روی محور x در {x}"), // On the x axis at {x}
        Point { x: 0, y } => println!("روی محور y در {y}"), // On the y axis at {y}
        Point { x, y } => {
            println!("روی هیچ محوری نیست: ({x}, {y})"); // On neither axis: ({x}, {y})
        }
    }
}
```

**Listing 19-14: تجزیه و تطبیق مقادیر لفظی در یک الگو**

بازوی اول با مشخص کردن اینکه فیلد `y` اگر مقدارش با لفظی 0 مطابقت داشته باشد، با هر نقطه‌ای که روی محور x قرار دارد مطابقت خواهد داشت. الگو همچنان یک متغیر `x` ایجاد می‌کند که می‌توانیم در کد این بازو استفاده کنیم.

به‌طور مشابه، بازوی دوم با مشخص کردن اینکه فیلد `x` اگر مقدارش 0 باشد با هر نقطه‌ای روی محور y مطابقت خواهد داشت و یک متغیر `y` برای مقدار فیلد `y` ایجاد می‌کند. بازوی سوم هیچ لفظی مشخص نمی‌کند، بنابراین با هر `Point` دیگری مطابقت دارد و متغیرهایی برای هر دو فیلد `x` و `y` ایجاد می‌کند.

در این مثال، مقدار `p` با بازوی دوم مطابقت دارد به دلیل اینکه `x` شامل 0 است، بنابراین این کد «روی محور y در 7» را چاپ خواهد کرد.

به یاد داشته باشید که یک عبارت `match` پس از یافتن اولین الگوی مطابقت‌کننده، بررسی بازوها را متوقف می‌کند، بنابراین حتی اگر `Point { x: 0, y: 0}` روی محور x و محور y باشد، این کد فقط «روی محور x در 0» را چاپ می‌کرد.

### تجزیه شمارش‌ها

ما در این کتاب شمارش‌ها را تجزیه کرده‌ایم (برای مثال، Listing 6-5)، اما هنوز به‌طور صریح بحث نکرده‌ایم که الگو برای تجزیه یک شمارش با نحوه تعریف داده‌های ذخیره‌شده در شمارش مطابقت دارد. به‌عنوان مثال، در Listing 19-15 از شمارش `Message` از Listing 6-2 استفاده می‌کنیم و یک `match` با الگوهایی می‌نویسیم که هر مقدار داخلی را تجزیه می‌کند.

**فایل: src/main.rs**

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("گونه Quit هیچ داده‌ای برای تجزیه ندارد."); // The Quit variant has no data to destructure.
        }
        Message::Move { x, y } => {
            println!("حرکت در جهت x به اندازه {x} و در جهت y به اندازه {y}"); // Move in the x direction {x} and in the y direction {y}
        }
        Message::Write(text) => {
            println!("پیام متنی: {text}"); // Text message: {text}
        }
        Message::ChangeColor(r, g, b) => {
            println!("تغییر رنگ به قرمز {r}، سبز {g}، و آبی {b}"); // Change color to red {r}, green {g}, and blue {b}
        }
    }
}
```

**Listing 19-15: تجزیه گونه‌های شمارش که انواع مختلف مقادیر را نگه می‌دارند**

این کد «تغییر رنگ به قرمز 0، سبز 160، و آبی 255» را چاپ خواهد کرد. مقدار `msg` را تغییر دهید تا کد بازوهای دیگر را اجرا کنید.

برای گونه‌های شمارش بدون داده، مانند `Message::Quit`، نمی‌توانیم مقدار را بیشتر تجزیه کنیم. فقط می‌توانیم روی مقدار لفظی `Message::Quit` تطبیق دهیم، و هیچ متغیری در آن الگو وجود ندارد.

برای گونه‌های شمارش شبیه ساختار، مانند `Message::Move`، می‌توانیم از الگویی مشابه الگویی که برای تطبیق ساختارها مشخص می‌کنیم استفاده کنیم. پس از نام گونه، کروشه‌ها قرار می‌دهیم و سپس فیلدها را با متغیرها فهرست می‌کنیم تا قطعات را برای استفاده در کد این بازو تفکیک کنیم. اینجا از فرم میانبر همان‌طور که در Listing 19-13 کردیم استفاده می‌کنیم.

برای گونه‌های شمارش شبیه تاپل، مانند `Message::Write` که یک تاپل با یک عنصر را نگه می‌دارد و `Message::ChangeColor` که یک تاپل با سه عنصر را نگه می‌دارد، الگو مشابه الگویی است که برای تطبیق تاپل‌ها مشخص می‌کنیم. تعداد متغیرها در الگو باید با تعداد عناصر در گونه‌ای که تطبیق می‌دهیم مطابقت داشته باشد.

### تجزیه ساختارها و شمارش‌های تو در تو

تا کنون، تمام مثال‌های ما تطبیق ساختارها یا شمارش‌ها در یک سطح بوده است، اما تطبیق می‌تواند روی موارد تو در تو نیز کار کند! برای مثال، می‌توانیم کد در Listing 19-15 را بازسازی کنیم تا از رنگ‌های RGB و HSV در پیام `ChangeColor` پشتیبانی کند، همان‌طور که در Listing 19-16 نشان داده شده است.

```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("تغییر رنگ به قرمز {r}، سبز {g}، و آبی {b}"); // Change color to red {r}, green {g}, and blue {b}
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("تغییر رنگ به رنگ {h}، اشباع {s}، مقدار {v}"); // Change color to hue {h}, saturation {s}, value {v}
        }
        _ => (),
    }
}
```

**Listing 19-16: تطبیق روی شمارش‌های تو در تو**

الگوی بازوی اول در عبارت `match` با یک گونه شمارش `Message::ChangeColor` که شامل یک گونه `Color::Rgb` است مطابقت دارد؛ سپس الگو به سه مقدار `i32` داخلی متصل می‌شود. الگوی بازوی دوم نیز با یک گونه شمارش `Message::ChangeColor` مطابقت دارد، اما شمارش داخلی به‌جای آن با `Color::Hsv` مطابقت دارد. ما می‌توانیم این شرایط پیچیده را در یک عبارت `match` مشخص کنیم، حتی اگر دو شمارش درگیر باشند.

### تجزیه ساختارها و تاپل‌ها

ما می‌توانیم الگوهای تجزیه را به روش‌های پیچیده‌تر مخلوط، تطبیق، و تو در تو کنیم. مثال زیر یک تجزیه پیچیده را نشان می‌دهد که در آن ساختارها و تاپل‌ها را داخل یک تاپل تو در تو می‌کنیم و تمام مقادیر ابتدایی را تجزیه می‌کنیم:

```rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```

این کد به ما امکان می‌دهد تا انواع پیچیده را به اجزای تشکیل‌دهنده‌شان تفکیک کنیم تا بتوانیم از مقادیر مورد علاقه‌مان به‌صورت جداگانه استفاده کنیم.

تجزیه با الگوها روشی راحت برای استفاده از قطعات مقادیر، مانند مقدار هر فیلد در یک ساختار، به‌صورت جداگانه از یکدیگر است.

## نادیده گرفتن مقادیر در یک الگو

دیده‌اید که گاهی اوقات نادیده گرفتن مقادیر در یک الگو مفید است، مانند در بازوی آخر یک `match`، برای به دست آوردن یک همه‌گیر که در واقع کاری انجام نمی‌دهد اما تمام مقادیر ممکن باقی‌مانده را در نظر می‌گیرد. چند راه برای نادیده گرفتن کل مقادیر یا بخش‌هایی از مقادیر در یک الگو وجود دارد: استفاده از الگوی `_` (که دیده‌اید)، استفاده از الگوی `_` درون الگوی دیگر، استفاده از نامی که با زیرخط شروع می‌شود، یا استفاده از `..` برای نادیده گرفتن بخش‌های باقی‌مانده یک مقدار. بیایید بررسی کنیم که چگونه و چرا از هر یک از این الگوها استفاده کنیم.

### نادیده گرفتن یک مقدار کامل با _

ما از زیرخط به‌عنوان یک الگوی عمومی (wildcard) استفاده کرده‌ایم که با هر مقداری مطابقت دارد اما به مقدار متصل نمی‌شود. این به‌ویژه به‌عنوان بازوی آخر در یک عبارت `match` مفید است، اما می‌توانیم از آن در هر الگویی، از جمله پارامترهای تابع، همان‌طور که در Listing 19-17 نشان داده شده است، استفاده کنیم.

**فایل: src/main.rs**

```rust
fn foo(_: i32, y: i32) {
    println!("این کد فقط از پارامتر y استفاده می‌کند: {y}"); // This code only uses the y parameter: {y}
}

fn main() {
    foo(3, 4);
}
```

**Listing 19-17: استفاده از _ در امضای تابع**

این کد مقدار 3 که به‌عنوان آرگومان اول پاس داده شده است را کاملاً نادیده می‌گیرد و «این کد فقط از پارامتر y استفاده می‌کند: 4» را چاپ خواهد کرد.

در اکثر موارد، وقتی دیگر به یک پارامتر تابع خاص نیازی ندارید، امضا را تغییر می‌دهید تا پارامتر استفاده‌نشده را شامل نشود. نادیده گرفتن یک پارامتر تابع می‌تواند به‌ویژه در مواردی مفید باشد، برای مثال، وقتی یک ویژگی را پیاده‌سازی می‌کنید که به امضای نوع خاصی نیاز دارید اما بدنه تابع در پیاده‌سازی شما به یکی از پارامترها نیازی ندارد. سپس از دریافت هشدار کامپایلر درباره پارامترهای تابع استفاده‌نشده جلوگیری می‌کنید، همان‌طور که اگر به‌جای آن از یک نام استفاده می‌کردید.

### نادیده گرفتن بخش‌هایی از یک مقدار با _

ما همچنین می‌توانیم از `_` درون الگوی دیگری استفاده کنیم تا فقط بخشی از یک مقدار را نادیده بگیریم، برای مثال، وقتی می‌خواهیم فقط برای بخشی از یک مقدار آزمایش کنیم اما برای بخش‌های دیگر در کدی که می‌خواهیم اجرا کنیم استفاده‌ای نداریم. Listing 19-18 کدی را نشان می‌دهد که مسئول مدیریت مقدار یک تنظیم است. نیازهای کسب‌وکار این است که کاربر نباید اجازه داشته باشد یک تنظیم سفارشی‌سازی‌شده موجود را بازنویسی کند اما می‌تواند تنظیم را لغو کند و اگر در حال حاضر تنظیم نشده باشد، مقداری به آن بدهد.

```rust
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("نمی‌توان یک مقدار سفارشی‌سازی‌شده موجود را بازنویسی کرد"); // Can't overwrite an existing customized value
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("تنظیم برابر است با {setting_value:?}"); // setting is {setting_value:?}
```

**Listing 19-18: استفاده از زیرخط درون الگوهایی که با گونه‌های Some مطابقت دارند وقتی نیازی به استفاده از مقدار داخل Some نداریم**

این کد «نمی‌توان یک مقدار سفارشی‌سازی‌شده موجود را بازنویسی کرد» و سپس «تنظیم برابر است با Some(5)» را چاپ خواهد کرد. در بازوی اول `match`، نیازی به تطبیق یا استفاده از مقادیر داخل هر گونه `Some` نداریم، اما باید مورد را آزمایش کنیم که `setting_value` و `new_setting_value` گونه `Some` باشند. در آن صورت، دلیل عدم تغییر `setting_value` را چاپ می‌کنیم و تغییر نمی‌یابد.

در تمام موارد دیگر (اگر `setting_value` یا `new_setting_value` برابر `None` باشد) که توسط الگوی `_` در بازوی دوم بیان شده است، می‌خواهیم به `new_setting_value` اجازه دهیم به `setting_value` تبدیل شود.

ما همچنین می‌توانیم از زیرخط‌ها در چندین مکان درون یک الگو برای نادیده گرفتن مقادیر خاص استفاده کنیم. Listing 19-19 مثالی از نادیده گرفتن مقادیر دوم و چهارم در یک تاپل با پنج آیتم را نشان می‌دهد.

```rust
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("برخی اعداد: {first}, {third}, {fifth}"); // Some numbers: {first}, {third}, {fifth}
    }
}
```

**Listing 19-19: نادیده گرفتن چندین بخش از یک تاپل**

این کد «برخی اعداد: 2, 8, 32» را چاپ خواهد کرد، و مقادیر 4 و 16 نادیده گرفته می‌شوند.

### نادیده گرفتن یک متغیر استفاده‌نشده با شروع نام آن با _

اگر متغیری ایجاد کنید اما در هیچ جایی از آن استفاده نکنید، Rust معمولاً یک هشدار صادر می‌کند زیرا یک متغیر استفاده‌نشده می‌تواند نشانه یک اشکال باشد. با این حال، گاهی اوقات مفید است که بتوانید متغیری ایجاد کنید که هنوز از آن استفاده نمی‌کنید، مانند وقتی در حال نمونه‌سازی یا شروع یک پروژه هستید. در این موقعیت، می‌توانید به Rust بگویید که درباره متغیر استفاده‌نشده هشدار ندهد با شروع نام متغیر با یک زیرخط. در Listing 19-20، دو متغیر استفاده‌نشده ایجاد می‌کنیم، اما وقتی این کد را کامپایل کنیم، فقط باید درباره یکی از آن‌ها هشدار دریافت کنیم.

**فایل: src/main.rs**

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

**Listing 19-20: شروع نام یک متغیر با زیرخط برای جلوگیری از دریافت هشدارهای متغیر استفاده‌نشده**

در اینجا، ما درباره عدم استفاده از متغیر `y` هشدار دریافت می‌کنیم، اما درباره عدم استفاده از `_x` هشداری دریافت نمی‌کنیم.

توجه کنید که تفاوت ظریفی بین استفاده صرف از `_` و استفاده از نامی که با زیرخط شروع می‌شود وجود دارد. سینتکس `_x` همچنان مقدار را به متغیر متصل می‌کند، در حالی که `_` اصلاً متصل نمی‌شود. برای نشان دادن موردی که این تمایز اهمیت دارد، Listing 19-21 برای ما یک خطا فراهم می‌کند.

```rust
// این کد کامپایل نمی‌شود!
let s = Some(String::from("سلام!")); // Hello!

if let Some(_s) = s {
    println!("یک رشته یافت شد"); // found a string
}

println!("{s:?}");
```

**Listing 19-21: یک متغیر استفاده‌نشده که با زیرخط شروع می‌شود همچنان مقدار را متصل می‌کند، که ممکن است مالکیت مقدار را بگیرد**

ما یک خطا دریافت خواهیم کرد زیرا مقدار `s` همچنان به `_s` منتقل می‌شود، که مانع استفاده مجدد از `s` می‌شود. با این حال، استفاده از زیرخط به‌تنهایی هرگز به مقدار متصل نمی‌شود. Listing 19-22 بدون هیچ خطایی کامپایل خواهد شد زیرا `s` به چیزی متصل نمی‌شود؛ منتقل نمی‌شود.

```rust
let s = Some(String::from("سلام!")); // Hello!

if let Some(_) = s {
    println!("یک رشته یافت شد"); // found a string
}

println!("{s:?}");
```

**Listing 19-22: استفاده از زیرخط مقدار را متصل نمی‌کند**

این کد به‌خوبی کار می‌کند زیرا ما هرگز `s` را به چیزی متصل نمی‌کنیم؛ منتقل نمی‌شود.

### نادیده گرفتن بخش‌های باقی‌مانده یک مقدار با ..

با مقادیر دارای بخش‌های زیاد، می‌توانیم از سینتکس `..` استفاده کنیم تا بخش‌های خاصی را استفاده کنیم و بقیه را نادیده بگیریم، و از نیاز به فهرست کردن زیرخط‌ها برای هر مقدار نادیده‌گرفته‌شده جلوگیری کنیم. الگوی `..` هر بخش از مقداری که به‌صراحت در بقیه الگو تطبیق نداده‌ایم را نادیده می‌گیرد. در Listing 19-23، ما یک ساختار `Point` داریم که یک مختصات در فضای سه‌بعدی را نگه می‌دارد. در عبارت `match`، می‌خواهیم فقط روی مختصات `x` عمل کنیم و مقادیر فیلدهای `y` و `z` را نادیده بگیریم.

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x برابر است با {x}"), // x is {x}
}
```

**Listing 19-23: نادیده گرفتن همه فیلدهای یک Point به‌جز x با استفاده از ..**

ما مقدار `x` را فهرست می‌کنیم و سپس فقط الگوی `..` را شامل می‌شویم. این سریع‌تر از فهرست کردن `y: _` و `z: _` است، به‌خصوص وقتی با ساختارهایی کار می‌کنیم که فیلدهای زیادی دارند در موقعیت‌هایی که فقط یک یا دو فیلد مرتبط هستند.

سینتکس `..` به تعداد مقادیر مورد نیاز گسترش می‌یابد. Listing 19-24 نشان می‌دهد که چگونه از `..` با یک تاپل استفاده کنیم.

**فایل: src/main.rs**

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("برخی اعداد: {first}, {last}"); // Some numbers: {first}, {last}
        }
    }
}
```

**Listing 19-24: تطبیق فقط با مقادیر اول و آخر در یک تاپل و نادیده گرفتن همه مقادیر دیگر**

در این کد، مقدار اول و آخر با `first` و `last` تطبیق داده می‌شوند. `..` با هر چیزی در وسط تطبیق می‌یابد و آن را نادیده می‌گیرد.

با این حال، استفاده از `..` باید بدون ابهام باشد. اگر مشخص نباشد که کدام مقادیر برای تطبیق در نظر گرفته شده‌اند و کدام باید نادیده گرفته شوند، Rust یک خطا به ما می‌دهد. Listing 19-25 مثالی از استفاده غیرشفاف از `..` را نشان می‌دهد، بنابراین کامپایل نخواهد شد.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("برخی اعداد: {second}"); // Some numbers: {second}
        },
    }
}
```

**Listing 19-25: تلاش برای استفاده از .. به روشی غیرشفاف**

وقتی این مثال را کامپایل می‌کنیم، این خطا را دریافت می‌کنیم:

```
$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second, ..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
```

برای Rust غیرممکن است که تعیین کند چه تعداد مقدار در تاپل را قبل از تطبیق یک مقدار با `second` نادیده بگیرد و سپس چه تعداد مقدار دیگر را پس از آن نادیده بگیرد. این کد می‌توانست به این معنا باشد که می‌خواهیم 2 را نادیده بگیریم، `second` را به 4 متصل کنیم، و سپس 8، 16، و 32 را نادیده بگیریم؛ یا اینکه می‌خواهیم 2 و 4 را نادیده بگیریم، `second` را به 8 متصل کنیم، و سپس 16 و 32 را نادیده بگیریم؛ و غیره. نام متغیر `second` برای Rust معنای خاصی ندارد، بنابراین یک خطای کامپایلر دریافت می‌کنیم زیرا استفاده از `..` در دو مکان مانند این غیرشفاف است.

## شرط‌های اضافی با نگهبان‌های تطبیق

یک نگهبان تطبیق (match guard) یک شرط `if` اضافی است که پس از الگو در یک بازوی `match` مشخص می‌شود و باید برای انتخاب آن بازو نیز مطابقت داشته باشد. نگهبان‌های تطبیق برای بیان ایده‌های پیچیده‌تر از آنچه یک الگو به‌تنهایی اجازه می‌دهد مفید هستند. توجه کنید که آن‌ها فقط در عبارت‌های `match` در دسترس هستند، نه در عبارت‌های `if let` یا `while let`.

شرط می‌تواند از متغیرهای ایجادشده در الگو استفاده کند. Listing 19-26 یک `match` را نشان می‌دهد که بازوی اول آن الگوی `Some(x)` و همچنین یک نگهبان تطبیق `if x % 2 == 0` دارد (که اگر عدد زوج باشد درست خواهد بود).

```rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("عدد {x} زوج است"), // The number {x} is even
    Some(x) => println!("عدد {x} فرد است"), // The number {x} is odd
    None => (),
}
```

**Listing 19-26: افزودن یک نگهبان تطبیق به یک الگو**

این مثال «عدد 4 زوج است» را چاپ خواهد کرد. وقتی `num` با الگو در بازوی اول مقایسه می‌شود، مطابقت دارد زیرا `Some(4)` با `Some(x)` مطابقت دارد. سپس نگهبان تطبیق بررسی می‌کند که آیا باقی‌مانده تقسیم `x` بر 2 برابر 0 است، و چون این‌طور است، بازوی اول انتخاب می‌شود.

اگر `num` به‌جای آن `Some(5)` بود، نگهبان تطبیق در بازوی اول نادرست می‌بود زیرا باقی‌مانده 5 تقسیم بر 2 برابر 1 است که برابر 0 نیست. سپس Rust به بازوی دوم می‌رفت، که مطابقت می‌داشت زیرا بازوی دوم نگهبان تطبیق ندارد و بنابراین با هر گونه `Some` مطابقت دارد.

هیچ راهی برای بیان شرط `if x % 2 == 0` در یک الگو وجود ندارد، بنابراین نگهبان تطبیق به ما امکان بیان این منطق را می‌دهد. نقطه ضعف این بیان‌پذیری اضافی این است که کامپایلر وقتی عبارات نگهبان تطبیق درگیر باشند، برای جامعیت بررسی نمی‌کند.

در Listing 19-11، ذکر کردیم که می‌توانیم از نگهبان‌های تطبیق برای حل مشکل سایه‌زدن الگو استفاده کنیم. به یاد بیاورید که ما یک متغیر جدید داخل الگو در عبارت `match` ایجاد کردیم به‌جای استفاده از متغیر خارج از `match`. آن متغیر جدید به این معنا بود که نمی‌توانستیم با مقدار متغیر خارجی آزمایش کنیم. Listing 19-27 نشان می‌دهد که چگونه می‌توانیم از یک نگهبان تطبیق برای رفع این مشکل استفاده کنیم.

**فایل: src/main.rs**

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("50 دریافت شد"), // Got 50
        Some(n) if n == y => println!("تطبیق یافت، n = {n}"), // Matched, n = {n}
        _ => println!("حالت پیش‌فرض، x = {x:?}"), // Default case, x = {x:?}
    }

    println!("در انتها: x = {x:?}, y = {y}"); // at the end: x = {x:?}, y = {y}
}
```

**Listing 19-27: استفاده از یک نگهبان تطبیق برای آزمایش برابری با یک متغیر خارجی**

این کد حالا «حالت پیش‌فرض، x = Some(5)» را چاپ خواهد کرد. الگو در بازوی دوم `match` یک متغیر جدید `y` معرفی نمی‌کند که متغیر خارجی `y` را سایه بزند، به این معنا که می‌توانیم از `y` خارجی در نگهبان تطبیق استفاده کنیم. به‌جای مشخص کردن الگو به‌عنوان `Some(y)`، که متغیر خارجی `y` را سایه می‌زد، ما `Some(n)` را مشخص می‌کنیم. این یک متغیر جدید `n` ایجاد می‌کند که چیزی را سایه نمی‌زند زیرا هیچ متغیر `n` خارج از `match` وجود ندارد.

نگهبان تطبیق `if n == y` یک الگو نیست و بنابراین متغیرهای جدیدی معرفی نمی‌کند. این `y` همان `y` خارجی است نه یک `y` جدید که آن را سایه بزند، و می‌توانیم با مقایسه `n` با `y` به دنبال مقداری باشیم که همان مقدار `y` خارجی را دارد.

شما همچنین می‌توانید از عملگر یا `|` در یک نگهبان تطبیق برای مشخص کردن چندین الگو استفاده کنید؛ شرط نگهبان تطبیق به همه الگوها اعمال خواهد شد. Listing 19-28 اولویت را وقتی یک الگو که از `|` استفاده می‌کند با یک نگهبان تطبیق ترکیب می‌شود نشان می‌دهد. بخش مهم این مثال این است که نگهبان تطبیق `if y` به 4، 5، و 6 اعمال می‌شود، حتی اگر به نظر برسد که `if y` فقط به 6 اعمال می‌شود.

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("بله"), // yes
    _ => println!("خیر"), // no
}
```

**Listing 19-28: ترکیب چندین الگو با یک نگهبان تطبیق**

شرط تطبیق بیان می‌کند که بازو فقط اگر مقدار `x` برابر 4، 5، یا 6 باشد و اگر `y` درست باشد مطابقت دارد. وقتی این کد اجرا می‌شود، الگوی بازوی اول مطابقت دارد زیرا `x` برابر 4 است، اما نگهبان تطبیق `if y` نادرست است، بنابراین بازوی اول انتخاب نمی‌شود. کد به بازوی دوم می‌رود، که مطابقت دارد، و این برنامه «خیر» را چاپ می‌کند. دلیل این است که شرط `if` به کل الگو `4 | 5 | 6` اعمال می‌شود، نه فقط به مقدار آخر 6. به عبارت دیگر، اولویت یک نگهبان تطبیق نسبت به یک الگو به این شکل رفتار می‌کند:

```rust
(4 | 5 | 6) if y => ...
```

به‌جای این:

```rust
4 | 5 | (6 if y) => ...
```

پس از اجرای کد، رفتار اولویت آشکار است: اگر نگهبان تطبیق فقط به مقدار نهایی در فهرست مقادیر مشخص‌شده با استفاده از عملگر `|` اعمال می‌شد، بازو مطابقت می‌داشت و برنامه «بله» را چاپ می‌کرد.

## اتصالات با @

عملگر `@` به ما امکان می‌دهد یک متغیر ایجاد کنیم که یک مقدار را نگه می‌دارد در حالی که همزمان آن مقدار را برای تطبیق با الگو آزمایش می‌کنیم. در Listing 19-29، می‌خواهیم آزمایش کنیم که فیلد `id` یک `Message::Hello` در محدوده `3..=7` باشد. همچنین می‌خواهیم مقدار را به متغیر `id_variable` متصل کنیم تا بتوانیم از آن در کد مرتبط با بازو استفاده کنیم. می‌توانستیم این متغیر را `id`، همنام با فیلد، بنامیم، اما برای این مثال از نام متفاوتی استفاده خواهیم کرد.

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7,
    } => println!("یک id در محدوده یافت شد: {id_variable}"), // Found an id in range: {id_variable}
    Message::Hello { id: 10..=12 } => {
        println!("یک id در محدوده دیگری یافت شد") // Found an id in another range
    }
    Message::Hello { id } => println!("id دیگری یافت شد: {id}"), // Found some other id: {id}
}
```

**Listing 19-29: استفاده از @ برای اتصال به یک مقدار در یک الگو در حالی که آن را آزمایش می‌کنیم**

این مثال «یک id در محدوده یافت شد: 5» را چاپ خواهد کرد. با مشخص کردن `id_variable @` قبل از محدوده `3..=7`، ما هر مقداری که با محدوده مطابقت داشت را ضبط می‌کنیم در حالی که آزمایش می‌کنیم که مقدار با الگوی محدوده مطابقت دارد.

در بازوی دوم، که فقط یک محدوده در الگو مشخص شده است، کد مرتبط با بازو متغیری ندارد که مقدار واقعی فیلد `id` را شامل شود. مقدار فیلد `id` می‌توانست 10، 11، یا 12 باشد، اما کد همراه با آن الگو نمی‌داند کدام است. کد الگو نمی‌تواند از مقدار فیلد `id` استفاده کند، زیرا ما مقدار `id` را در یک متغیر ذخیره نکرده‌ایم.

در بازوی آخر، که یک متغیر بدون محدوده مشخص کرده‌ایم، ما مقدار را برای استفاده در کد بازو در یک متغیر به نام `id` در دسترس داریم. دلیل این است که از سینتکس میانبر فیلد ساختار استفاده کرده‌ایم. اما ما هیچ آزمایشی روی مقدار در فیلد `id` در این بازو اعمال نکرده‌ایم، همان‌طور که در دو بازوی اول کردیم: هر مقداری با این الگو مطابقت می‌داشت.

استفاده از `@` به ما امکان می‌دهد یک مقدار را آزمایش کنیم و آن را در یک متغیر در یک الگو ذخیره کنیم.

## خلاصه

الگوهای Rust بسیار در تمایز بین انواع مختلف داده‌ها مفید هستند. وقتی در عبارت‌های `match` استفاده می‌شوند، Rust اطمینان می‌دهد که الگوهای شما هر مقدار ممکن را پوشش می‌دهند، وگرنه برنامه شما کامپایل نخواهد شد. الگوها در عبارت‌های `let` و پارامترهای تابع این ساختارها را مفیدتر می‌کنند، و امکان تجزیه مقادیر به بخش‌های کوچک‌تر را همزمان با تخصیص این بخش‌ها به متغیرها فراهم می‌کنند. ما می‌توانیم الگوهای ساده یا پیچیده را برای رفع نیازهایمان ایجاد کنیم.

در ادامه، برای فصل ماقبل آخر کتاب، به برخی جنبه‌های پیشرفته از ویژگی‌های مختلف Rust نگاه خواهیم کرد.
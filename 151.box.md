    # استفاده از `Box<T>` برای اشاره به داده‌ها در هیپ

ساده‌ترین اشاره‌گر هوشمند، **باکس (box)** است که نوع آن به‌صورت `Box<T>` نوشته می‌شود. باکس‌ها به شما امکان می‌دهند داده‌ها را به جای استک، در **هیپ** ذخیره کنید. آنچه در استک باقی می‌ماند، اشاره‌گری به داده‌های هیپ است. برای مرور تفاوت بین استک و هیپ، به فصل چهارم مراجعه کنید.

باکس‌ها سربار عملکردی ندارند، به جز اینکه داده‌هایشان را در هیپ به جای استک ذخیره می‌کنند. اما قابلیت‌های اضافی زیادی هم ندارند. بیشتر اوقات در این موقعیت‌ها از آن‌ها استفاده خواهید کرد:

- وقتی نوع‌ای دارید که اندازه‌اش در زمان کامپایل مشخص نیست و می‌خواهید از مقداری از آن نوع در زمینه‌ای استفاده کنید که نیاز به اندازه دقیق دارد.
- وقتی مقدار زیادی داده دارید و می‌خواهید مالکیت را منتقل کنید اما مطمئن شوید که داده‌ها هنگام انتقال کپی نمی‌شوند.
- وقتی می‌خواهید مالک یک مقدار باشید و فقط به این اهمیت می‌دهید که آن مقدار نوعی است که یک ویژگی‌ خاص را پیاده‌سازی می‌کند، نه اینکه نوع خاصی باشد.

ما در بخش "فعال‌سازی انواع بازگشتی با باکس‌ها" موقعیت اول را نشان خواهیم داد. در مورد دوم، انتقال مالکیت مقدار زیادی داده می‌تواند زمان‌بر باشد زیرا داده‌ها در استک کپی می‌شوند. برای بهبود عملکرد در این موقعیت، می‌توانیم مقدار زیادی داده را در هیپ در یک باکس ذخیره کنیم. سپس، فقط مقدار کمی از داده‌های اشاره‌گر در استک جابه‌جا می‌شود، در حالی که داده‌هایی که به آن‌ها اشاره می‌کند در یک مکان در هیپ باقی می‌ماند. مورد سوم به‌عنوان **شیء ویژگی‌ (trait object)** شناخته می‌شود، و بخش "استفاده از اشیاء ویژگی‌ که امکان مقادیر از انواع مختلف را فراهم می‌کنند" در فصل هجدهم به این موضوع اختصاص دارد. بنابراین، آنچه در اینجا یاد می‌گیرید دوباره در آن بخش به کار خواهید برد!

## استفاده از `Box<T>` برای ذخیره داده‌ها در هیپ

قبل از اینکه به مورد استفاده ذخیره‌سازی هیپ برای `Box<T>` بپردازیم، نحو و نحوه تعامل با مقادیر ذخیره‌شده در یک `Box<T>` را پوشش خواهیم داد.

**جدول 15-1** نشان می‌دهد که چگونه از یک باکس برای ذخیره یک مقدار `i32` در هیپ استفاده کنیم.

**فایل: src/main.rs**

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```

**جدول 15-1**: ذخیره یک مقدار `i32` در هیپ با استفاده از باکس

ما متغیر `b` را تعریف می‌کنیم تا مقدار یک `Box` داشته باشد که به مقدار ۵ اشاره می‌کند، که در هیپ تخصیص داده شده است. این برنامه `b = 5` را چاپ خواهد کرد؛ در این مورد، می‌توانیم به داده‌های داخل باکس به همان شکلی دسترسی پیدا کنیم که اگر این داده‌ها در استک بودند. درست مانند هر مقدار مالک‌شده، وقتی یک باکس از حوزه خارج می‌شود، مانند `b` در انتهای `main`، آزاد می‌شود. آزادسازی هم برای باکس (ذخیره‌شده در استک) و هم برای داده‌هایی که به آن اشاره می‌کند (ذخیره‌شده در هیپ) اتفاق می‌افتد.

قرار دادن یک مقدار تکی در هیپ خیلی مفید نیست، بنابراین به‌ندرت باکس‌ها را به‌تنهایی به این شکل استفاده خواهید کرد. داشتن مقادیری مانند یک `i32` تکی در استک، جایی که به‌صورت پیش‌فرض ذخیره می‌شوند، در اکثر موقعیت‌ها مناسب‌تر است. بیایید به موردی نگاه کنیم که باکس‌ها به ما امکان می‌دهند انواعی را تعریف کنیم که اگر باکس‌ها را نداشتیم، اجازه تعریف آن‌ها را نداشتیم.

## فعال‌سازی انواع بازگشتی با باکس‌ها

یک مقدار از نوع بازگشتی می‌تواند شامل مقدار دیگری از همان نوع به‌عنوان بخشی از خودش باشد. انواع بازگشتی مشکلی ایجاد می‌کنند زیرا **Rust** باید در زمان کامپایل بداند یک نوع چقدر فضا اشغال می‌کند. با این حال، تودرتو شدن مقادیر انواع بازگشتی می‌تواند به‌صورت نظری به‌طور نامحدود ادامه یابد، بنابراین **Rust** نمی‌تواند بداند مقدار به چه مقدار فضا نیاز دارد. چون باکس‌ها اندازه مشخصی دارند، می‌توانیم با قرار دادن یک باکس در تعریف نوع بازگشتی، انواع بازگشتی را فعال کنیم.

به‌عنوان مثالی از یک نوع بازگشتی، بیایید لیست **cons** را بررسی کنیم. این یک نوع داده است که معمولاً در زبان‌های برنامه‌نویسی تابعی یافت می‌شود. نوع لیست cons که تعریف خواهیم کرد به جز بازگشتی بودن ساده است؛ بنابراین، مفاهیم در مثالی که با آن کار خواهیم کرد هر زمان که با موقعیت‌های پیچیده‌تر شامل انواع بازگشتی مواجه شوید مفید خواهند بود.

### اطلاعات بیشتر درباره لیست Cons

لیست **cons** یک ساختار داده است که از زبان برنامه‌نویسی **Lisp** و گویش‌های آن گرفته شده است، از جفت‌های تودرتویی تشکیل شده و نسخه **Lisp** از یک لیست پیوندی است. نام آن از تابع `cons` (مخفف تابع سازنده) در **Lisp** می‌آید که یک جفت جدید را از دو آرگومان خود می‌سازد. با فراخوانی `cons` روی یک جفت شامل یک مقدار و جفت دیگر، می‌توانیم لیست‌های cons ساخته‌شده از جفت‌های بازگشتی را بسازیم.

به عنوان مثال، در اینجا یک نمایش شبه‌کد از یک لیست cons شامل لیست ۱، ۲، ۳ با هر جفت در پرانتز آورده شده است:

```lisp
(1, (2, (3, Nil)))
```

هر آیتم در یک لیست cons شامل دو عنصر است: مقدار آیتم کنونی و آیتم بعدی. آخرین آیتم در لیست فقط شامل یک مقدار به نام `Nil` بدون آیتم بعدی است. یک لیست cons با فراخوانی بازگشتی تابع `cons` تولید می‌شود. نام متعارف برای نشان دادن مورد پایه بازگشتی `Nil` است. توجه کنید که این با مفهوم "null" یا "nil" که در فصل ششم بحث کردیم متفاوت است، که یک مقدار نامعتبر یا غایب است.

لیست cons یک ساختار داده رایج در **Rust** نیست. بیشتر اوقات وقتی در **Rust** لیستی از آیتم‌ها دارید، `Vec<T>` انتخاب بهتری برای استفاده است. انواع داده بازگشتی پیچیده‌تر در موقعیت‌های مختلف مفید هستند، اما با شروع با لیست cons در این فصل، می‌توانیم بررسی کنیم که چگونه باکس‌ها به ما امکان می‌دهند یک نوع داده بازگشتی را بدون حواس‌پرتی زیاد تعریف کنیم.

**جدول 15-2** شامل یک تعریف شمارشگر برای یک لیست cons است. توجه کنید که این کد هنوز کامپایل نمی‌شود زیرا نوع `List` اندازه مشخصی ندارد، که این را نشان خواهیم داد.

**فایل: src/main.rs**

**این کد کامپایل نمی‌شود!**

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

**جدول 15-2**: اولین تلاش برای تعریف یک شمارشگر برای نمایش یک ساختار داده لیست cons از مقادیر `i32`

**توجه**: ما برای اهداف این مثال یک لیست cons را پیاده‌سازی می‌کنیم که فقط مقادیر `i32` را نگه می‌دارد. می‌توانستیم با استفاده از جنریک‌ها، همان‌طور که در فصل دهم بحث کردیم، آن را پیاده‌سازی کنیم تا نوع لیست cons بتواند مقادیر از هر نوع را ذخیره کند.

استفاده از نوع `List` برای ذخیره لیست ۱، ۲، ۳ مانند کد در **جدول 15-3** خواهد بود.

**فایل: src/main.rs**

**این کد کامپایل نمی‌شود!**

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

**جدول 15-3**: استفاده از شمارشگر `List` برای ذخیره لیست ۱، ۲، ۳

مقدار `Cons` اول شامل ۱ و یک مقدار `List` دیگر است. این مقدار `List` یک مقدار `Cons` دیگر است که شامل ۲ و یک مقدار `List` دیگر است. این مقدار `List` یک مقدار `Cons` دیگر است که شامل ۳ و یک مقدار `List` است، که در نهایت `Nil` است، واریانتی غیربازگشتی که پایان لیست را نشان می‌دهد.

اگر سعی کنیم کد در **جدول 15-3** را کامپایل کنیم، خطای نشان‌داده‌شده در **جدول 15-4** را دریافت خواهیم کرد.

**فایل: output.txt**

```bash
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
```

**جدول 15-4**: خطایی که هنگام تلاش برای تعریف یک شمارشگر بازگشتی دریافت می‌کنیم

خطا نشان می‌دهد که این نوع "اندازه بی‌نهایت دارد". دلیل این است که ما `List` را با یک واریانت تعریف کرده‌ایم که بازگشتی است: آن مستقیماً مقدار دیگری از خودش را نگه می‌دارد. در نتیجه، **Rust** نمی‌تواند بفهمد برای ذخیره یک مقدار `List` به چه مقدار فضا نیاز دارد. بیایید بررسی کنیم که چرا این خطا را دریافت می‌کنیم. ابتدا به این نگاه خواهیم کرد که **Rust** چگونه تصمیم می‌گیرد برای ذخیره یک مقدار از یک نوع غیربازگشتی به چه مقدار فضا نیاز دارد.

### محاسبه اندازه یک نوع غیربازگشتی

شمارشگر `Message` را که در **جدول 6-2** در فصل ششم وقتی درباره تعریف‌های شمارشگر بحث کردیم تعریف کردیم، به یاد بیاورید:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

برای تعیین اینکه چه مقدار فضا برای یک مقدار `Message` تخصیص داده شود، **Rust** هر یک از واریانت‌ها را بررسی می‌کند تا ببیند کدام واریانت به بیشترین فضا نیاز دارد. **Rust** می‌بیند که `Message::Quit` هیچ فضایی نیاز ندارد، `Message::Move` به اندازه کافی فضا برای ذخیره دو مقدار `i32` نیاز دارد، و به همین ترتیب. چون فقط یک واریانت استفاده خواهد شد، بیشترین فضایی که یک مقدار `Message` نیاز خواهد داشت، فضایی است که برای ذخیره بزرگ‌ترین واریانتش لازم است.

در مقابل، وقتی **Rust** سعی می‌کند تعیین کند که یک نوع بازگشتی مانند شمارشگر `List` در **جدول 15-2** به چه مقدار فضا نیاز دارد، چه اتفاقی می‌افتد؟ کامپایلر با بررسی واریانت `Cons` شروع می‌کند، که شامل یک مقدار از نوع `i32` و یک مقدار از نوع `List` است. بنابراین، `Cons` به مقداری فضا برابر با اندازه یک `i32` به علاوه اندازه یک `List` نیاز دارد. برای فهمیدن اینکه نوع `List` به چه مقدار حافظه نیاز دارد، کامپایلر به واریانت‌ها نگاه می‌کند، با شروع از واریانت `Cons`. واریانت `Cons` شامل یک مقدار از نوع `i32` و یک مقدار از نوع `List` است، و این فرآیند به‌صورت بی‌نهایت ادامه می‌یابد، همان‌طور که در **شکل 15-1** نشان داده شده است.

**شکل 15-1**: یک لیست `List` بی‌نهایت شامل واریانت‌های `Cons` بی‌نهایت

<img src="img/trpl15-01.svg">

### استفاده از `Box<T>` برای به‌دست‌آوردن یک نوع بازگشتی با اندازه مشخص

چون **Rust** نمی‌تواند بفهمد برای انواع تعریف‌شده به‌صورت بازگشتی چه مقدار فضا تخصیص دهد، کامپایلر خطایی با پیشنهاد مفیدی ارائه می‌دهد:

```
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

در این پیشنهاد، **غی مستقیم بودن (indirection)** به این معنی است که به جای ذخیره مستقیم یک مقدار، باید ساختار داده را تغییر دهیم تا مقدار را به‌صورت غیرمستقیم با ذخیره یک اشاره‌گر به مقدار ذخیره کنیم.

چون یک `Box<T>` یک اشاره‌گر است، **Rust** همیشه می‌داند که یک `Box<T>` به چه مقدار فضا نیاز دارد: اندازه یک اشاره‌گر با مقدار داده‌ای که به آن اشاره می‌کند تغییر نمی‌کند. این به این معنی است که می‌توانیم یک `Box<T>` را در واریانت `Cons` به جای مقدار `List` دیگر مستقیماً قرار دهیم. `Box<T>` به مقدار `List` بعدی که در هیپ خواهد بود اشاره خواهد کرد، نه داخل واریانت `Cons`. از نظر مفهومی، ما همچنان یک لیست داریم، که با لیست‌هایی که لیست‌های دیگر را نگه می‌دارند ساخته شده است، اما این پیاده‌سازی حالا بیشتر شبیه قرار دادن آیتم‌ها کنار یکدیگر است تا داخل یکدیگر.

ما می‌توانیم تعریف شمارشگر `List` در **جدول 15-2** و استفاده از `List` در **جدول 15-3** را به کد در **جدول 15-5** تغییر دهیم، که کامپایل خواهد شد.

**فایل: src/main.rs**

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

**جدول 15-5**: تعریف `List` که از `Box<T>` استفاده می‌کند تا اندازه مشخصی داشته باشد

واریانت `Cons` به اندازه یک `i32` به علاوه فضای ذخیره داده‌های اشاره‌گر باکس نیاز دارد. واریانت `Nil` هیچ مقداری ذخیره نمی‌کند، بنابراین به فضای کمتری نسبت به واریانت `Cons` نیاز دارد. حالا می‌دانیم که هر مقدار `List` به اندازه یک `i32` به علاوه اندازه داده‌های اشاره‌گر باکس فضا اشغال خواهد کرد. با استفاده از یک باکس، زنجیره بازگشتی بی‌نهایت را شکسته‌ایم، بنابراین کامپایلر می‌تواند اندازه مورد نیاز برای ذخیره یک مقدار `List` را محاسبه کند. **شکل 15-2** نشان می‌دهد که واریانت `Cons` حالا چگونه به نظر می‌رسد.

<img src="img/trpl15-02.svg">

**شکل 15-2**: یک `List` که به دلیل نگه داشتن یک `Box` توسط `Cons` اندازه بی‌نهایت ندارد


باکس‌ها فقط غیرمستقیم بودن و تخصیص هیپ را فراهم می‌کنند؛ آن‌ها هیچ قابلیت خاص دیگری، مانند آن‌هایی که با دیگر انواع اشاره‌گر هوشمند خواهیم دید، ندارند. همچنین سربار عملکردی که این قابلیت‌های خاص ایجاد می‌کنند را ندارند، بنابراین می‌توانند در مواردی مانند لیست cons که غیرمستقیم بودن تنها ویژگی مورد نیاز ماست مفید باشند. در فصل هجدهم به موارد استفاده بیشتری برای باکس‌ها خواهیم پرداخت.

نوع `Box<T>` یک اشاره‌گر هوشمند است زیرا ویژگی‌ `Deref` را پیاده‌سازی می‌کند، که به مقادیر `Box<T>` اجازه می‌دهد مانند ارجاعات رفتار کنند. وقتی یک مقدار `Box<T>` از حوزه خارج می‌شود، داده‌های هیپ که باکس به آن‌ها اشاره می‌کند نیز به دلیل پیاده‌سازی ویژگی‌ `Drop` پاکسازی می‌شوند. این دو ویژگی‌ برای عملکردی که توسط انواع اشاره‌گر هوشمند دیگر که در بقیه این فصل بحث خواهیم کرد ارائه می‌شوند حتی مهم‌تر خواهند بود. بیایید این دو ویژگی‌ را با جزئیات بیشتری بررسی کنیم.

## بررسی ویژگی‌‌های `Deref` و `Drop` در `Box<T>`

برای درک بهتر اینکه چرا `Box<T>` یک اشاره‌گر هوشمند محسوب می‌شود، بیایید دو ویژگی‌ کلیدی که پیاده‌سازی می‌کند را بررسی کنیم: `Deref` و `Drop`.

### ویژگی‌ `Deref`

ویژگی‌ `Deref` به `Box<T>` اجازه می‌دهد مانند یک ارجاع رفتار کند. وقتی مقداری از نوع `Box<T>` دارید، می‌توانید به داده‌ای که به آن اشاره می‌کند به‌صورت شفاف دسترسی پیدا کنید، گویی مستقیماً به خود مقدار دسترسی دارید. این به لطف پیاده‌سازی ویژگی‌ `Deref` است، که به **Rust** امکان می‌دهد وقتی روی یک `Box<T>` عملگر `*` یا دسترسی به اعضای مقدار (مانند `.` برای متدها یا فیلدها) استفاده می‌شود، به‌طور خودکار مقدار داخل باکس را **dereference** کند.

به عنوان مثال، در **جدول 15-1**، ما `b` را به‌عنوان `Box::new(5)` تعریف کردیم و سپس `println!("b = {b}")` را استفاده کردیم. ماکرو `println!` می‌تواند مقدار داخل `b` را به دلیل پیاده‌سازی `Deref` روی `Box<T>` چاپ کند، که به آن اجازه می‌دهد به مقدار `5` دسترسی پیدا کند.

بیایید یک مثال دیگر را در نظر بگیریم تا این رفتار را روشن‌تر کنیم:

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y); // dereference صریح
}
```

در اینجا، `*y` مقدار داخل `Box` را استخراج می‌کند، که `5` است. بدون ویژگی‌ `Deref`، مجبور بودیم به‌صورت دستی مقدار داخل `Box` را با چیزی مانند `y.deref()` استخراج کنیم، اما پیاده‌سازی `Deref` این فرآیند را برای ما خودکار می‌کند.

### ویژگی‌ `Drop`

ویژگی‌ `Drop` به `Box<T>` اجازه می‌دهد وقتی از حوزه خارج می‌شود، داده‌های هیپ را که به آن‌ها اشاره می‌کند به‌طور خودکار پاکسازی کند. وقتی یک `Box<T>` از حوزه خارج می‌شود، **Rust** متد `drop` را از ویژگی‌ `Drop` فراخوانی می‌کند، که حافظه تخصیص‌یافته در هیپ را آزاد می‌کند. این تضمین می‌کند که هیچ نشت حافظه‌ای رخ نمی‌دهد.

به عنوان مثال، در **جدول 15-5**، وقتی متغیر `list` در انتهای `main` از حوزه خارج می‌شود، **Rust** به‌طور بازگشتی تمام `Box`ها در لیست cons را آزاد می‌کند و حافظه هیپ تخصیص‌یافته برای هر گره `Cons` و مقدار `i32` آن را پاکسازی می‌کند.

می‌توانید رفتار `Drop` را با پیاده‌سازی ویژگی‌ `Drop` برای یک نوع سفارشی و اضافه کردن پیام‌های چاپ برای ردیابی زمان آزادسازی آزمایش کنید، اما برای `Box<T>`، این رفتار به‌صورت داخلی مدیریت می‌شود و نیازی به مداخله دستی ندارد.

## مثال عملی: استفاده از `Box<T>` برای انتقال مالکیت داده‌های بزرگ

برای نشان دادن مورد دوم که در آن باکس‌ها برای انتقال مالکیت مقدار زیادی داده بدون کپی کردن مفید هستند، بیایید یک سناریو را در نظر بگیریم که در آن یک ساختار بزرگ داریم:

```rust
struct LargeData {
    data: [u8; 1000000], // 1MB داده
}

fn main() {
    let large = LargeData { data: [0; 1000000] };
    
    // انتقال مالکیت بدون Box: داده‌ها کپی می‌شوند
    let moved_large = large; // این کار 1MB داده را در استک کپی می‌کند
    
    // استفاده از Box برای انتقال فقط یک اشاره‌گر
    let boxed_large = Box::new(LargeData { data: [0; 1000000] });
    let moved_box = boxed_large; // فقط اشاره‌گر کپی می‌شود، نه 1MB داده
}
```

در این مثال، انتقال `large` به `moved_large` باعث کپی شدن کل آرایه ۱ مگابایتی در استک می‌شود، که می‌تواند کند باشد. در مقابل، انتقال `boxed_large` به `moved_box` فقط اشاره‌گر `Box` را کپی می‌کند، که بسیار سریع‌تر است زیرا داده‌های واقعی در هیپ باقی می‌مانند و کپی نمی‌شوند.

## نتیجه‌گیری

`Box<T>` یک اشاره‌گر هوشمند ساده اما قدرتمند در **Rust** است که تخصیص هیپ و غیرمستقیم بودن را فراهم می‌کند. این برای موقعیت‌هایی مانند فعال‌سازی انواع بازگشتی (مانند لیست cons)، انتقال مالکیت داده‌های بزرگ بدون کپی، و استفاده از اشیاء ویژگی‌ (که بعداً در فصل هجدهم بحث می‌شوند) ایده‌آل است. پیاده‌سازی‌های ویژگی‌‌های `Deref` و `Drop` استفاده از `Box<T>` را شهودی و ایمن می‌کنند، و اطمینان می‌دهند که می‌توانید از مزایای تخصیص هیپ بدون نگرانی در مورد مدیریت دستی حافظه بهره‌مند شوید.

در بخش‌های بعدی، به انواع اشاره‌گرهای هوشمند دیگر مانند `Rc<T>` و `RefCell<T>` خواهیم پرداخت که قابلیت‌های بیشتری مانند شمارش ارجاعات و تغییرپذیری داخلی ارائه می‌دهند، و همچنین جزئیات بیشتری درباره چگونگی استفاده از اشیاء ویژگی‌ برای مقادیر از انواع مختلف بررسی خواهیم کرد.
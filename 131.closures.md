# بسته‌بندی‌ها: توابع ناشناس که محیط خود را ضبط می‌کنند

بسته‌بندی‌ها در **Rust** توابع ناشناسی هستند که می‌توانید آن‌ها را در یک متغیر ذخیره کنید یا به‌عنوان آرگومان به توابع دیگر پاس دهید. می‌توانید بسته‌بندی را در یک مکان ایجاد کنید و سپس آن را در جای دیگری فراخوانی کنید تا در یک زمینه متفاوت ارزیابی شود. برخلاف توابع، بسته‌بندی‌ها می‌توانند مقادیر را از حوزه‌ای که در آن تعریف شده‌اند ضبط کنند. ما نشان خواهیم داد که چگونه این ویژگی‌های بسته‌بندی امکان استفاده مجدد از کد و سفارشی‌سازی رفتار را فراهم می‌کنند.

## ضبط محیط با بسته‌بندی‌ها

ابتدا بررسی خواهیم کرد که چگونه می‌توانیم از بسته‌بندی‌ها برای ضبط مقادیر از محیطی که در آن تعریف شده‌اند برای استفاده بعدی استفاده کنیم. سناریو این است: شرکت تی‌شرت ما هر از گاهی یک تی‌شرت انحصاری با نسخه محدود به شخصی در لیست پستی‌مان به‌عنوان تبلیغ هدیه می‌دهد. افراد در لیست پستی می‌توانند به‌صورت اختیاری رنگ مورد علاقه خود را به پروفایلشان اضافه کنند. اگر شخصی که برای تی‌شرت رایگان انتخاب شده رنگ مورد علاقه‌اش را مشخص کرده باشد، تی‌شرت آن رنگ را دریافت می‌کند. اگر فرد رنگ مورد علاقه‌ای مشخص نکرده باشد، رنگی را دریافت می‌کند که شرکت در حال حاضر بیشترین تعداد آن را دارد.

روش‌های زیادی برای پیاده‌سازی این وجود دارد. برای این مثال، ما از یک نوع برشمارشگر به نام `ShirtColor` استفاده می‌کنیم که شامل دو گونه `Red` و `Blue` است (برای ساده‌سازی تعداد رنگ‌ها را محدود کرده‌ایم). موجودی شرکت را با یک ساختار به نام `Inventory` نشان می‌دهیم که یک فیلد به نام `shirts` دارد و شامل یک `Vec<ShirtColor>` است که نشان‌دهنده رنگ‌های تی‌شرت‌های موجود در انبار است. متد `giveaway` تعریف‌شده روی `Inventory` ترجیح اختیاری رنگ تی‌شرت برنده تی‌شرت رایگان را دریافت می‌کند و رنگ تی‌شرتی که فرد دریافت خواهد کرد را برمی‌گرداند. این تنظیم در **جدول 13-1** نشان داده شده است:

**فایل: src/main.rs**

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

**جدول 13-1**: موقعیت هدیه شرکت تی‌شرت

فروشگاه تعریف‌شده در `main` دو تی‌شرت آبی و یک تی‌شرت قرمز برای توزیع در این تبلیغ نسخه محدود باقی‌مانده دارد. ما متد `giveaway` را برای کاربری با ترجیح تی‌شرت قرمز و کاربری بدون هیچ ترجیحی فراخوانی می‌کنیم.

دوباره، این کد می‌تواند به روش‌های زیادی پیاده‌سازی شود، و اینجا، برای تمرکز روی بسته‌بندی‌ها، به مفاهیمی که قبلاً آموخته‌اید پایبند بوده‌ایم، به جز بدنه متد `giveaway` که از یک بسته‌بندی استفاده می‌کند. در متد `giveaway`، ترجیح کاربر را به‌عنوان پارامتری از نوع `Option<ShirtColor>` دریافت می‌کنیم و متد `unwrap_or_else` را روی `user_preference` فراخوانی می‌کنیم. متد `unwrap_or_else` روی `Option<T>` توسط کتابخانه استاندارد تعریف شده است. این متد یک آرگومان می‌گیرد: یک بسته‌بندی بدون هیچ آرگومانی که مقداری از نوع `T` (همان نوع ذخیره‌شده در گونه `Some` از `Option<T>`، در این مورد `ShirtColor`) را برمی‌گرداند. اگر `Option<T>` گونه `Some` باشد، `unwrap_or_else` مقدار درون `Some` را برمی‌گرداند. اگر `Option<T>` گونه `None` باشد، `unwrap_or_else` بسته‌بندی را فراخوانی می‌کند و مقدار برگشتی توسط بسته‌بندی را برمی‌گرداند.

ما عبارت بسته‌بندی `|| self.most_stocked()` را به‌عنوان آرگومان به `unwrap_or_else` مشخص می‌کنیم. این بسته‌بندی هیچ پارامتری نمی‌گیرد (اگر بسته‌بندی پارامترهایی داشت، آن‌ها بین دو خط عمودی ظاهر می‌شدند). بدنه بسته‌بندی `self.most_stocked()` را فراخوانی می‌کند. ما بسته‌بندی را اینجا تعریف می‌کنیم، و پیاده‌سازی `unwrap_or_else` بسته‌بندی را بعداً اگر نتیجه مورد نیاز باشد ارزیابی خواهد کرد.

اجرای این کد چاپ می‌کند:

```bash
$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
```

یک جنبه جالب اینجا این است که ما یک بسته‌بندی پاس داده‌ایم که `self.most_stocked()` را روی نمونه کنونی `Inventory` فراخوانی می‌کند. کتابخانه استاندارد نیازی به دانستن چیزی درباره انواع `Inventory` یا `ShirtColor` که ما تعریف کرده‌ایم یا منطقی که می‌خواهیم در این سناریو استفاده کنیم نداشت. بسته‌بندی یک ارجاع غیرقابل تغییر به نمونه `self` از `Inventory` ضبط می‌کند و آن را با کدی که ما مشخص کرده‌ایم به متد `unwrap_or_else` پاس می‌دهد. توابع، از سوی دیگر، قادر به ضبط محیط خود به این روش نیستند.

## استنتاج نوع بسته‌بندی و حاشیه‌نویسی

تفاوت‌های بیشتری بین توابع و بسته‌بندی‌ها وجود دارد. بسته‌بندی‌ها معمولاً نیازی به حاشیه‌نویسی انواع پارامترها یا مقدار بازگشتی ندارند، برخلاف توابع `fn`. حاشیه‌نویسی‌های نوع برای توابع لازم هستند زیرا انواع بخشی از یک رابط صریح هستند که در معرض کاربران شما قرار می‌گیرند. تعریف این رابط به‌صورت سختگیرانه برای اطمینان از اینکه همه در مورد انواع مقادیری که یک تابع استفاده می‌کند و برمی‌گرداند توافق دارند مهم است. بسته‌بندی‌ها، از سوی دیگر، در چنین رابطی استفاده نمی‌شوند: آن‌ها در متغیرها ذخیره می‌شوند و بدون نام‌گذاری و در معرض قرار گرفتن برای کاربران کتابخانه‌مان استفاده می‌شوند.

بسته‌بندی‌ها معمولاً کوتاه هستند و فقط در یک زمینه محدود مرتبط هستند تا در هر سناریوی دلخواه. در این زمینه‌های محدود، کامپایلر می‌تواند انواع پارامترها و نوع بازگشتی را استنتاج کند، مشابه اینکه چگونه می‌تواند انواع اکثر متغیرها را استنتاج کند (موارد نادری وجود دارد که کامپایلر به حاشیه‌نویسی‌های نوع بسته‌بندی نیز نیاز دارد).

مانند متغیرها، اگر بخواهیم صراحت و وضوح را افزایش دهیم، می‌توانیم حاشیه‌نویسی‌های نوع را اضافه کنیم، به قیمت اینکه نسبت به آنچه واقعاً لازم است طولانی‌تر شویم. حاشیه‌نویسی انواع برای یک بسته‌بندی شبیه تعریف نشان‌داده‌شده در **جدول 13-2** خواهد بود. در این مثال، ما یک بسته‌بندی را تعریف می‌کنیم و آن را در یک متغیر ذخیره می‌کنیم به جای اینکه بسته‌بندی را در جایی که به‌عنوان آرگومان پاس می‌دهیم تعریف کنیم، همان‌طور که در **جدول 13-1** انجام دادیم.

**فایل: src/main.rs**

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
}
```

**جدول 13-2**: افزودن حاشیه‌نویسی‌های نوع اختیاری برای پارامتر و انواع مقدار بازگشتی در بسته‌بندی

با افزودن حاشیه‌نویسی‌های نوع، نحو بسته‌بندی‌ها بیشتر شبیه نحو توابع به نظر می‌رسد. اینجا ما یک تابع تعریف می‌کنیم که 1 به پارامترش اضافه می‌کند و یک بسته‌بندی که همان رفتار را دارد، برای مقایسه. ما چند فاصله اضافه کرده‌ایم تا بخش‌های مرتبط را هم‌راستا کنیم. این نشان می‌دهد که نحو بسته‌بندی چگونه شبیه نحو تابع است، به جز استفاده از خطوط عمودی و میزان نحوی که اختیاری است:

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

خط اول تعریف یک تابع را نشان می‌دهد، و خط دوم تعریف یک بسته‌بندی کاملاً حاشیه‌نویسی‌شده را نشان می‌دهد. در خط سوم، حاشیه‌نویسی‌های نوع را از تعریف بسته‌بندی حذف می‌کنیم. در خط چهارم، کروشه‌ها را حذف می‌کنیم، که اختیاری هستند زیرا بدنه بسته‌بندی فقط یک عبارت دارد. همه این‌ها تعریف‌های معتبری هستند که هنگام فراخوانی رفتار یکسانی تولید خواهند کرد. خطوط `add_one_v3` و `add_one_v4` نیاز دارند که بسته‌بندی‌ها ارزیابی شوند تا بتوانند کامپایل شوند زیرا انواع از استفاده آن‌ها استنتاج خواهند شد. این مشابه `let v = Vec::new();` است که نیاز به حاشیه‌نویسی نوع یا مقادیر نوعی برای درج در `Vec` دارد تا **Rust** بتواند نوع را استنتاج کند.

برای تعریف‌های بسته‌بندی، کامپایلر یک نوع مشخص برای هر یک از پارامترهای آن‌ها و برای مقدار بازگشتی آن‌ها استنتاج خواهد کرد. به عنوان مثال، **جدول 13-3** تعریف یک بسته‌بندی کوتاه را نشان می‌دهد که فقط مقداری که به‌عنوان پارامتر دریافت می‌کند را برمی‌گرداند. این بسته‌بندی چندان مفید نیست جز برای اهداف این مثال. توجه کنید که هیچ حاشیه‌نویسی نوع به تعریف اضافه نکرده‌ایم. چون حاشیه‌نویسی نوع وجود ندارد، می‌توانیم بسته‌بندی را با هر نوع فراخوانی کنیم، که اینجا با `String` در اولین بار انجام داده‌ایم. اگر سپس سعی کنیم `example_closure` را با یک عدد صحیح فراخوانی کنیم، خطا دریافت خواهیم کرد.

**فایل: src/main.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
```

**جدول 13-3**: تلاش برای فراخوانی یک بسته‌بندی که انواع آن با دو نوع مختلف استنتاج شده‌اند

کامپایلر این خطا را به ما می‌دهد:

```bash
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --> src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --> src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
```

اولین باری که `example_closure` را با مقدار `String` فراخوانی می‌کنیم، کامپایلر نوع `x` و نوع بازگشتی بسته‌بندی را به‌عنوان `String` استنتاج می‌کند. این انواع سپس در بسته‌بندی در `example_closure` قفل می‌شوند، و وقتی بعدی سعی می‌کنیم از نوع متفاوتی با همان بسته‌بندی استفاده کنیم، خطای نوع دریافت می‌کنیم.

## ضبط ارجاعات یا انتقال مالکیت

بسته‌بندی‌ها می‌توانند مقادیر را از محیط خود به سه روش ضبط کنند، که مستقیماً به سه روشی که یک تابع می‌تواند پارامتر بگیرد نگاشت می‌شوند: قرض گرفتن غیرقابل تغییر، قرض گرفتن قابل تغییر، و گرفتن مالکیت. بسته‌بندی بر اساس آنچه بدنه تابع با مقادیر ضبط‌شده انجام می‌دهد، تصمیم می‌گیرد که کدام یک از این‌ها را استفاده کند.

در **جدول 13-4**، ما یک بسته‌بندی تعریف می‌کنیم که یک ارجاع غیرقابل تغییر به بردار به نام `list` ضبط می‌کند زیرا فقط به یک ارجاع غیرقابل تغییر برای چاپ مقدار نیاز دارد:

**فایل: src/main.rs**

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}
```

**جدول 13-4**: تعریف و فراخوانی یک بسته‌بندی که یک ارجاع غیرقابل تغییر ضبط می‌کند

این مثال همچنین نشان می‌دهد که یک متغیر می‌تواند به تعریف یک بسته‌بندی متصل شود، و ما می‌توانیم بعداً بسته‌بندی را با استفاده از نام متغیر و پرانتزها فراخوانی کنیم، گویی نام متغیر نام یک تابع است.

چون می‌توانیم چندین ارجاع غیرقابل تغییر به `list` را همزمان داشته باشیم، `list` همچنان از کد قبل از تعریف بسته‌بندی، بعد از تعریف بسته‌بندی اما قبل از فراخوانی بسته‌بندی، و بعد از فراخوانی بسته‌بندی قابل دسترسی است. این کد کامپایل می‌شود، اجرا می‌شود و چاپ می‌کند:

```bash
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
```

بعد، در **جدول 13-5**، بدنه بسته‌بندی را تغییر می‌دهیم تا یک عنصر به بردار `list` اضافه کند. بسته‌بندی حالا یک ارجاع قابل تغییر ضبط می‌کند:

**فایل: src/main.rs**

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}
```

**جدول 13-5**: تعریف و فراخوانی یک بسته‌بندی که یک ارجاع قابل تغییر ضبط می‌کند

این کد کامپایل می‌شود، اجرا می‌شود و چاپ می‌کند:

```bash
$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
```

توجه کنید که دیگر یک `println!` بین تعریف و فراخوانی بسته‌بندی `borrows_mutably` وجود ندارد: وقتی `borrows_mutably` تعریف می‌شود، یک ارجاع قابل تغییر به `list` ضبط می‌کند. ما بسته‌بندی را بعد از فراخوانی بسته‌بندی دوباره استفاده نمی‌کنیم، بنابراین قرض قابل تغییر پایان می‌یابد. بین تعریف بسته‌بندی و فراخوانی بسته‌بندی، یک قرض غیرقابل تغییر برای چاپ مجاز نیست زیرا وقتی یک قرض قابل تغییر وجود دارد، هیچ قرض دیگری مجاز نیست. سعی کنید یک `println!` آنجا اضافه کنید تا ببینید چه پیام خطایی دریافت می‌کنید!

اگر بخواهید بسته‌بندی را مجبور کنید که مالکیت مقادیری که در محیط استفاده می‌کند را بگیرد، حتی اگر بدنه بسته‌بندی به‌طور سختگیرانه به مالکیت نیاز نداشته باشد، می‌توانید از کلمه کلیدی `move` قبل از لیست پارامترها استفاده کنید.

این تکنیک عمدتاً زمانی مفید است که یک بسته‌بندی را به یک رشته جدید پاس می‌دهید تا داده‌ها را منتقل کنید تا توسط رشته جدید مالک شوند. ما در فصل شانزدهم درباره رشته‌ها و اینکه چرا می‌خواهید از آن‌ها استفاده کنید به‌طور مفصل بحث خواهیم کرد وقتی درباره هم‌زمانی صحبت می‌کنیم، اما برای حالا، بیایید به‌طور مختصر ایجاد یک رشته جدید با استفاده از یک بسته‌بندی که به کلمه کلیدی `move` نیاز دارد را بررسی کنیم. **جدول 13-6** کد **جدول 13-4** را اصلاح‌شده نشان می‌دهد تا بردار را در یک رشته جدید چاپ کند به جای رشته اصلی:

**فایل: src/main.rs**

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}
```

**جدول 13-6**: استفاده از `move` برای مجبور کردن بسته‌بندی برای رشته به گرفتن مالکیت `list`

ما یک رشته جدید ایجاد می‌کنیم و به رشته یک بسته‌بندی برای اجرا به‌عنوان آرگومان می‌دهیم. بدنه بسته‌بندی لیست را چاپ می‌کند. در **جدول 13-4**، بسته‌بندی فقط `list` را با استفاده از یک ارجاع غیرقابل تغییر ضبط کرد زیرا این کمترین میزان دسترسی به `list` بود که برای چاپ آن نیاز بود. در این مثال، حتی اگر بدنه بسته‌بندی همچنان فقط به یک ارجاع غیرقابل تغییر نیاز دارد، باید مشخص کنیم که `list` باید با قرار دادن کلمه کلیدی `move` در ابتدای تعریف بسته‌بندی به بسته‌بندی منتقل شود. رشته جدید ممکن است قبل از بقیه رشته اصلی به پایان برسد، یا رشته اصلی ممکن است ابتدا به پایان برسد. اگر رشته اصلی مالکیت `list` را حفظ کند اما قبل از رشته جدید به پایان برسد و `list` را حذف کند، ارجاع غیرقابل تغییر در رشته نامعتبر خواهد بود. بنابراین، کامپایلر نیاز دارد که `list` به بسته‌بندی داده‌شده به رشته جدید منتقل شود تا ارجاع معتبر باشد. سعی کنید کلمه کلیدی `move` را حذف کنید یا از `list` در رشته اصلی بعد از تعریف بسته‌بندی استفاده کنید تا ببینید چه خطاهای کامپایلری دریافت می‌کنید!

## انتقال مقادیر ضبط‌شده از بسته‌بندی‌ها و صفات Fn

هنگامی که یک بسته‌بندی یک ارجاع یا مالکیت مقداری از محیطی که در آن تعریف شده است را ضبط می‌کند (بنابراین روی آنچه که، اگر چیزی، به بسته‌بندی منتقل می‌شود تأثیر می‌گذارد)، کد موجود در بدنه بسته‌بندی مشخص می‌کند که چه اتفاقی برای ارجاعات یا مقادیر هنگام ارزیابی بعدی بسته‌بندی می‌افتد (بنابراین روی آنچه که، اگر چیزی، از بسته‌بندی خارج می‌شود تأثیر می‌گذارد). بدنه یک بسته‌بندی می‌تواند هر یک از موارد زیر را انجام دهد: یک مقدار ضبط‌شده را از بسته‌بندی منتقل کند، مقدار ضبط‌شده را تغییر دهد، نه مقدار را منتقل کند و نه تغییر دهد، یا از ابتدا هیچ چیزی از محیط ضبط نکند.

نحوه ضبط و مدیریت مقادیر از محیط توسط بسته‌بندی روی این تأثیر می‌گذارد که بسته‌بندی کدام صفات را پیاده‌سازی می‌کند، و صفات راهی هستند که توابع و ساختارها می‌توانند مشخص کنند چه نوع بسته‌بندی‌هایی می‌توانند استفاده کنند. بسته‌بندی‌ها به‌صورت خودکار یک، دو یا هر سه ویژگی‌ `Fn` را به‌صورت افزودنی پیاده‌سازی می‌کنند، بسته به اینکه بدنه بسته‌بندی چگونه مقادیر را مدیریت می‌کند:

- **FnOnce** برای بسته‌بندی‌هایی اعمال می‌شود که می‌توانند یک بار فراخوانی شوند. همه بسته‌بندی‌ها حداقل این ویژگی‌ را پیاده‌سازی می‌کنند زیرا همه بسته‌بندی‌ها می‌توانند فراخوانی شوند. بسته‌بندی که مقادیر ضبط‌شده را از بدنه خود منتقل می‌کند فقط `FnOnce` را پیاده‌سازی می‌کند و هیچ یک از صفات دیگر `Fn` را، زیرا فقط یک بار می‌تواند فراخوانی شود.
- **FnMut** برای بسته‌بندی‌هایی اعمال می‌شود که مقادیر ضبط‌شده را از بدنه خود منتقل نمی‌کنند، اما ممکن است مقادیر ضبط‌شده را تغییر دهند. این بسته‌بندی‌ها می‌توانند بیش از یک بار فراخوانی شوند.
- **Fn** برای بسته‌بندی‌هایی اعمال می‌شود که مقادیر ضبط‌شده را از بدنه خود منتقل نمی‌کنند و مقادیر ضبط‌شده را تغییر نمی‌دهند، و همچنین بسته‌بندی‌هایی که هیچ چیزی از محیط خود ضبط نمی‌کنند. این بسته‌بندی‌ها می‌توانند بیش از یک بار بدون تغییر محیط خود فراخوانی شوند، که در مواردی مانند فراخوانی یک بسته‌بندی چندین بار به‌صورت هم‌زمان مهم است.

بیایید به تعریف متد `unwrap_or_else` روی `Option<T>` که در **جدول 13-1** استفاده کردیم نگاه کنیم:

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

به یاد بیاورید که `T` نوع عمومی است که نوع مقدار در گونه `Some` از یک `Option` را نشان می‌دهد. این نوع `T` همچنین نوع بازگشتی تابع `unwrap_or_else` است: کدی که `unwrap_or_else` را روی یک `Option<String>` فراخوانی می‌کند، به عنوان مثال، یک `String` دریافت خواهد کرد.

بعد، توجه کنید که تابع `unwrap_or_else` پارامتر نوع عمومی اضافی `F` دارد. نوع `F` نوع پارامتر به نام `f` است، که بسته‌بندی‌ای است که هنگام فراخوانی `unwrap_or_else` ارائه می‌دهیم.

محدودیت ویژگی‌ مشخص‌شده روی نوع عمومی `F`، `FnOnce() -> T` است، که به این معنی است که `F` باید بتواند یک بار فراخوانی شود، هیچ آرگومانی نگیرد، و یک `T` برگرداند. استفاده از `FnOnce` در محدودیت ویژگی‌ بیان می‌کند که `unwrap_or_else` حداکثر یک بار `f` را فراخوانی خواهد کرد. در بدنه `unwrap_or_else`، می‌بینیم که اگر `Option` یک `Some` باشد، `f` فراخوانی نخواهد شد. اگر `Option` یک `None` باشد، `f` یک بار فراخوانی خواهد شد. چون همه بسته‌بندی‌ها `FnOnce` را پیاده‌سازی می‌کنند، `unwrap_or_else` هر سه نوع بسته‌بندی را می‌پذیرد و تا جایی که می‌تواند انعطاف‌پذیر است.

**توجه**: اگر کاری که می‌خواهیم انجام دهیم نیازی به ضبط مقداری از محیط نداشته باشد، می‌توانیم از نام یک تابع به جای بسته‌بندی استفاده کنیم. به عنوان مثال، می‌توانیم `unwrap_or_else(Vec::new)` را روی یک مقدار `Option<Vec<T>>` فراخوانی کنیم تا اگر مقدار `None` باشد، یک بردار جدید و خالی دریافت کنیم. کامپایلر به‌صورت خودکار هر یک از صفات `Fn` که برای تعریف یک تابع قابل اعمال است را پیاده‌سازی می‌کند.

حالا بیایید به متد کتابخانه استاندارد `sort_by_key` که روی برش‌ها تعریف شده است نگاه کنیم، تا ببینیم چگونه با `unwrap_or_else` متفاوت است و چرا `sort_by_key` از `FnMut` به جای `FnOnce` برای محدودیت ویژگی‌ استفاده می‌کند. بسته‌بندی یک آرگومان به شکل ارجاع به آیتم کنونی در برش که در نظر گرفته می‌شود دریافت می‌کند و مقداری از نوع `K` که می‌تواند مرتب شود را برمی‌گرداند. این تابع زمانی مفید است که بخواهید یک برش را بر اساس یک ویژگی خاص از هر آیتم مرتب کنید. در **جدول 13-7**، ما لیستی از نمونه‌های `Rectangle` داریم و از `sort_by_key` برای مرتب کردن آن‌ها بر اساس ویژگی `width` از کم به زیاد استفاده می‌کنیم:

**فایل: src/main.rs**

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}
```

**جدول 13-7**: استفاده از `sort_by_key` برای مرتب کردن مستطیل‌ها بر اساس عرض

این کد چاپ می‌کند:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
```

دلیل اینکه `sort_by_key` برای گرفتن یک بسته‌بندی `FnMut` تعریف شده این است که بسته‌بندی را چندین بار فراخوانی می‌کند: یک بار برای هر آیتم در برش. بسته‌بندی `|r| r.width` چیزی را از محیط خود ضبط نمی‌کند، تغییر نمی‌دهد، یا از آن خارج نمی‌کند، بنابراین الزامات محدودیت ویژگی‌ را برآورده می‌کند.

در مقابل، **جدول 13-8** مثالی از یک بسته‌بندی را نشان می‌دهد که فقط ویژگی‌ `FnOnce` را پیاده‌سازی می‌کند، زیرا یک مقدار را از محیط خارج می‌کند. کامپایلر به ما اجازه نمی‌دهد این بسته‌بندی را با `sort_by_key` استفاده کنیم:

**فایل: src/main.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}
```

**جدول 13-8**: تلاش برای استفاده از یک بسته‌بندی `FnOnce` با `sort_by_key`

این یک روش پیچیده و غیرکارآمد (که کار نمی‌کند) برای تلاش برای برشمارش تعداد دفعاتی است که `sort_by_key` بسته‌بندی را هنگام مرتب‌سازی `list` فراخوانی می‌کند. این کد تلاش می‌کند این برشمارش را با فشار دادن `value`—یک `String` از محیط بسته‌بندی—به بردار `sort_operations` انجام دهد. بسته‌بندی `value` را ضبط می‌کند و سپس با انتقال مالکیت `value` به بردار `sort_operations`، `value` را از بسته‌بندی خارج می‌کند. این بسته‌بندی می‌تواند یک بار فراخوانی شود؛ تلاش برای فراخوانی آن برای بار دوم کار نخواهد کرد زیرا `value` دیگر در محیط نخواهد بود تا دوباره به `sort_operations` فشار داده شود! بنابراین، این بسته‌بندی فقط `FnOnce` را پیاده‌سازی می‌کند. وقتی سعی می‌کنیم این کد را کامپایل کنیم، این خطا را دریافت می‌کنیم که `value` نمی‌تواند از بسته‌بندی خارج شود زیرا بسته‌بندی باید `FnMut` را پیاده‌سازی کند:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --> src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
```

خطا به خطی در بدنه بسته‌بندی اشاره می‌کند که `value` را از محیط خارج می‌کند. برای رفع این مشکل، باید بدنه بسته‌بندی را تغییر دهیم تا مقادیر را از محیط خارج نکند. نگه داشتن یک برشمارشگر در محیط و افزایش مقدار آن در بدنه بسته‌بندی یک روش ساده‌تر برای برشمارش تعداد دفعاتی است که بسته‌بندی فراخوانی می‌شود. بسته‌بندی در **جدول 13-9** با `sort_by_key` کار می‌کند زیرا فقط یک ارجاع قابل تغییر به برشمارشگر `num_sort_operations` را ضبط می‌کند و بنابراین می‌تواند بیش از یک بار فراخوانی شود:

**فایل: src/main.rs**

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}
```

**جدول 13-9**: استفاده از یک بسته‌بندی `FnMut` با `sort_by_key` مجاز است

صفات `Fn` هنگام تعریف یا استفاده از توابع یا انواعی که از بسته‌بندی‌ها استفاده می‌کنند مهم هستند. در بخش بعدی، درباره تکرارسازها بحث خواهیم کرد. بسیاری از متدهای تکرارساز آرگومان‌های بسته‌بندی می‌گیرند، بنابراین این جزئیات بسته‌بندی را در ذهن داشته باشید در حالی که ادامه می‌دهیم!
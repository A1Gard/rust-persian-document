
# اشاره‌گر هوشمند شمارش مرجع `Rc<T>`

در اکثر موارد، مالکیت داده‌ها در زبان برنامه‌نویسی Rust کاملاً مشخص است: شما دقیقاً می‌دانید کدام متغیر مالک یک مقدار خاص است. اما گاهی اوقات ممکن است یک مقدار واحد چندین مالک داشته باشد. برای مثال، در ساختارهای داده‌ای گرافی، چندین یال (edge) ممکن است به یک گره (node) اشاره کنند و آن گره به‌صورت مفهومی متعلق به تمام یال‌هایی است که به آن اشاره دارند. گره نباید حذف شود مگر اینکه هیچ یالی به آن اشاره نکند و در نتیجه هیچ مالکی نداشته باشد.

برای فعال کردن مالکیت چندگانه به‌صورت صریح، باید از نوع `Rc<T>` در Rust استفاده کنید. این نوع که مخفف **Reference Counting** (شمارش مرجع) است، تعداد مراجع به یک مقدار را ردیابی می‌کند تا مشخص کند آیا آن مقدار هنوز در حال استفاده است یا خیر. اگر هیچ مرجعی به مقدار وجود نداشته باشد، آن مقدار می‌تواند بدون ایجاد مشکل در مراجع دیگر حذف شود.

> **توجه**: `Rc<T>` فقط برای سناریوهای تک‌رشته‌ای (single-threaded) مناسب است. در فصل شانزدهم، وقتی به بحث همزمانی (concurrency) می‌پردازیم، نحوه انجام شمارش مرجع در برنامه‌های چندرشته‌ای را بررسی خواهیم کرد.

تصور کنید `Rc<T>` مانند یک تلویزیون در اتاق نشیمن خانواده است. وقتی یک نفر وارد اتاق می‌شود تا تلویزیون را تماشا کند، آن را روشن می‌کند. دیگران هم می‌توانند وارد اتاق شوند و از تلویزیون استفاده کنند. وقتی آخرین نفر اتاق را ترک می‌کند، تلویزیون را خاموش می‌کند چون دیگر کسی از آن استفاده نمی‌کند. اگر کسی تلویزیون را در حالی که دیگران در حال تماشا هستند خاموش کند، قطعاً اعتراض بقیه بلند می‌شود!

از `Rc<T>` زمانی استفاده می‌کنیم که می‌خواهیم داده‌ای را روی هیپ (heap) تخصیص دهیم تا چندین بخش از برنامه ما بتوانند آن را بخوانند، اما در زمان کامپایل نمی‌توانیم مشخص کنیم کدام بخش آخرین بار استفاده از داده را تمام می‌کند. اگر می‌دانستیم کدام بخش آخر کارش تمام می‌شود، می‌توانستیم آن بخش را مالک داده کنیم و قوانین مالکیت عادی که در زمان کامپایل اعمال می‌شوند، کار را پیش می‌بردند.

## استفاده از `Rc<T>` برای اشتراک داده

بیایید به مثال لیست پیوندی (cons list) در بخش قبلی (Listing 15-5) برگردیم. در آن مثال، لیست را با استفاده از `Box<T>` تعریف کردیم. این بار، می‌خواهیم دو لیست بسازیم که هر دو مالکیت یک لیست سوم را به اشتراک بگذارند. از نظر مفهومی، این شبیه به شکل 15-3 است.

### شکل 15-3: دو لیست `b` و `c` که مالکیت یک لیست سوم `a` را به اشتراک دارند

ما یک لیست `a` می‌سازیم که شامل اعداد 5 و 10 است. سپس دو لیست دیگر می‌سازیم: لیست `b` که با عدد 3 شروع می‌شود و لیست `c` که با عدد 4 شروع می‌شود. هر دو لیست `b` و `c` به لیست `a` (که شامل 5 و 10 است) ادامه می‌دهند. به عبارت دیگر، هر دو لیست مالکیت لیست اول (شامل 5 و 10) را به اشتراک دارند.

### تلاش برای پیاده‌سازی با `Box<T>`

اگر بخواهیم این سناریو را با تعریف لیست که از `Box<T>` استفاده می‌کند پیاده‌سازی کنیم، با مشکل مواجه می‌شویم. کد زیر (Listing 15-17) کامپایل نمی‌شود:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

**خطای کامپایل:**

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --> src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
```

### توضیح خطا

متغیرهای نوع `Cons` مالک داده‌هایی هستند که نگه می‌دارند. وقتی لیست `b` را می‌سازیم، متغیر `a` به `b` منتقل (moved) می‌شود و `b` مالک `a` می‌شود. حالا وقتی می‌خواهیم دوباره از `a` برای ساخت لیست `c` استفاده کنیم، این کار مجاز نیست چون `a` قبلاً منتقل شده است.

**راه‌حل جایگزین با استفاده از ارجاعات**: می‌توانستیم تعریف `Cons` را تغییر دهیم تا به جای مالکیت، ارجاعات (references) را نگه دارد، اما در این صورت باید پارامترهای طول عمر (lifetime parameters) مشخص کنیم. این پارامترها نشان می‌دهند که هر عنصر در لیست حداقل به اندازه کل لیست عمر می‌کند. این موضوع در مثال Listing 15-17 درست است، اما در همه سناریوها صدق نمی‌کند.

### استفاده از `Rc<T>` به جای `Box<T>`

برای حل این مشکل، تعریف `List` را تغییر می‌دهیم تا به جای `Box<T>` از `Rc<T>` استفاده کند، همان‌طور که در Listing 15-18 نشان داده شده است:

<img src="img/trpl15-03.svg">

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

**توضیح کد**:
- هر نوع `Cons` حالا یک مقدار و یک `Rc<T>` نگه می‌دارد که به یک `List` اشاره می‌کند.
- وقتی `b` را می‌سازیم، به جای گرفتن مالکیت `a`، متغیر `Rc<List>` را که `a` نگه می‌دارد کلون (clone) می‌کنیم. این کار تعداد مراجع را از یک به دو افزایش می‌دهد و اجازه می‌دهد `a` و `b` مالکیت داده‌های داخل `Rc<List>` را به اشتراک بگذارند.
- به همین ترتیب، وقتی `c` را می‌سازیم، دوباره `a` را کلون می‌کنیم و تعداد مراجع از دو به سه افزایش می‌یابد.
- هر بار که `Rc::clone` را فراخوانی می‌کنیم، شمارش مرجع داده‌های داخل `Rc<List>` افزایش می‌یابد و داده‌ها تا زمانی که هیچ مرجعی به آن‌ها وجود نداشته باشد حذف نمی‌شوند.

**نکته**: ما باید یک دستور `use std::rc::Rc;` اضافه کنیم چون `Rc<T>` در پیش‌گفتار (prelude) Rust قرار ندارد.

**تفاوت `Rc::clone` و `a.clone()`**:
می‌توانستیم به جای `Rc::clone(&a)` از `a.clone()` استفاده کنیم، اما در Rust مرسوم است که از `Rc::clone` استفاده شود. پیاده‌سازی `Rc::clone` کپی عمیق (deep copy) از تمام داده‌ها انجام نمی‌دهد، بلکه فقط شمارش مرجع را افزایش می‌دهد که زمان بسیار کمی می‌برد. در مقابل، کپی عمیق داده‌ها می‌تواند زمان‌بر باشد. با استفاده از `Rc::clone`، می‌توانیم به‌راحتی بین کپی‌های عمیق و افزایش شمارش مرجع تمایز قائل شویم. وقتی به دنبال مشکلات عملکردی در کد هستیم، فقط باید به کپی‌های عمیق توجه کنیم و فراخوانی‌های `Rc::clone` را نادیده بگیریم.

## افزایش شمارش مرجع با کلون کردن `Rc<T>`

برای مشاهده نحوه تغییر شمارش مرجع، مثال Listing 15-18 را اصلاح می‌کنیم تا شمارش مراجع را هنگام ایجاد و حذف مراجع به `Rc<List>` در متغیر `a` چاپ کنیم. در Listing 15-19، تابع `main` را تغییر می‌دهیم تا یک محدوده داخلی (inner scope) برای لیست `c` داشته باشیم تا ببینیم وقتی `c` از محدوده خارج می‌شود، شمارش مرجع چگونه تغییر می‌کند.

```rust
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("شمارش مرجع پس از ایجاد a = {}", Rc::strong_count(&a)); // count after creating a
    let b = Cons(3, Rc::clone(&a));
    println!("شمارش مرجع پس از ایجاد b = {}", Rc::strong_count(&a)); // count after creating b
    {
        let c = Cons(4, Rc::clone(&a));
        println!("شمارش مرجع پس از ایجاد c = {}", Rc::strong_count(&a)); // count after creating c
    }
    println!("شمارش مرجع پس از خروج c از محدوده = {}", Rc::strong_count(&a)); // count after c goes out of scope
}
```

**خروجی کد:**

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
شمارش مرجع پس از ایجاد a = 1
شمارش مرجع پس از ایجاد b = 2
شمارش مرجع پس از ایجاد c = 3
شمارش مرجع پس از خروج c از محدوده = 2
```

**توضیح خروجی**:
- می‌بینیم که `Rc<List>` در `a` ابتدا یک شمارش مرجع برابر با 1 دارد.
- هر بار که `clone` را فراخوانی می‌کنیم، شمارش یک واحد افزایش می‌یابد.
- وقتی `c` از محدوده خارج می‌شود، شمارش یک واحد کاهش می‌یابد.
- نیازی به فراخوانی تابع خاصی برای کاهش شمارش مرجع نداریم؛ پیاده‌سازی ویژگی (trait) `Drop` به‌طور خودکار وقتی یک مقدار `Rc<T>` از محدوده خارج می‌شود، شمارش مرجع را کاهش می‌دهد.

**آنچه در این مثال نمی‌بینیم**:
وقتی `b` و سپس `a` در انتهای تابع `main` از محدوده خارج می‌شوند، شمارش به 0 می‌رسد و `Rc<List>` به‌طور کامل حذف می‌شود. استفاده از `Rc<T>` به یک مقدار اجازه می‌دهد چندین مالک داشته باشد و شمارش مرجع تضمین می‌کند که مقدار تا زمانی که حداقل یکی از مالکان وجود دارد معتبر باقی می‌ماند.

**نکته اضافی**: از طریق ارجاعات غیرقابل تغییر (immutable references)، `Rc<T>` به شما اجازه می‌دهد داده‌ها را بین بخش‌های مختلف برنامه‌تان فقط برای خواندن به اشتراک بگذارید. اگر `Rc<T>` اجازه داشتن چندین ارجاع قابل تغییر (mutable references) را هم می‌داد، ممکن بود یکی از قوانین قرض‌گیری (borrowing rules) که در فصل چهارم بحث کردیم نقض شود: داشتن چندین ارجاع قابل تغییر به یک مکان می‌تواند باعث مشکلات ناهمگونی داده‌ها و رقابت داده‌ای (data races) شود. اما تغییر دادن داده‌ها بسیار مفید است! در بخش بعدی، الگوی تغییرپذیری داخلی (interior mutability) و نوع `RefCell<T>` را بررسی می‌کنیم که می‌توانید در کنار `Rc<T>` استفاده کنید تا محدودیت غیرقابل تغییر بودن را دور بزنید.

> **توجه**: تابع `Rc::strong_count` به جای `count` نام‌گذاری شده است چون نوع `Rc<T>` یک شمارش ضعیف (weak count) هم دارد. در بخش «جلوگیری از چرخه‌های مرجع با استفاده از `Weak<T>`» کاربرد `weak_count` را بررسی خواهیم کرد.
## آوردن مسیرها به حوزه با کلمه‌کلیدی `use`

نوشتن مسیرهای کامل برای فراخوانی توابع می‌تواند ناخوشایند و تکراری باشد. در لیست ۷-۷، چه مسیر مطلق و چه نسبی را برای تابع `add_to_waitlist` انتخاب کرده باشیم، هر بار که می‌خواستیم `add_to_waitlist` را فراخوانی کنیم، باید `front_of_house` و `hosting` را هم مشخص می‌کردیم. خوشبختانه، راهی برای ساده‌سازی این فرآیند وجود دارد: می‌توانیم با استفاده از کلمه‌کلیدی `use` یک‌بار میانبری به یک مسیر ایجاد کنیم و سپس از نام کوتاه‌تر در همه جای حوزه استفاده کنیم.

در لیست ۷-۱۱، ماژول `crate::front_of_house::hosting` را به حوزه تابع `eat_at_restaurant` می‌آوریم تا فقط نیاز باشد `hosting::add_to_waitlist` را مشخص کنیم تا تابع `add_to_waitlist` را در `eat_at_restaurant` فراخوانی کنیم.

**نام فایل:** `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

**لیست ۷-۱۱:** آوردن یک ماژول به حوزه با `use`

افزودن `use` و یک مسیر در یک حوزه مشابه ایجاد یک لینک نمادین در فایل‌سیستم است. با افزودن `use crate::front_of_house::hosting` در ریشه جعبه، `hosting` حالا یک نام معتبر در آن حوزه است، درست مثل اینکه ماژول `hosting` در ریشه جعبه تعریف شده باشد. مسیرهایی که با `use` به حوزه آورده می‌شوند، مانند سایر مسیرها، قوانین حریم خصوصی را بررسی می‌کنند.

توجه کنید که `use` فقط میانبر را برای حوزه خاصی که در آن `use` رخ می‌دهد ایجاد می‌کند. لیست ۷-۱۲ تابع `eat_at_restaurant` را به یک ماژول فرزند جدید به نام `customer` منتقل می‌کند، که حوزه متفاوتی نسبت به عبارت `use` است، بنابراین بدنه تابع کامپایل نمی‌شود.

**نام فایل:** `src/lib.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
```

**لیست ۷-۱۲:** یک عبارت `use` فقط در حوزه‌ای که در آن است اعمال می‌شود

خطای کامپایلر نشان می‌دهد که میانبر دیگر در ماژول `customer` اعمال نمی‌شود:

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: نتوانست حل کند: استفاده از جعبه یا ماژول اعلان‌نشده `hosting`
  --> src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ استفاده از جعبه یا ماژول اعلان‌نشده `hosting`
   |
help: این ماژول را از طریق بازصادرات عمومی آن وارد کنید
   |
10 +     use crate::hosting;
   |

warning: واردات استفاده‌نشده: `crate::front_of_house::hosting`
 --> src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` به‌صورت پیش‌فرض فعال است

برای اطلاعات بیشتر درباره این خطا، `rustc --explain E0433` را امتحان کنید.
warning: `restaurant` (کتابخانه) یک هشدار تولید کرد
error: نتوانست جعبه `restaurant` (کتابخانه) را به دلیل 1 خطای قبلی کامپایل کند؛ 1 هشدار صادر شد
```

همچنین هشداری وجود دارد که می‌گوید `use` در حوزه‌اش دیگر استفاده نمی‌شود! برای رفع این مشکل، یا `use` را به داخل ماژول `customer` منتقل کنید، یا در ماژول فرزند `customer` به میانبر در ماژول والد با `super::hosting` ارجاع دهید.

### ایجاد مسیرهای `use` به سبک مرسوم

در لیست ۷-۱۱، ممکن است تعجب کرده باشید که چرا `use crate::front_of_house::hosting` را مشخص کردیم و سپس در `eat_at_restaurant` از `hosting::add_to_waitlist` استفاده کردیم، به‌جای اینکه مسیر `use` را تا خود تابع `add_to_waitlist` مشخص کنیم تا همان نتیجه را به دست آوریم، همان‌طور که در لیست ۷-۱۳ نشان داده شده است.

**نام فایل:** `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
```

**لیست ۷-۱۳:** آوردن تابع `add_to_waitlist` به حوزه با `use`، که غیرمرسوم است

اگرچه هر دو لیست ۷-۱۱ و ۷-۱۳ همان کار را انجام می‌دهند، لیست ۷-۱۱ روش مرسوم برای آوردن یک تابع به حوزه با `use` است. آوردن ماژول والد تابع به حوزه با `use` به این معناست که باید هنگام فراخوانی تابع، ماژول والد را مشخص کنیم. مشخص کردن ماژول والد هنگام فراخوانی تابع نشان می‌دهد که تابع به‌صورت محلی تعریف نشده است، در حالی که تکرار مسیر کامل را به حداقل می‌رساند. کد در لیست ۷-۱۳ مشخص نمی‌کند که `add_to_waitlist` کجا تعریف شده است.

از سوی دیگر، وقتی ساختارها، شمارش‌ها، و سایر موارد را با `use` به حوزه می‌آوریم، مرسوم است که مسیر کامل را مشخص کنیم. لیست ۷-۱۴ روش مرسوم برای آوردن ساختار `HashMap` از کتابخانه استاندارد به حوزه یک جعبه باینری را نشان می‌دهد.

**نام فایل:** `src/main.rs`

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

**لیست ۷-۱۴:** آوردن `HashMap` به حوزه به روش مرسوم

هیچ دلیل محکمی پشت این رسم وجود ندارد: این فقط قراردادی است که به وجود آمده و افراد به خواندن و نوشتن کد Rust به این شکل عادت کرده‌اند.

استثنای این رسم زمانی است که بخواهیم دو مورد با نام یکسان را با عبارات `use` به حوزه بیاوریم، زیرا Rust این را اجازه نمی‌دهد. لیست ۷-۱۵ نشان می‌دهد چگونه دو نوع `Result` با نام یکسان اما ماژول‌های والد متفاوت را به حوزه بیاوریم و چگونه به آن‌ها ارجاع دهیم.

**نام فایل:** `src/lib.rs`

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

**لیست ۷-۱۵:** آوردن دو نوع با نام یکسان به یک حوزه نیاز به استفاده از ماژول‌های والد آن‌ها دارد

همان‌طور که می‌بینید، استفاده از ماژول‌های والد دو نوع `Result` را متمایز می‌کند. اگر به‌جای آن `use std::fmt::Result` و `use std::io::Result` را مشخص کنیم، دو نوع `Result` در یک حوزه خواهیم داشت و Rust نمی‌داند وقتی از `Result` استفاده می‌کنیم، کدام‌یک را منظور کرده‌ایم.

### ارائه نام‌های جدید با کلمه‌کلیدی `as`

راه‌حل دیگری برای مشکل آوردن دو نوع با نام یکسان به یک حوزه با `use` وجود دارد: پس از مسیر، می‌توانیم `as` و یک نام محلی جدید یا نام مستعار برای نوع مشخص کنیم. لیست ۷-۱۶ روش دیگری برای نوشتن کد در لیست ۷-۱۵ را با تغییر نام یکی از دو نوع `Result` با استفاده از `as` نشان می‌دهد.

**نام فایل:** `src/lib.rs`

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```

**لیست ۷-۱۶:** تغییر نام یک نوع هنگام آوردن آن به حوزه با کلمه‌کلیدی `as`

در عبارت دوم `use`، نام جدید `IoResult` را برای نوع `std::io::Result` انتخاب کردیم، که با `Result` از `std::fmt` که به حوزه آورده‌ایم، تداخل نخواهد داشت. لیست ۷-۱۵ و ۷-۱۶ هر دو مرسوم در نظر گرفته می‌شوند، بنابراین انتخاب با شماست!

### بازصادرات نام‌ها با `pub use`

وقتی نامی را با کلمه‌کلیدی `use` به حوزه می‌آوریم، آن نام در حوزه‌ای که به آن وارد شده خصوصی است. برای اینکه کد خارج از آن حوزه بتواند به آن نام ارجاع دهد، انگار که در آن حوزه تعریف شده است، می‌توانیم `pub` و `use` را ترکیب کنیم. این تکنیک **بازصادرات (re-exporting)** نامیده می‌شود، زیرا ما یک مورد را به حوزه می‌آوریم و همزمان آن را برای دیگران در دسترس قرار می‌دهیم تا به حوزه خودشان بیاورند.

لیست ۷-۱۷ کد در لیست ۷-۱۱ را نشان می‌دهد که `use` در ماژول ریشه به `pub use` تغییر کرده است.

**نام فایل:** `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

**لیست ۷-۱۷:** در دسترس قرار دادن یک نام برای هر کدی با `pub use`

قبل از این تغییر، کد خارجی باید تابع `add_to_waitlist` را با استفاده از مسیر `restaurant::front_of_house::hosting::add_to_waitlist()` فراخوانی می‌کرد، که همچنین نیاز داشت ماژول `front_of_house` به‌عنوان `pub` علامت‌گذاری شود. حالا که این `pub use` ماژول `hosting` را از ماژول ریشه بازصادرات کرده است، کد خارجی می‌تواند به‌جای آن از مسیر `restaurant::hosting::add_to_waitlist()` استفاده کند.

بازصادرات وقتی مفید است که ساختار داخلی کد شما با نحوه تفکر برنامه‌نویسان درباره حوزه متفاوت باشد. برای مثال، در این استعاره رستوران، افرادی که رستوران را اداره می‌کنند به «جلوی سالن» و «پشت سالن» فکر می‌کنند. اما مشتریانی که از رستوران بازدید می‌کنند احتمالاً بخش‌های رستوران را با این اصطلاحات در نظر نمی‌گیرند. با `pub use`، می‌توانیم کدمان را با یک ساختار بنویسیم اما ساختار متفاوتی را آشکار کنیم. این کار کتابخانه ما را هم برای برنامه‌نویسانی که روی کتابخانه کار می‌کنند و هم برای برنامه‌نویسانی که کتابخانه را فراخوانی می‌کنند، سازمان‌یافته می‌کند. در فصل چهاردهم، مثال دیگری از `pub use` و تأثیر آن بر مستندات جعبه‌تان را در «صادرات یک API عمومی راحت با `pub use`» بررسی خواهیم کرد.

### استفاده از بسته‌های خارجی

در فصل دوم، پروژه بازی حدس زدن را برنامه‌نویسی کردیم که از یک بسته خارجی به نام `rand` برای دریافت اعداد تصادفی استفاده کرد. برای استفاده از `rand` در پروژه‌مان، این خط را به `Cargo.toml` اضافه کردیم:

**نام فایل:** `Cargo.toml`

```toml
rand = "0.8.5"
```

افزودن `rand` به‌عنوان یک وابستگی در `Cargo.toml` به Cargo می‌گوید که بسته `rand` و هر وابستگی‌اش را از crates.io دانلود کند و `rand` را برای پروژه ما در دسترس قرار دهد.

سپس، برای آوردن تعریف‌های `rand` به حوزه بسته‌مان، یک خط `use` اضافه کردیم که با نام جعبه، `rand`، شروع می‌شد و مواردی که می‌خواستیم به حوزه بیاوریم را فهرست کردیم. به یاد بیاورید که در بخش «تولید یک عدد تصادفی» در فصل دوم، ویژگی‌ `Rng` را به حوزه آوردیم و تابع `rand::thread_rng` را فراخوانی کردیم:

```rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
```

اعضای جامعه Rust بسته‌های زیادی را در crates.io در دسترس قرار داده‌اند، و وارد کردن هر یک از آن‌ها به بسته‌تان شامل همین مراحل است: فهرست کردن آن‌ها در فایل `Cargo.toml` بسته‌تان و استفاده از `use` برای آوردن موارد از جعبه‌هایشان به حوزه.

توجه کنید که کتابخانه استاندارد `std` نیز یک جعبه است که نسبت به بسته ما خارجی است. چون کتابخانه استاندارد همراه با زبان Rust ارائه می‌شود، نیازی به تغییر `Cargo.toml` برای شامل کردن `std` نداریم. اما باید با `use` به آن ارجاع دهیم تا مواردی از آنجا را به حوزه بسته‌مان بیاوریم. برای مثال، با `HashMap` از این خط استفاده می‌کنیم:

```rust
use std::collections::HashMap;
```

این یک مسیر مطلق است که با `std`، نام جعبه کتابخانه استاندارد، شروع می‌شود.

### استفاده از مسیرهای تودرتو برای تمیز کردن لیست‌های بزرگ `use`

اگر از چندین مورد تعریف‌شده در یک جعبه یا ماژول یکسان استفاده می‌کنیم، فهرست کردن هر مورد در خط خودش می‌تواند فضای عمودی زیادی در فایل‌هایمان اشغال کند. برای مثال، این دو عبارت `use` که در بازی حدس زدن در لیست ۲-۴ داشتیم، مواردی از `std` را به حوزه می‌آوردند:

**نام فایل:** `src/main.rs`

```rust
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
```

در عوض، می‌توانیم از مسیرهای تودرتو استفاده کنیم تا همان موارد را در یک خط به حوزه بیاوریم. این کار را با مشخص کردن بخش مشترک مسیر، به دنبال دو نقطه، و سپس کروشه‌هایی دور بخش‌هایی از مسیرها که متفاوت هستند انجام می‌دهیم، همان‌طور که در لیست ۷-۱۸ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
// --snip--
use std::{cmp::Ordering, io};
// --snip--
```

**لیست ۷-۱۸:** مشخص کردن یک مسیر تودرتو برای آوردن چندین مورد با پیشوند یکسان به حوزه

در برنامه‌های بزرگ‌تر، آوردن موارد زیاد به حوزه از یک جعبه یا ماژول با استفاده از مسیرهای تودرتو می‌تواند تعداد عبارات `use` جداگانه موردنیاز را به شدت کاهش دهد!

می‌توانیم از یک مسیر تودرتو در هر سطحی از یک مسیر استفاده کنیم، که وقتی دو عبارت `use` که زیرمسیر مشترکی دارند را ترکیب می‌کنیم مفید است. برای مثال، لیست ۷-۱۹ دو عبارت `use` را نشان می‌دهد: یکی که `std::io` را به حوزه می‌آورد و دیگری که `std::io::Write` را به حوزه می‌آورد.

**نام فایل:** `src/lib.rs`

```rust
use std::io;
use std::io::Write;
```

**لیست ۷-۱۹:** دو عبارت `use` که یکی زیرمسیر دیگری است

بخش مشترک این دو مسیر `std::io` است، و این مسیر کامل اول است. برای ادغام این دو مسیر در یک عبارت `use`، می‌توانیم از `self` در مسیر تودرتو استفاده کنیم، همان‌طور که در لیست ۷-۲۰ نشان داده شده است.

**نام فایل:** `src/lib.rs`

```rust
use std::io::{self, Write};
```

**لیست ۷-۲۰:** ترکیب مسیرهای لیست ۷-۱۹ در یک عبارت `use`

این خط `std::io` و `std::io::Write` را به حوزه می‌آورد.

### عملگر گلوب

اگر بخواهیم همه موارد عمومی تعریف‌شده در یک مسیر را به حوزه بیاوریم، می‌توانیم آن مسیر را به دنبال عملگر گلوب `*` مشخص کنیم:

```rust
use std::collections::*;
```

این عبارت `use` همه موارد عمومی تعریف‌شده در `std::collections` را به حوزه فعلی می‌آورد. هنگام استفاده از عملگر گلوب باید مراقب باشید! گلوب می‌تواند تشخیص اینکه چه نام‌هایی در حوزه هستند و نامی که در برنامه‌تان استفاده شده کجا تعریف شده است را دشوارتر کند.

عملگر گلوب اغلب هنگام تست برای آوردن همه چیز تحت آزمایش به ماژول تست‌ها استفاده می‌شود؛ در بخش «چگونه تست بنویسیم» در فصل یازدهم درباره آن صحبت خواهیم کرد. عملگر گلوب همچنین گاهی به‌عنوان بخشی از الگوی پرلود (prelude pattern) استفاده می‌شود: برای اطلاعات بیشتر درباره این الگو به مستندات کتابخانه استاندارد مراجعه کنید.

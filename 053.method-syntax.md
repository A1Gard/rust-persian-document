## نحو متد

متدها شبیه به توابع هستند: آن‌ها را با کلمه‌کلیدی `fn` و یک نام اعلان می‌کنیم، می‌توانند پارامترها و مقدار بازگشتی داشته باشند، و شامل کدی هستند که وقتی متد از جایی دیگر فراخوانی می‌شود، اجرا می‌شود. برخلاف توابع، متدها در زمینه یک ساختار (یا یک شمارش یا شیء ویژگی‌، که به ترتیب در فصل ششم و فصل هجدهم بحث می‌شوند) تعریف می‌شوند، و اولین پارامتر آن‌ها همیشه `self` است، که نماینده نمونه‌ای از ساختار است که متد روی آن فراخوانی می‌شود.

### تعریف متدها

بیایید تابع `area` را که یک نمونه `Rectangle` به‌عنوان پارامتر داشت تغییر دهیم و به‌جای آن یک متد `area` تعریف‌شده روی ساختار `Rectangle` بسازیم، همان‌طور که در لیست ۵-۱۳ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "مساحت مستطیل {} پیکسل مربع است.",
        rect1.area()
    );
}
```

**لیست ۵-۱۳:** تعریف یک متد `area` روی ساختار `Rectangle`

برای تعریف تابع در زمینه `Rectangle`، یک بلوک `impl` (پیاده‌سازی) برای `Rectangle` شروع می‌کنیم. هر چیزی درون این بلوک `impl` با نوع `Rectangle` مرتبط خواهد بود. سپس تابع `area` را به داخل کروشه‌های `impl` منتقل می‌کنیم و اولین (و در این مورد، تنها) پارامتر را در امضا و هر جای بدنه به `self` تغییر می‌دهیم. در `main`، جایی که تابع `area` را فراخوانی کردیم و `rect1` را به‌عنوان آرگومان پاس دادیم، حالا می‌توانیم از نحو متد برای فراخوانی متد `area` روی نمونه `Rectangle` خود استفاده کنیم. نحو متد بعد از یک نمونه می‌آید: ما یک نقطه اضافه می‌کنیم و به دنبال آن نام متد، پرانتزها، و هر آرگومانی می‌آید.

در امضای `area`، ما از `&self` به‌جای `rectangle: &Rectangle` استفاده می‌کنیم. `&self` در واقع مخفف `self: &Self` است. در یک بلوک `impl`، نوع `Self` یک نام مستعار برای نوعی است که بلوک `impl` برای آن است. متدها باید یک پارامتر به نام `self` از نوع `Self` به‌عنوان اولین پارامتر خود داشته باشند، بنابراین Rust به شما اجازه می‌دهد این را فقط با نام `self` در جایگاه اولین پارامتر کوتاه کنید. توجه کنید که هنوز باید از `&` جلوی میانبر `self` استفاده کنیم تا نشان دهیم این متد نمونه `Self` را قرض می‌گیرد، همان‌طور که در `rectangle: &Rectangle` کردیم. متدها می‌توانند مالکیت `self` را بگیرند، `self` را به‌صورت غیرقابل‌تغییر قرض بگیرند، همان‌طور که اینجا انجام دادیم، یا `self` را به‌صورت قابل‌تغییر قرض بگیرند، درست مانند هر پارامتر دیگری.

ما اینجا `&self` را انتخاب کردیم به همان دلیلی که در نسخه تابع از `&Rectangle` استفاده کردیم: نمی‌خواهیم مالکیت را بگیریم، و فقط می‌خواهیم داده‌های ساختار را بخوانیم، نه در آن بنویسیم. اگر بخواهیم نمونه‌ای که متد روی آن فراخوانی شده را به‌عنوان بخشی از کاری که متد انجام می‌دهد تغییر دهیم، از `&mut self` به‌عنوان اولین پارامتر استفاده می‌کنیم. داشتن متدی که مالکیت نمونه را با استفاده از فقط `self` به‌عنوان اولین پارامتر بگیرد نادر است؛ این تکنیک معمولاً زمانی استفاده می‌شود که متد `self` را به چیز دیگری تبدیل می‌کند و می‌خواهید از استفاده فراخواننده از نمونه اصلی پس از تبدیل جلوگیری کنید.

دلیل اصلی استفاده از متدها به‌جای توابع، علاوه بر ارائه نحو متد و عدم نیاز به تکرار نوع `self` در امضای هر متد، سازمان‌دهی است. ما تمام کارهایی که می‌توانیم با یک نمونه از یک نوع انجام دهیم را در یک بلوک `impl` قرار داده‌ایم به‌جای اینکه کاربران آینده کد ما مجبور شوند قابلیت‌های `Rectangle` را در جاهای مختلف کتابخانه‌ای که ارائه می‌دهیم جستجو کنند.

توجه کنید که می‌توانیم نامی برای متد انتخاب کنیم که با یکی از فیلدهای ساختار یکسان باشد. برای مثال، می‌توانیم یک متد روی `Rectangle` تعریف کنیم که آن هم `width` نامیده شود:

**نام فایل:** `src/main.rs`

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("مستطیل عرض غیرصفر دارد؛ برابر است با {}", rect1.width);
    }
}
```

در اینجا، ما انتخاب کردیم که متد `width` مقدار `true` را برگرداند اگر مقدار در فیلد `width` نمونه بزرگ‌تر از ۰ باشد و `false` اگر مقدار ۰ باشد: می‌توانیم از یک فیلد در متدی با همان نام برای هر هدفی استفاده کنیم. در `main`، وقتی بعد از `rect1.width` پرانتز می‌گذاریم، Rust می‌فهمد که منظور ما متد `width` است. وقتی پرانتز استفاده نمی‌کنیم، Rust می‌فهمد که منظور ما فیلد `width` است.

اغلب، اما نه همیشه، وقتی به متدی نامی مشابه یک فیلد می‌دهیم، می‌خواهیم فقط مقدار فیلد را برگرداند و کار دیگری انجام ندهد. به متدهایی مثل این **گترها (getters)** می‌گویند، و Rust برخلاف برخی زبان‌های دیگر، آن‌ها را به‌صورت خودکار برای فیلدهای ساختار پیاده‌سازی نمی‌کند. گترها مفید هستند زیرا می‌توانید فیلد را خصوصی کنید اما متد را عمومی کنید، و بنابراین دسترسی فقط خواندنی به آن فیلد را به‌عنوان بخشی از API عمومی نوع فعال کنید. در فصل هفتم درباره عمومی و خصوصی بودن و نحوه تعیین یک فیلد یا متد به‌عنوان عمومی یا خصوصی بحث خواهیم کرد.

### عملگر `->` کجاست؟

در C و C++، دو عملگر مختلف برای فراخوانی متدها استفاده می‌شود: از `.` استفاده می‌کنید اگر متد را مستقیماً روی شیء فراخوانی کنید و از `->` اگر متد را روی یک اشاره‌گر به شیء فراخوانی کنید و ابتدا نیاز به ارجاع‌زدایی اشاره‌گر داشته باشید. به عبارت دیگر، اگر `object` یک اشاره‌گر باشد، `object->something()` شبیه به `(*object).something()` است.

Rust معادلی برای عملگر `->` ندارد؛ در عوض، Rust یک ویژگی به نام **ارجاع‌دهی و ارجاع‌زدایی خودکار (automatic referencing and dereferencing)** دارد. فراخوانی متدها یکی از معدود جاهایی در Rust است که این رفتار را دارد.

نحوه کار آن این‌گونه است: وقتی یک متد را با `object.something()` فراخوانی می‌کنید، Rust به‌صورت خودکار `&`، `&mut`، یا `*` را اضافه می‌کند تا `object` با امضای متد مطابقت داشته باشد. به عبارت دیگر، موارد زیر یکسان هستند:

```rust
p1.distance(&p2);
(&p1).distance(&p2);
```

اولی بسیار تمیزتر به نظر می‌رسد. این رفتار ارجاع‌دهی خودکار کار می‌کند زیرا متدها یک گیرنده واضح دارند—نوع `self`. با توجه به گیرنده و نام یک متد، Rust می‌تواند به‌طور قطعی تشخیص دهد که آیا متد در حال خواندن (`&self`)، تغییر دادن (`&mut self`)، یا مصرف کردن (`self`) است. این که Rust قرض‌گیری را برای گیرنده‌های متد به‌صورت ضمنی انجام می‌دهد، بخش بزرگی از ارگونومیک کردن مالکیت در عمل است.

### متدهایی با پارامترهای بیشتر

بیایید با پیاده‌سازی یک متد دوم روی ساختار `Rectangle` تمرین کنیم. این بار می‌خواهیم یک نمونه از `Rectangle` یک نمونه دیگر از `Rectangle` را بگیرد و اگر مستطیل دوم کاملاً در `self` (مستطیل اول) جا شود، `true` برگرداند؛ در غیر این صورت، باید `false` برگرداند. یعنی، وقتی متد `can_hold` را تعریف کردیم، می‌خواهیم بتوانیم برنامه‌ای مانند آنچه در لیست ۵-۱۴ نشان داده شده است بنویسیم.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("آیا rect1 می‌تواند rect2 را در خود جای دهد؟ {}", rect1.can_hold(&rect2));
    println!("آیا rect1 می‌تواند rect3 را در خود جای دهد؟ {}", rect1.can_hold(&rect3));
}
```

**لیست ۵-۱۴:** استفاده از متد هنوز نانوشته `can_hold`

خروجی مورد انتظار به این شکل خواهد بود زیرا هر دو بعد `rect2` کوچک‌تر از ابعاد `rect1` هستند، اما `rect3` عریض‌تر از `rect1` است:

```
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

ما می‌دانیم که می‌خواهیم یک متد تعریف کنیم، بنابراین در بلوک `impl Rectangle` خواهد بود. نام متد `can_hold` خواهد بود، و یک قرض‌گیری غیرقابل‌تغییر از یک `Rectangle` دیگر را به‌عنوان پارامتر می‌گیرد. می‌توانیم نوع پارامتر را با نگاه کردن به کدی که متد را فراخوانی می‌کند تشخیص دهیم: `rect1.can_hold(&rect2)` مقدار `&rect2` را پاس می‌دهد، که یک قرض‌گیری غیرقابل‌تغییر به `rect2`، یک نمونه از `Rectangle`، است. این منطقی است زیرا ما فقط نیاز به خواندن `rect2` داریم (نه نوشتن، که به این معناست که نیاز به یک قرض‌گیری قابل‌تغpośred می‌داشتیم)، و می‌خواهیم `main` مالکیت `rect2` را حفظ کند تا بتوانیم پس از فراخوانی متد `can_hold` دوباره از آن استفاده کنیم. مقدار بازگشتی `can_hold` یک بولین خواهد بود، و پیاده‌سازی بررسی خواهد کرد که آیا عرض و ارتفاع `self` به ترتیب بزرگ‌تر از عرض و ارتفاع `Rectangle` دیگر هستند یا خیر. بیایید متد جدید `can_hold` را به بلوک `impl` از لیست ۵-۱۳ اضافه کنیم، همان‌طور که در لیست ۵-۱۵ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

**لیست ۵-۱۵:** پیاده‌سازی متد `can_hold` روی `Rectangle` که یک نمونه `Rectangle` دیگر را به‌عنوان پارامتر می‌گیرد

وقتی این کد را با تابع `main` در لیست ۵-۱۴ اجرا کنیم، خروجی مورد نظرمان را دریافت خواهیم کرد. متدها می‌توانند چندین پارامتر بگیرند که ما آن‌ها را بعد از پارامتر `self` به امضا اضافه می‌کنیم، و این پارامترها درست مانند پارامترهای توابع کار می‌کنند.

### توابع مرتبط

همه توابعی که در یک بلوک `impl` تعریف می‌شوند، **توابع مرتبط (associated functions)** نامیده می‌شوند زیرا با نوع نام‌گذاری‌شده بعد از `impl` مرتبط هستند. ما می‌توانیم توابع مرتبطی تعریف کنیم که `self` را به‌عنوان اولین پارامتر خود نداشته باشند (و بنابراین متد نیستند) زیرا نیازی به نمونه‌ای از نوع برای کار با آن‌ها ندارند. ما قبلاً از چنین تابعی استفاده کرده‌ایم: تابع `String::from` که روی نوع `String` تعریف شده است.

توابع مرتبطی که متد نیستند اغلب برای سازنده‌هایی (constructors) استفاده می‌شوند که یک نمونه جدید از ساختار را برمی‌گردانند. این‌ها اغلب `new` نامیده می‌شوند، اما `new` یک نام ویژه نیست و در زبان内置 نیست. برای مثال، می‌توانیم یک تابع مرتبط به نام `square` ارائه دهیم که یک پارامتر بعد داشته باشد و از آن به‌عنوان عرض و ارتفاع استفاده کند، بنابراین ساخت یک `Rectangle` مربعی آسان‌تر می‌شود به‌جای اینکه مجبور باشیم همان مقدار را دو بار مشخص کنیم:

**نام فایل:** `src/main.rs`

```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```

کلیدواژه‌ها `Self` در نوع بازگشتی و در بدنه تابع نام‌های مستعاری برای نوعی هستند که بعد از کلمه‌کلیدی `impl` می‌آید، که در این مورد `Rectangle` است.

برای فراخوانی این تابع مرتبط، از نحو `::` با نام ساختار استفاده می‌کنیم؛ به‌عنوان مثال: `let sq = Rectangle::square(3);`. این تابع توسط ساختار فضای نام‌گذاری شده است: نحو `::` هم برای توابع مرتبط و هم برای فضای نام‌های ایجادشده توسط ماژول‌ها استفاده می‌شود. ما در فصل هفتم درباره ماژول‌ها بحث خواهیم کرد.

### چندین بلوک `impl`

هر ساختار می‌تواند چندین بلوک `impl` داشته باشد. برای مثال، لیست ۵-۱۵ معادل کدی است که در لیست ۵-۱۶ نشان داده شده است، که هر متد در بلوک `impl` خودش قرار دارد.

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

**لیست ۵-۱۶:** بازنویسی لیست ۵-۱۵ با استفاده از چندین بلوک `impl`

در اینجا دلیلی برای جداسازی این متدها به چندین بلوک `impl` وجود ندارد، اما این نحو معتبر است. ما در فصل دهم، جایی که درباره نوع‌های عمومی (generic types) و صفات بحث می‌کنیم، موردی را خواهیم دید که چندین بلوک `impl` مفید هستند.

### خلاصه

ساختارها به شما امکان می‌دهند نوع‌های سفارشی‌ای ایجاد کنید که برای حوزه شما معنادار باشند. با استفاده از ساختارها، می‌توانید قطعات داده مرتبط را به هم متصل نگه دارید و هر قطعه را نام‌گذاری کنید تا کدتان واضح شود. در بلوک‌های `impl`، می‌توانید توابعی تعریف کنید که با نوع شما مرتبط هستند، و متدها نوعی از توابع مرتبط هستند که به شما امکان می‌دهند رفتاری که نمونه‌های ساختارهایتان دارند را مشخص کنید.

اما ساختارها تنها راه برای ایجاد نوع‌های سفارشی نیستند: بیایید به ویژگی شمارش (enum) Rust برویم تا ابزار دیگری به جعبه‌ابزارتان اضافه کنیم.

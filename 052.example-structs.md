## یک برنامه نمونه با استفاده از ساختارها

برای درک اینکه چه زمانی ممکن است بخواهیم از ساختارها استفاده کنیم، بیایید برنامه‌ای بنویسیم که مساحت یک مستطیل را محاسبه می‌کند. ابتدا با استفاده از متغیرهای تکی شروع می‌کنیم و سپس برنامه را بازسازی (refactor) می‌کنیم تا به‌جای آن از ساختارها استفاده کند.

بیایید یک پروژه باینری جدید با Cargo به نام `rectangles` بسازیم که عرض و ارتفاع یک مستطیل را به پیکسل می‌گیرد و مساحت مستطیل را محاسبه می‌کند. لیست ۵-۸ برنامه‌ای کوتاه را نشان می‌دهد که یک روش برای انجام دقیق این کار در فایل `src/main.rs` پروژه ما دارد.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "مساحت مستطیل {} پیکسل مربع است.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

**لیست ۵-۸:** محاسبه مساحت یک مستطیل مشخص‌شده با متغیرهای جداگانه عرض و ارتفاع

حالا، این برنامه را با استفاده از `cargo run` اجرا کنید:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
```

این کد با فراخوانی تابع `area` با هر بعد، موفق به محاسبه مساحت مستطیل می‌شود، اما می‌توانیم کارهای بیشتری انجام دهیم تا این کد واضح‌تر و خواناتر شود.

مشکل این کد در امضای تابع `area` مشهود است:

```rust
fn area(width: u32, height: u32) -> u32 {
```

تابع `area` قرار است مساحت یک مستطیل را محاسبه کند، اما تابعی که نوشتیم دو پارامتر دارد، و در هیچ جای برنامه ما مشخص نیست که این پارامترها به هم مرتبط هستند. گروه‌بندی عرض و ارتفاع با هم خواناتر و قابل‌مدیریت‌تر خواهد بود. ما قبلاً در بخش «نوع تاپل» در فصل سوم یک راه برای انجام این کار بحث کردیم: با استفاده از تاپل‌ها.

### بازسازی با تاپل‌ها

لیست ۵-۹ نسخه دیگری از برنامه ما را نشان می‌دهد که از تاپل‌ها استفاده می‌کند.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "مساحت مستطیل {} پیکسل مربع است.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

**لیست ۵-۹:** مشخص کردن عرض و ارتفاع مستطیل با یک تاپل

از یک جهت، این برنامه بهتر است. تاپل‌ها به ما امکان می‌دهند کمی ساختار اضافه کنیم، و حالا فقط یک آرگومان پاس می‌دهیم. اما از جهت دیگر، این نسخه کمتر واضح است: تاپل‌ها عناصر خود را نام‌گذاری نمی‌کنند، بنابراین باید به بخش‌های تاپل با ایندکس دسترسی پیدا کنیم، که محاسبه ما را کمتر آشکار می‌کند.

اشتباه گرفتن عرض و ارتفاع برای محاسبه مساحت اهمیتی ندارد، اما اگر بخواهیم مستطیل را روی صفحه نمایش بکشیم، مهم خواهد بود! باید به خاطر داشته باشیم که عرض ایندکس ۰ تاپل و ارتفاع ایندکس ۱ تاپل است. این برای شخص دیگری که بخواهد کد ما را بفهمد و به خاطر بسپارد، حتی سخت‌تر خواهد بود. چون معنای داده‌هایمان را در کد منتقل نکرده‌ایم، حالا معرفی خطاها آسان‌تر است.

### بازسازی با ساختارها: افزودن معنای بیشتر

ما از ساختارها برای افزودن معنا با برچسب‌گذاری داده‌ها استفاده می‌کنیم. می‌توانیم تاپلی که استفاده می‌کنیم را به یک ساختار تبدیل کنیم که نامی برای کل و همچنین نام‌هایی برای بخش‌ها دارد، همان‌طور که در لیست ۵-۱۰ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "مساحت مستطیل {} پیکسل مربع است.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

**لیست ۵-۱۰:** تعریف یک ساختار `Rectangle`

در اینجا، ما یک ساختار تعریف کردیم و آن را `Rectangle` نام‌گذاری کردیم. داخل کروشه‌ها، فیلدها را به‌عنوان `width` و `height` تعریف کردیم، که هر دو از نوع `u32` هستند. سپس، در `main`، یک نمونه خاص از `Rectangle` ایجاد کردیم که عرض ۳۰ و ارتفاع ۵۰ دارد.

تابع `area` ما حالا با یک پارامتر تعریف شده است، که آن را `rectangle` نام‌گذاری کردیم، و نوع آن یک قرض‌گیری غیرقابل‌تغییر (immutable borrow) از یک نمونه ساختار `Rectangle` است. همان‌طور که در فصل چهارم ذکر شد، ما می‌خواهیم ساختار را قرض بگیریم به‌جای اینکه مالکیت آن را بگیریم. این‌گونه، `main` مالکیت خود را حفظ می‌کند و می‌تواند به استفاده از `rect1` ادامه دهد، به همین دلیل در امضای تابع و جایی که تابع را فراخوانی می‌کنیم از `&` استفاده می‌کنیم.

تابع `area` به فیلدهای `width` و `height` نمونه `Rectangle` دسترسی پیدا می‌کند (توجه کنید که دسترسی به فیلدهای یک نمونه ساختار قرض‌گرفته‌شده مقادیر فیلدها را منتقل نمی‌کند، به همین دلیل اغلب قرض‌گیری ساختارها را می‌بینید). امضای تابع ما برای `area` حالا دقیقاً آنچه را که منظورمان است می‌گوید: محاسبه مساحت `Rectangle`، با استفاده از فیلدهای `width` و `height` آن. این نشان می‌دهد که عرض و ارتفاع به هم مرتبط هستند، و به مقادیر نام‌های توصیفی می‌دهد به‌جای استفاده از مقادیر ایندکس تاپل ۰ و ۱. این یک پیروزی برای وضوح است.

### افزودن قابلیت‌های مفید با صفات مشتق‌شده

مفید خواهد بود که بتوانیم یک نمونه از `Rectangle` را هنگام دیباگ کردن برنامه‌مان چاپ کنیم و مقادیر تمام فیلدهای آن را ببینیم. لیست ۵-۱۱ سعی می‌کند از ماکروی `println!` همان‌طور که در فصل‌های قبلی استفاده کردیم، استفاده کند. اما این کار نخواهد کرد.

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 برابر است با {}", rect1);
}
```

**لیست ۵-۱۱:** تلاش برای چاپ یک نمونه `Rectangle`

وقتی این کد را کامپایل کنیم، خطایی با این پیام اصلی دریافت می‌کنیم:

```
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

ماکروی `println!` می‌تواند انواع مختلفی از قالب‌بندی را انجام دهد، و به‌صورت پیش‌فرض، کروشه‌ها به `println!` می‌گویند که از قالب‌بندی‌ای به نام `Display` استفاده کند: خروجی‌ای که برای مصرف مستقیم کاربر نهایی در نظر گرفته شده است. نوع‌های ابتدایی که تاکنون دیده‌ایم به‌صورت پیش‌فرض `Display` را پیاده‌سازی می‌کنند زیرا تنها یک راه وجود دارد که بخواهید یک `1` یا هر نوع ابتدایی دیگر را به کاربر نشان دهید. اما با ساختارها، نحوه قالب‌بندی خروجی توسط `println!` کمتر واضح است زیرا امکانات نمایش بیشتری وجود دارد: آیا کاما می‌خواهید یا نه؟ آیا می‌خواهید کروشه‌ها چاپ شوند؟ آیا همه فیلدها باید نشان داده شوند؟ به دلیل این ابهام، Rust سعی نمی‌کند آنچه ما می‌خواهیم را حدس بزند، و ساختارها پیاده‌سازی ارائه‌شده‌ای از `Display` برای استفاده با `println!` و جایگاه‌نگهدار `{}` ندارند.

اگر به خواندن خطاها ادامه دهیم، یادداشت مفیدی پیدا خواهیم کرد:

```
   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
```

بیایید امتحان کنیم! فراخوانی ماکروی `println!` حالا به‌صورت `println!("rect1 is {rect1:?}");` خواهد بود. قرار دادن مشخص‌کننده `:?` داخل کروشه‌ها به `println!` می‌گوید که می‌خواهیم از قالب خروجی‌ای به نام `Debug` استفاده کنیم. ویژگی‌ `Debug` به ما امکان می‌دهد ساختارمان را به روشی چاپ کنیم که برای توسعه‌دهندگان مفید است تا بتوانیم مقدار آن را هنگام دیباگ کردن کدمان ببینیم.

کد را با این تغییر کامپایل کنید. اوه! هنوز خطا دریافت می‌کنیم:

```
error[E0277]: `Rectangle` doesn't implement `Debug`
```

اما باز هم، کامپایلر یادداشت مفیدی به ما می‌دهد:

```
   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
```

Rust قابلیت چاپ اطلاعات دیباگ را شامل می‌شود، اما ما باید به‌صراحت انتخاب کنیم تا این قابلیت برای ساختارمان در دسترس باشد. برای این کار، ویژگی خارجی `#[derive(Debug)]` را درست قبل از تعریف ساختار اضافه می‌کنیم، همان‌طور که در لیست ۵-۱۲ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 برابر است با {rect1:?}");
}
```

**لیست ۵-۱۲:** افزودن ویژگی برای مشتق کردن ویژگی‌ `Debug` و چاپ نمونه `Rectangle` با استفاده از قالب‌بندی دیباگ

حالا وقتی برنامه را اجرا کنیم، هیچ خطایی دریافت نمی‌کنیم و خروجی زیر را خواهیم دید:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
```

عالی است! این زیباترین خروجی نیست، اما مقادیر تمام فیلدها برای این نمونه را نشان می‌دهد، که قطعاً هنگام دیباگ کردن کمک می‌کند. وقتی ساختارهای بزرگ‌تری داریم، داشتن خروجی‌ای که خواندن آن کمی آسان‌تر باشد مفید است؛ در این موارد، می‌توانیم به‌جای `{:?}` از `{:#?}` در رشته `println!` استفاده کنیم. در این مثال، استفاده از سبک `{:#?}` خروجی زیر را تولید خواهد کرد:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
```

راه دیگری برای چاپ یک مقدار با استفاده از قالب `Debug` استفاده از ماکروی `dbg!` است، که مالکیت یک عبارت را می‌گیرد (برخلاف `println!` که ارجاع می‌گیرد)، فایل و شماره خط جایی که فراخوانی ماکروی `dbg!` در کد شما رخ می‌دهد را همراه با مقدار حاصل از آن عبارت چاپ می‌کند، و مالکیت مقدار را برمی‌گرداند.

> **توجه:** فراخوانی ماکروی `dbg!` به جریان کنسول خطای استاندارد (stderr) چاپ می‌کند، برخلاف `println!` که به جریان کنسول خروجی استاندارد (stdout) چاپ می‌کند. درباره `stderr` و `stdout` در بخش «نوشتن پیام‌های خطا به خطای استاندارد به‌جای خروجی استاندارد» در فصل دوازدهم بیشتر صحبت خواهیم کرد.

در اینجا مثالی داریم که در آن به مقداری که به فیلد `width` اختصاص داده می‌شود و همچنین مقدار کل ساختار در `rect1` علاقه‌مندیم:

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

ما می‌توانیم `dbg!` را دور عبارت `30 * scale` قرار دهیم و، چون `dbg!` مالکیت مقدار عبارت را برمی‌گرداند، فیلد `width` همان مقداری را می‌گیرد که اگر فراخوانی `dbg!` آنجا نبود. نمی‌خواهیم `dbg!` مالکیت `rect1` را بگیرد، بنابراین در فراخوانی بعدی از ارجاع به `rect1` استفاده می‌کنیم. خروجی این مثال به این شکل خواهد بود:

```bash
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

می‌توانیم ببینیم که بخش اول خروجی از خط ۱۰ فایل `src/main.rs` آمده است، جایی که ما در حال دیباگ کردن عبارت `30 * scale` هستیم، و مقدار حاصل آن ۶۰ است (قالب‌بندی `Debug` پیاده‌سازی‌شده برای اعداد صحیح فقط مقدار آن‌ها را چاپ می‌کند). فراخوانی `dbg!` در خط ۱۴ فایل `src/main.rs` مقدار `&rect1` را چاپ می‌کند، که ساختار `Rectangle` است. این خروجی از قالب‌بندی زیبای `Debug` نوع `Rectangle` استفاده می‌کند. ماکروی `dbg!` می‌تواند واقعاً مفید باشد وقتی سعی می‌کنید بفهمید کدتان چه کاری انجام می‌دهد!

علاوه بر ویژگی‌ `Debug`، Rust تعدادی ویژگی‌ دیگر را برای استفاده با ویژگی `derive` ارائه کرده است که می‌توانند رفتار مفیدی به نوع‌های سفارشی ما اضافه کنند. این صفات و رفتارهایشان در ضمیمه C فهرست شده‌اند. ما در فصل دهم نحوه پیاده‌سازی این صفات با رفتار سفارشی و همچنین نحوه ایجاد صفات خودتان را پوشش خواهیم داد. ویژگی‌های دیگری غیر از `derive` نیز وجود دارند؛ برای اطلاعات بیشتر، به بخش «ویژگی‌ها» در مرجع Rust مراجعه کنید.

تابع `area` ما بسیار خاص است: فقط مساحت مستطیل‌ها را محاسبه می‌کند. مفید خواهد بود که این رفتار را نزدیک‌تر به ساختار `Rectangle` خودمان گره بزنیم زیرا با هیچ نوع دیگری کار نخواهد کرد. بیایید ببینیم چگونه می‌توانیم این کد را با تبدیل تابع `area` به یک متد `area` تعریف‌شده روی نوع `Rectangle` ادامه دهیم بازسازی کنیم.

# Rust ناامن

تمام کدهایی که تاکنون بحث کردیم، تضمین‌های ایمنی حافظه Rust را در زمان کامپایل اعمال کرده‌اند. با این حال، Rust یک زبان دوم مخفی در داخل خود دارد که این تضمین‌های ایمنی حافظه را اعمال نمی‌کند: این زبان به نام **Rust ناامن** شناخته می‌شود و درست مانند Rust معمولی کار می‌کند، اما قدرت‌های فوق‌العاده بیشتری به ما می‌دهد.

Rust ناامن به این دلیل وجود دارد که تحلیل استاتیک به طور ذاتی محافظه‌کارانه است. وقتی کامپایلر سعی می‌کند تعیین کند که آیا کد به تضمین‌ها پایبند است یا خیر، بهتر است برخی برنامه‌های معتبر را رد کند تا اینکه برخی برنامه‌های نامعتبر را بپذیرد. اگرچه کد ممکن است درست باشد، اگر کامپایلر Rust اطلاعات کافی برای اطمینان نداشته باشد، کد را رد خواهد کرد. در این موارد، می‌توانید از کد ناامن استفاده کنید تا به کامپایلر بگویید: «به من اعتماد کن، می‌دانم چه کار می‌کنم.» اما هشدار داده می‌شود که استفاده از Rust ناامن با مسئولیت خودتان است: اگر از کد ناامن به اشتباه استفاده کنید، مشکلاتی به دلیل عدم ایمنی حافظه، مانند ارجاع به اشاره‌گر نال، ممکن است رخ دهد.

دلیل دیگر وجود Rust ناامن این است که سخت‌افزار کامپیوتر ذاتاً ناامن است. اگر Rust به شما اجازه انجام عملیات ناامن را ندهد، نمی‌توانید برخی وظایف را انجام دهید. Rust باید به شما اجازه دهد برنامه‌نویسی سطح پایین سیستمی انجام دهید، مانند تعامل مستقیم با سیستم‌عامل یا حتی نوشتن سیستم‌عامل خودتان. کار با برنامه‌نویسی سطح پایین سیستمی یکی از اهداف این زبان است. بیایید کاوش کنیم که با Rust ناامن چه کارهایی می‌توانیم انجام دهیم و چگونه این کار را انجام دهیم.

## قدرت‌های فوق‌العاده ناامن

برای تغییر به Rust ناامن، از کلمه کلیدی `unsafe` استفاده کنید و سپس یک بلوک جدید شروع کنید که کد ناامن را در خود جای می‌دهد. در Rust ناامن می‌توانید پنج عملیات انجام دهید که در Rust امن نمی‌توانید، و ما به این‌ها **قدرت‌های فوق‌العاده ناامن** می‌گوییم. این قدرت‌ها شامل توانایی‌های زیر هستند:

1. ارجاع‌زدایی از یک اشاره‌گر خام
2. فراخوانی یک تابع یا متد ناامن
3. دسترسی یا تغییر یک متغیر استاتیک تغییرپذیر
4. پیاده‌سازی یک ویژگی ناامن
5. دسترسی به فیلدهای یک اتحاد (union)

مهم است که درک کنید `unsafe` بررسی‌کننده قرض‌گیری یا سایر بررسی‌های ایمنی Rust را خاموش نمی‌کند: اگر از یک ارجاع در کد ناامن استفاده کنید، همچنان بررسی خواهد شد. کلمه کلیدی `unsafe` فقط به شما دسترسی به این پنج ویژگی را می‌دهد که سپس توسط کامپایلر برای ایمنی حافظه بررسی نمی‌شوند. شما همچنان در داخل یک بلوک ناامن درجه‌ای از ایمنی خواهید داشت.

علاوه بر این، `unsafe` به این معنا نیست که کد داخل بلوک لزوماً خطرناک است یا قطعاً مشکلات ایمنی حافظه خواهد داشت: نیت این است که شما به‌عنوان برنامه‌نویس اطمینان دهید که کد داخل یک بلوک ناامن به روشی معتبر به حافظه دسترسی خواهد داشت.

انسان‌ها خطاپذیر هستند و اشتباهات رخ خواهند داد، اما با الزام اینکه این پنج عملیات ناامن باید در بلوک‌های مشخص‌شده با `unsafe` باشند، خواهید دانست که هر خطای مربوط به ایمنی حافظه باید در داخل یک بلوک ناامن باشد. بلوک‌های ناامن را کوچک نگه دارید؛ بعداً وقتی اشکالات حافظه را بررسی می‌کنید، از این کار سپاسگزار خواهید بود.

برای جداسازی کد ناامن تا حد ممکن، بهتر است چنین کدی را در یک انتزاع امن محصور کنید و یک API امن ارائه دهید، که بعداً در این فصل هنگام بررسی توابع و متدهای ناامن بحث خواهیم کرد. بخش‌هایی از کتابخانه استاندارد به‌عنوان انتزاع‌های امن بر روی کد ناامن که بررسی شده‌اند پیاده‌سازی شده‌اند. بسته‌بندی کد ناامن در یک انتزاع امن از نشت استفاده‌های ناامن به همه مکان‌هایی که شما یا کاربرانتان ممکن است بخواهید از عملکرد پیاده‌سازی‌شده با کد ناامن استفاده کنید جلوگیری می‌کند، زیرا استفاده از یک انتزاع امن، امن است.

بیایید هر یک از این پنج قدرت فوق‌العاده ناامن را به نوبت بررسی کنیم. همچنین به برخی انتزاع‌هایی نگاه خواهیم کرد که یک رابط امن به کد ناامن ارائه می‌دهند.

### ارجاع‌زدایی از یک اشاره‌گر خام

در بخش «ارجاع‌های آویزان» در فصل چهارم، ذکر کردیم که کامپایلر اطمینان می‌دهد ارجاع‌ها همیشه معتبر هستند. Rust ناامن دو نوع جدید به نام **اشاره‌گرهای خام** دارد که شبیه ارجاع‌ها هستند. مانند ارجاع‌ها، اشاره‌گرهای خام می‌توانند غیرقابل‌تغییر یا تغییرپذیر باشند و به ترتیب به صورت `*const T` و `*mut T` نوشته می‌شوند. ستاره در اینجا عملگر ارجاع‌زدایی نیست؛ بخشی از نام نوع است. در زمینه اشاره‌گرهای خام، غیرقابل‌تغییر به این معناست که اشاره‌گر پس از ارجاع‌زدایی نمی‌تواند مستقیماً مقداردهی شود.

برخلاف ارجاع‌ها و اشاره‌گرهای هوشمند، اشاره‌گرهای خام:

- مجاز به نادیده گرفتن قوانین قرض‌گیری هستند با داشتن اشاره‌گرهای غیرقابل‌تغییر و تغییرپذیر یا چندین اشاره‌گر تغییرپذیر به همان مکان
- تضمین نمی‌شوند که به حافظه معتبر اشاره کنند
- مجاز به نال بودن هستند
- هیچ پاکسازی خودکاری را پیاده‌سازی نمی‌کنند

با انصراف از تضمین‌های Rust، می‌توانید ایمنی تضمین‌شده را در ازای عملکرد بهتر یا توانایی تعامل با زبان یا سخت‌افزار دیگری که تضمین‌های Rust در آن اعمال نمی‌شود، کنار بگذارید.

Listing 20-1 نشان می‌دهد چگونه یک اشاره‌گر خام غیرقابل‌تغییر و یک اشاره‌گر خام تغییرپذیر ایجاد کنیم.

```rust
let mut num = 5;

let r1 = &raw const num;
let r2 = &raw mut num;
```

**Listing 20-1: ایجاد اشاره‌گرهای خام با عملگرهای قرض‌گیری خام**

توجه کنید که در این کد از کلمه کلیدی `unsafe` استفاده نمی‌کنیم. ما می‌توانیم اشاره‌گرهای خام را در کد امن ایجاد کنیم؛ فقط نمی‌توانیم اشاره‌گرهای خام را خارج از یک بلوک ناامن ارجاع‌زدایی کنیم، همان‌طور که کمی بعد خواهید دید.

ما اشاره‌گرهای خام را با استفاده از عملگرهای قرض‌گیری خام ایجاد کرده‌ایم: `&raw const num` یک اشاره‌گر خام غیرقابل‌تغییر `*const i32` ایجاد می‌کند، و `&raw mut num` یک اشاره‌گر خام تغییرپذیر `*mut i32` ایجاد می‌کند. چون ما آن‌ها را مستقیماً از یک متغیر محلی ایجاد کردیم، می‌دانیم که این اشاره‌گرهای خام خاص معتبر هستند، اما نمی‌توانیم این فرض را درباره هر اشاره‌گر خامی داشته باشیم.

برای نشان دادن این موضوع، در ادامه یک اشاره‌گر خام ایجاد خواهیم کرد که نمی‌توانیم از اعتبار آن مطمئن باشیم، با استفاده از `as` برای تبدیل یک مقدار به‌جای استفاده از عملگرهای قرض‌گیری خام. Listing 20-2 نشان می‌دهد چگونه یک اشاره‌گر خام به یک مکان دلخواه در حافظه ایجاد کنیم. تلاش برای استفاده از حافظه دلخواه تعریف‌نشده است: ممکن است در آن آدرس داده‌ای وجود داشته باشد یا نداشته باشد، کامپایلر ممکن است کد را بهینه‌سازی کند تا هیچ دسترسی به حافظه‌ای وجود نداشته باشد، یا برنامه ممکن است با خطای نقض تقسیم‌بندی خاتمه یابد. معمولاً هیچ دلیل خوبی برای نوشتن چنین کدی وجود ندارد، به‌خصوص در مواردی که می‌توانید به‌جای آن از عملگر قرض‌گیری خام استفاده کنید، اما این امکان وجود دارد.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

**Listing 20-2: ایجاد یک اشاره‌گر خام به یک آدرس حافظه دلخواه**

به یاد بیاورید که می‌توانیم اشاره‌گرهای خام را در کد امن ایجاد کنیم، اما نمی‌توانیم اشاره‌گرهای خام را ارجاع‌زدایی کنیم و داده‌ای که به آن اشاره دارند را بخوانیم. در Listing 20-3، ما از عملگر ارجاع‌زدایی `*` روی یک اشاره‌گر خام استفاده می‌کنیم که نیاز به یک بلوک ناامن دارد.

```rust
let mut num = 5;

let r1 = &raw const num;
let r2 = &raw mut num;

unsafe {
    println!("r1 برابر است با: {}", *r1); // r1 is: {}
    println!("r2 برابر است با: {}", *r2); // r2 is: {}
}
```

**Listing 20-3: ارجاع‌زدایی از اشاره‌گرهای خام در داخل یک بلوک ناامن**

ایجاد یک اشاره‌گر ضرری ندارد؛ فقط وقتی سعی کنیم به مقداری که به آن اشاره می‌کند دسترسی پیدا کنیم، ممکن است با یک مقدار نامعتبر مواجه شویم.

همچنین توجه کنید که در Listing 20-1 و 20-3، ما اشاره‌گرهای خام `*const i32` و `*mut i32` را ایجاد کردیم که هر دو به همان مکان حافظه اشاره داشتند، جایی که `num` ذخیره شده است. اگر به‌جای آن سعی می‌کردیم یک ارجاع غیرقابل‌تغییر و یک ارجاع تغییرپذیر به `num` ایجاد کنیم، کد کامپایل نمی‌شد زیرا قوانین مالکیت Rust اجازه نمی‌دهند یک ارجاع تغییرپذیر همزمان با هر ارجاع غیرقابل‌تغییری وجود داشته باشد. با اشاره‌گرهای خام، می‌توانیم یک اشاره‌گر تغییرپذیر و یک اشاره‌گر غیرقابل‌تغییر به همان مکان ایجاد کنیم و داده را از طریق اشاره‌گر تغییرپذیر تغییر دهیم، که ممکن است یک رقابت داده‌ای ایجاد کند. مراقب باشید!

با وجود همه این خطرات، چرا باید از اشاره‌گرهای خام استفاده کنید؟ یک مورد استفاده اصلی هنگام تعامل با کد C است، همان‌طور که در بخش بعدی «فراخوانی یک تابع یا متد ناامن» خواهید دید. مورد دیگر زمانی است که انتزاع‌های ایمنی را می‌سازید که بررسی‌کننده قرض‌گیری درک نمی‌کند. ما توابع ناامن را معرفی خواهیم کرد و سپس به مثالی از یک انتزاع امن که از کد ناامن استفاده می‌کند نگاه خواهیم کرد.

### فراخوانی یک تابع یا متد ناامن

دومین نوع عملیاتی که می‌توانید در یک بلوک ناامن انجام دهید، فراخوانی توابع ناامن است. توابع و متدهای ناامن دقیقاً شبیه توابع و متدهای معمولی به نظر می‌رسند، اما قبل از بقیه تعریف، یک `unsafe` اضافی دارند. کلمه کلیدی `unsafe` در این زمینه نشان می‌دهد که تابع الزاماتی دارد که باید هنگام فراخوانی این تابع رعایت کنیم، زیرا Rust نمی‌تواند تضمین کند که ما این الزامات را برآورده کرده‌ایم. با فراخوانی یک تابع ناامن در داخل یک بلوک ناامن، ما می‌گوییم که مستندات این تابع را خوانده‌ایم و مسئولیت رعایت قراردادهای تابع را بر عهده می‌گیریم.

اینجا یک تابع ناامن به نام `dangerous` آورده شده است که در بدنه خود کاری انجام نمی‌دهد:

```rust
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
```

ما باید تابع `dangerous` را در یک بلوک ناامن جداگانه فراخوانی کنیم. اگر سعی کنیم `dangerous` را بدون بلوک ناامن فراخوانی کنیم، یک خطا دریافت خواهیم کرد:

```
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --> src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

با بلوک ناامن، ما به Rust اعلام می‌کنیم که مستندات تابع را خوانده‌ایم، می‌فهمیم چگونه از آن به‌درستی استفاده کنیم، و تأیید کرده‌ایم که قرارداد تابع را رعایت می‌کنیم.

برای انجام عملیات ناامن در بدنه یک تابع ناامن، همچنان باید از یک بلوک ناامن استفاده کنید، همان‌طور که در یک تابع معمولی، و اگر فراموش کنید، کامپایلر به شما هشدار خواهد داد. این کمک می‌کند تا بلوک‌های ناامن تا حد ممکن کوچک نگه داشته شوند، زیرا ممکن است عملیات ناامن در کل بدنه تابع لازم نباشد.

### ایجاد یک انتزاع امن بر روی کد ناامن

فقط به این دلیل که یک تابع شامل کد ناامن است، به این معنا نیست که باید کل تابع را به‌عنوان ناامن علامت‌گذاری کنیم. در واقع، بسته‌بندی کد ناامن در یک تابع امن یک انتزاع رایج است. به‌عنوان مثال، بیایید تابع `split_at_mut` از کتابخانه استاندارد را بررسی کنیم، که به مقداری کد ناامن نیاز دارد. ما کاوش خواهیم کرد که چگونه ممکن است آن را پیاده‌سازی کنیم. این متد امن روی برش‌های تغییرپذیر تعریف شده است: یک برش را می‌گیرد و با تقسیم برش در شاخص داده‌شده به‌عنوان آرگومان، آن را به دو برش تبدیل می‌کند. Listing 20-4 نشان می‌دهد چگونه از `split_at_mut` استفاده کنیم.

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

**Listing 20-4: استفاده از تابع امن split_at_mut**

ما نمی‌توانیم این تابع را فقط با استفاده از Rust امن پیاده‌سازی کنیم. تلاشی ممکن است شبیه Listing 20-5 باشد، که کامپایل نخواهد شد. برای سادگی، ما `split_at_mut` را به‌عنوان یک تابع به‌جای یک متد پیاده‌سازی خواهیم کرد و فقط برای برش‌های مقادیر `i32` به‌جای یک نوع عمومی `T`.

```rust
// این کد کامپایل نمی‌شود!
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

**Listing 20-5: تلاش برای پیاده‌سازی split_at_mut با استفاده از فقط Rust امن**

این تابع ابتدا طول کل برش را دریافت می‌کند. سپس تأیید می‌کند که شاخص داده‌شده به‌عنوان پارامتر در داخل برش است با بررسی اینکه آیا کمتر یا برابر با طول است یا خیر. این تأیید به این معناست که اگر شاخصی بزرگ‌تر از طول برای تقسیم برش پاس دهیم، تابع قبل از تلاش برای استفاده از آن شاخص پنیک خواهد کرد.

سپس دو برش تغییرپذیر را در یک تاپل برمی‌گردانیم: یکی از ابتدای برش اصلی تا شاخص `mid` و دیگری از `mid` تا انتهای برش.

وقتی سعی کنیم کد در Listing 20-5 را کامپایل کنیم، یک خطا دریافت خواهیم کرد.

```
$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --> src/main.rs:6:31
  |
1 | fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&mut values[..mid], &mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
```

بررسی‌کننده قرض‌گیری Rust نمی‌تواند درک کند که ما بخش‌های مختلف برش را قرض می‌گیریم؛ فقط می‌داند که ما دو بار از همان برش قرض می‌گیریم. قرض گرفتن بخش‌های مختلف یک برش اساساً مشکلی ندارد زیرا دو برش همپوشانی ندارند، اما Rust به اندازه کافی هوشمند نیست که این را بداند. وقتی می‌دانیم کد درست است، اما Rust نمی‌داند، زمان استفاده از کد ناامن است.

Listing 20-6 نشان می‌دهد چگونه با استفاده از یک بلوک ناامن، یک اشاره‌گر خام، و چند فراخوانی به توابع ناامن، پیاده‌سازی `split_at_mut` را کارآمد کنیم.

```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

**Listing 20-6: استفاده از کد ناامن در پیاده‌سازی تابع split_at_mut**

از بخش «نوع برش» در فصل چهارم به یاد بیاورید که برش‌ها یک اشاره‌گر به برخی داده‌ها و طول برش هستند. ما از متد `len` برای دریافت طول یک برش و متد `as_mut_ptr` برای دسترسی به اشاره‌گر خام یک برش استفاده می‌کنیم. در این مورد، چون یک برش تغییرپذیر به مقادیر `i32` داریم، `as_mut_ptr` یک اشاره‌گر خام با نوع `*mut i32` برمی‌گرداند، که ما آن را در متغیر `ptr` ذخیره کرده‌ایم.

ما تأیید را نگه می‌داریم که شاخص `mid` در داخل برش است. سپس به کد ناامن می‌رسیم: تابع `slice::from_raw_parts_mut` یک اشاره‌گر خام و یک طول می‌گیرد و یک برش ایجاد می‌کند. ما از آن برای ایجاد یک برش که از `ptr` شروع می‌شود و به طول `mid` آیتم است استفاده می‌کنیم. سپس متد `add` را روی `ptr` با `mid` به‌عنوان آرگومان فراخوانی می‌کنیم تا یک اشاره‌گر خام که از `mid` شروع می‌شود دریافت کنیم، و یک برش با استفاده از آن اشاره‌گر و تعداد آیتم‌های باقی‌مانده پس از `mid` به‌عنوان طول ایجاد می‌کنیم.

تابع `slice::from_raw_parts_mut` ناامن است زیرا یک اشاره‌گر خام می‌گیرد و باید اعتماد کند که این اشاره‌گر معتبر است. متد `add` روی اشاره‌گرهای خام نیز ناامن است زیرا باید اعتماد کند که مکان آفست نیز یک اشاره‌گر معتبر است. بنابراین، ما باید یک بلوک ناامن دور فراخوانی‌هایمان به `slice::from_raw_parts_mut` و `add` قرار دهیم تا بتوانیم آن‌ها را فراخوانی کنیم. با نگاه کردن به کد و با افزودن تأیید که `mid` باید کمتر یا برابر با `len` باشد، می‌توانیم بگوییم که تمام اشاره‌گرهای خام استفاده‌شده در بلوک ناامن، اشاره‌گرهای معتبری به داده‌های داخل برش خواهند بود. این یک استفاده قابل‌قبول و مناسب از `unsafe` است.

توجه کنید که نیازی به علامت‌گذاری تابع نتیجه‌گیری‌شده `split_at_mut` به‌عنوان ناامن نداریم، و می‌توانیم این تابع را از Rust امن فراخوانی کنیم. ما یک انتزاع امن به کد ناامن با پیاده‌سازی تابع ایجاد کرده‌ایم که از کد ناامن به روشی امن استفاده می‌کند، زیرا فقط اشاره‌گرهای معتبری از داده‌هایی که این تابع به آن‌ها دسترسی دارد ایجاد می‌کند.

در مقابل، استفاده از `slice::from_raw_parts_mut` در Listing 20-7 احتمالاً هنگام استفاده از برش خراب خواهد شد. این کد یک مکان حافظه دلخواه می‌گیرد و یک برش به طول 10,000 آیتم ایجاد می‌کند.

```rust
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

**Listing 20-7: ایجاد یک برش از یک مکان حافظه دلخواه**

ما مالک حافظه در این مکان دلخواه نیستیم، و هیچ تضمینی وجود ندارد که برشی که این کد ایجاد می‌کند شامل مقادیر معتبر `i32` باشد. تلاش برای استفاده از `values` به‌عنوان یک برش معتبر منجر به رفتار تعریف‌نشده می‌شود.

### استفاده از توابع extern برای فراخوانی کد خارجی

گاهی اوقات، کد Rust شما ممکن است نیاز به تعامل با کد نوشته‌شده در زبان دیگری داشته باشد. برای این منظور، Rust کلمه کلیدی `extern` را دارد که ایجاد و استفاده از یک رابط تابع خارجی (FFI) را تسهیل می‌کند. FFI راهی است برای یک زبان برنامه‌نویسی برای تعریف توابع و امکان فراخوانی آن توابع توسط یک زبان برنامه‌نویسی دیگر (خارجی).

Listing 20-8 نشان می‌دهد چگونه یک ادغام با تابع `abs` از کتابخانه استاندارد C تنظیم کنیم. توابعی که در بلوک‌های `extern` اعلان می‌شوند، به‌طور کلی برای فراخوانی از کد Rust ناامن هستند، بنابراین بلوک‌های `extern` نیز باید به‌عنوان ناامن علامت‌گذاری شوند. دلیل این است که زبان‌های دیگر قوانین و تضمین‌های Rust را اعمال نمی‌کنند، و Rust نمی‌تواند آن‌ها را بررسی کند، بنابراین مسئولیت اطمینان از ایمنی بر عهده برنامه‌نویس است.

**فایل: src/main.rs**

```rust
unsafe extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("مقدار مطلق -3 طبق C: {}", abs(-3)); // Absolute value of -3 according to C: {}
    }
}
```

**Listing 20-8: اعلان و فراخوانی یک تابع extern تعریف‌شده در زبان دیگر**

در داخل بلوک `unsafe extern "C"`، ما نام‌ها و امضاهای توابع خارجی از زبان دیگری که می‌خواهیم فراخوانی کنیم را فهرست می‌کنیم. بخش `"C"` مشخص می‌کند که تابع خارجی از کدام رابط باینری برنامه (ABI) استفاده می‌کند: ABI نحوه فراخوانی تابع در سطح اسمبلی را تعریف می‌کند. ABI `"C"` رایج‌ترین است و از ABI زبان برنامه‌نویسی C پیروی می‌کند. اطلاعات درباره تمام ABI‌هایی که Rust پشتیبانی می‌کند در مرجع Rust موجود است.

هر آیتمی که در یک بلوک `unsafe extern` اعلان می‌شود، به‌صورت ضمنی ناامن است. با این حال، برخی توابع FFI برای فراخوانی امن هستند. برای مثال، تابع `abs` از کتابخانه استاندارد C هیچ ملاحظه ایمنی حافظه‌ای ندارد و ما می‌دانیم که می‌توان آن را با هر `i32` فراخوانی کرد. در چنین مواردی، می‌توانیم از کلمه کلیدی `safe` استفاده کنیم تا بگوییم این تابع خاص حتی در یک بلوک `unsafe extern` برای فراخوانی امن است. پس از انجام این تغییر، فراخوانی آن دیگر نیازی به بلوک ناامن ندارد، همان‌طور که در Listing 20-9 نشان داده شده است.

**فایل: src/main.rs**

```rust
unsafe extern "C" {
    safe fn abs(input: i32) -> i32;
}

fn main() {
    println!("مقدار مطلق -3 طبق C: {}", abs(-3)); // Absolute value of -3 according to C: {}
}
```

**Listing 20-9: علامت‌گذاری صریح یک تابع به‌عنوان امن در داخل یک بلوک unsafe extern و فراخوانی امن آن**

علامت‌گذاری یک تابع به‌عنوان `safe` به‌طور ذاتی آن را امن نمی‌کند! در عوض، این مانند وعده‌ای است که شما به Rust می‌دهید که آن امن است. همچنان مسئولیت شماست که اطمینان حاصل کنید این وعده رعایت می‌شود!

### فراخوانی توابع Rust از زبان‌های دیگر

ما همچنین می‌توانیم از `extern` برای ایجاد رابطی استفاده کنیم که به زبان‌های دیگر اجازه می‌دهد توابع Rust را فراخوانی کنند. به‌جای ایجاد یک بلوک کامل `extern`، کلمه کلیدی `extern` را اضافه می‌کنیم و ABI مورد استفاده را درست قبل از کلمه کلیدی `fn` برای تابع مربوطه مشخص می‌کنیم. همچنین باید یک حاشیه‌نویسی `#[unsafe(no_mangle)]` اضافه کنیم تا به کامپایلر Rust بگوییم که نام این تابع را تغییر ندهد. تغییر نام (mangling) زمانی است که کامپایلر نامی که به یک تابع داده‌ایم را به نامی متفاوت تغییر می‌دهد که شامل اطلاعات بیشتری برای سایر بخش‌های فرآیند کامپایل است اما برای انسان کمتر قابل‌خواندن است. هر کامپایلر زبان برنامه‌نویسی نام‌ها را کمی متفاوت تغییر می‌دهد، بنابراین برای اینکه یک تابع Rust توسط زبان‌های دیگر قابل‌نام‌گذاری باشد، باید تغییر نام کامپایلر Rust را غیرفعال کنیم. این ناامن است زیرا ممکن است در کتابخانه‌ها بدون تغییر نام داخلی، برخورد نامی رخ دهد، بنابراین مسئولیت ماست که اطمینان حاصل کنیم نامی که انتخاب می‌کنیم برای صادرات بدون تغییر نام امن است.

در مثال زیر، ما تابع `call_from_c` را برای کد C قابل‌دسترسی می‌کنیم، پس از اینکه به یک کتابخانه مشترک کامپایل شد و از C لینک شد:

```rust
#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("فقط یک تابع Rust از C فراخوانی شد!"); // Just called a Rust function from C!
}
```

این استفاده از `extern` فقط در حاشیه‌نویسی نیاز به `unsafe` دارد، نه در بلوک `extern`.

### دسترسی یا تغییر یک متغیر استاتیک تغییرپذیر

در این کتاب، هنوز درباره متغیرهای سراسری صحبت نکرده‌ایم، که Rust از آن‌ها پشتیبانی می‌کند اما می‌توانند با قوانین مالکیت Rust مشکل‌ساز باشند. اگر دو نخ به همان متغیر سراسری تغییرپذیر دسترسی داشته باشند، می‌تواند باعث یک رقابت داده‌ای شود.

در Rust، متغیرهای سراسری به نام **متغیرهای استاتیک** شناخته می‌شوند. Listing 20-10 یک مثال از اعلان و استفاده از یک متغیر استاتیک با یک برش رشته‌ای به‌عنوان مقدار را نشان می‌دهد.

**فایل: src/main.rs**

```rust
static HELLO_WORLD: &str = "سلام، جهان!"; // Hello, world!

fn main() {
    println!("نام برابر است با: {}", HELLO_WORLD); // name is: {}
}
```

**Listing 20-10: تعریف و استفاده از یک متغیر استاتیک غیرقابل‌تغییر**

متغیرهای استاتیک شبیه ثابت‌ها هستند، که در بخش «ثابت‌ها» در فصل سوم بحث کردیم. نام‌های متغیرهای استاتیک به‌صورت قراردادی به شکل `SCREAMING_SNAKE_CASE` هستند. متغیرهای استاتیک فقط می‌توانند ارجاع‌هایی با طول عمر `'static` ذخیره کنند، به این معنا که کامپایلر Rust می‌تواند طول عمر را تشخیص دهد و ما نیازی به حاشیه‌نویسی صریح آن نداریم. دسترسی به یک متغیر استاتیک غیرقابل‌تغییر امن است.

تفاوت ظریفی بین ثابت‌ها و متغیرهای استاتیک غیرقابل‌تغییر وجود دارد و آن این است که مقادیر در یک متغیر استاتیک یک آدرس ثابت در حافظه دارند. استفاده از مقدار همیشه به همان داده دسترسی خواهد داشت. از سوی دیگر، ثابت‌ها اجازه دارند داده‌هایشان را هر بار که استفاده می‌شوند کپی کنند. تفاوت دیگر این است که متغیرهای استاتیک می‌توانند تغییرپذیر باشند. دسترسی و تغییر متغیرهای استاتیک تغییرپذیر ناامن است. Listing 20-11 نشان می‌دهد چگونه یک متغیر استاتیک تغییرپذیر به نام `COUNTER` را اعلان، دسترسی، و تغییر دهیم.

**فایل: src/main.rs**

```rust
static mut COUNTER: u32 = 0;

/// ایمنی: فراخوانی این از بیش از یک نخ به‌طور همزمان رفتار تعریف‌نشده است،
/// بنابراین باید تضمین کنید که فقط از یک نخ به‌طور همزمان فراخوانی می‌شود.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // ایمنی: این فقط از یک نخ در `main` فراخوانی می‌شود.
        add_to_count(3);
        println!("شمارنده: {}", *(&raw const COUNTER)); // COUNTER: {}
    }
}
```

**Listing 20-11: خواندن یا نوشتن در یک متغیر استاتیک تغییرپذیر ناامن است**

مانند متغیرهای معمولی، تغییرپذیری را با کلمه کلیدی `mut` مشخص می‌کنیم. هر کدی که از `COUNTER` می‌خواند یا در آن می‌نویسد باید در یک بلوک ناامن باشد. این کد کامپایل می‌شود و `COUNTER: 3` را همان‌طور که انتظار می‌رود چاپ می‌کند زیرا تک‌نخی است. دسترسی چندین نخ به `COUNTER` احتمالاً منجر به رقابت‌های داده‌ای می‌شود، بنابراین رفتار تعریف‌نشده است. به همین دلیل، ما باید کل تابع را به‌عنوان ناامن علامت‌گذاری کنیم و محدودیت ایمنی را مستند کنیم، تا هر کسی که تابع را فراخوانی می‌کند بداند چه کارهایی می‌تواند و نمی‌تواند به‌طور امن انجام دهد.

هرگاه یک تابع ناامن می‌نویسیم، مرسوم است که یک نظر با شروع `SAFETY` بنویسیم و توضیح دهیم که فراخواننده برای فراخوانی امن تابع چه کاری باید انجام دهد. به همین ترتیب، هرگاه یک عملیات ناامن انجام می‌دهیم، مرسوم است که یک نظر با شروع `SAFETY` بنویسیم تا توضیح دهیم چگونه قوانین ایمنی رعایت شده‌اند.

علاوه بر این، کامپایلر به شما اجازه نمی‌دهد ارجاع‌هایی به یک متغیر استاتیک تغییرپذیر ایجاد کنید. فقط می‌توانید از طریق یک اشاره‌گر خام، که با یکی از عملگرهای قرض‌گیری خام ایجاد شده است، به آن دسترسی پیدا کنید. این شامل مواردی می‌شود که ارجاع به‌صورت نامرئی ایجاد می‌شود، مانند زمانی که در `println!` در این لیست کد استفاده می‌شود. الزام اینکه ارجاع‌ها به متغیرهای استاتیک تغییرپذیر فقط از طریق اشاره‌گرهای خام ایجاد شوند، کمک می‌کند تا الزامات ایمنی برای استفاده از آن‌ها واضح‌تر شود.

با داده‌های تغییرپذیری که به‌صورت سراسری قابل‌دسترسی هستند، اطمینان از عدم وجود رقابت‌های داده‌ای دشوار است، به همین دلیل Rust متغیرهای استاتیک تغییرپذیر را ناامن در نظر می‌گیرد. در صورت امکان، بهتر است از تکنیک‌های هم‌زمانی و اشاره‌گرهای هوشمند امن برای نخ‌ها که در فصل شانزدهم بحث کردیم استفاده کنید تا کامپایلر بررسی کند که دسترسی به داده‌ها از نخ‌های مختلف به‌صورت امن انجام می‌شود.

### پیاده‌سازی یک ویژگی ناامن

ما می‌توانیم از `unsafe` برای پیاده‌سازی یک ویژگی ناامن استفاده کنیم. یک ویژگی زمانی ناامن است که حداقل یکی از متدهای آن دارای برخی شرایط ناپایدار باشد که کامپایلر نمی‌تواند تأیید کند. ما با افزودن کلمه کلیدی `unsafe` قبل از `trait` و علامت‌گذاری پیاده‌سازی ویژگی به‌عنوان ناامن، اعلام می‌کنیم که یک ویژگی ناامن است، همان‌طور که در Listing 20-12 نشان داده شده است.

```rust
unsafe trait Foo {
    // متدها اینجا می‌آیند
}

unsafe impl Foo for i32 {
    // پیاده‌سازی متدها اینجا می‌آید
}
```

**Listing 20-12: تعریف و پیاده‌سازی یک ویژگی ناامن**

با استفاده از `unsafe impl`، ما قول می‌دهیم که شرایط ناپایداری را که کامپایلر نمی‌تواند تأیید کند، رعایت خواهیم کرد.

به‌عنوان مثال، ویژگی‌های نشانه‌گر `Sync` و `Send` را که در بخش «هم‌زمانی قابل‌گسترش با ویژگی‌های Sync و Send» در فصل شانزدهم بحث کردیم، به یاد بیاورید: کامپایلر این ویژگی‌ها را به‌صورت خودکار پیاده‌سازی می‌کند اگر انواع ما کاملاً از انواع دیگری که `Send` و `Sync` را پیاده‌سازی کرده‌اند تشکیل شده باشند. اگر نوع ما شامل نوعی باشد که `Send` یا `Sync` را پیاده‌سازی نکرده است، مانند اشاره‌گرهای خام، و بخواهیم آن نوع را به‌عنوان `Send` یا `Sync` علامت‌گذاری کنیم، باید از `unsafe` استفاده کنیم. Rust نمی‌تواند تأیید کند که نوع ما تضمین‌هایی را برای ارسال امن در میان نخ‌ها یا دسترسی از چندین نخ رعایت می‌کند؛ بنابراین، باید این بررسی‌ها را به‌صورت دستی انجام دهیم و با `unsafe` این را نشان دهیم.

### دسترسی به فیلدهای یک اتحاد

آخرین عملیاتی که فقط با `unsafe` کار می‌کند، دسترسی به فیلدهای یک **اتحاد (union)** است. یک اتحاد شبیه یک ساختار است، اما در هر نمونه خاص در یک زمان فقط یکی از فیلدهای اعلان‌شده استفاده می‌شود. اتحادها عمدتاً برای تعامل با اتحادها در کد C استفاده می‌شوند. دسترسی به فیلدهای اتحاد ناامن است زیرا Rust نمی‌تواند نوع داده‌ای که در حال حاضر در نمونه اتحاد ذخیره شده است را تضمین کند. می‌توانید اطلاعات بیشتری درباره اتحادها در مرجع Rust بیابید.

### استفاده از Miri برای بررسی کد ناامن

وقتی کد ناامن می‌نویسید، ممکن است بخواهید بررسی کنید که آنچه نوشته‌اید واقعاً امن و درست است. یکی از بهترین راه‌ها برای انجام این کار استفاده از **Miri**، یک ابزار رسمی Rust برای تشخیص رفتار تعریف‌نشده است. در حالی که بررسی‌کننده قرض‌گیری یک ابزار استاتیک است که در زمان کامپایل کار می‌کند، Miri یک ابزار دینامیک است که در زمان اجرا کار می‌کند. آن کد شما را با اجرای برنامه یا مجموعه آزمون‌هایتان بررسی می‌کند و تشخیص می‌دهد که کی قوانین شناخته‌شده درباره نحوه کار Rust را نقض می‌کنید.

استفاده از Miri نیاز به یک نسخه شبانه (nightly) از Rust دارد (که در ضمیمه G: چگونه Rust ساخته می‌شود و «Rust شبانه» بیشتر درباره آن صحبت می‌کنیم). می‌توانید نسخه شبانه Rust و ابزار Miri را با تایپ `rustup +nightly component add miri` نصب کنید. این نسخه Rust پروژه شما را تغییر نمی‌دهد؛ فقط ابزار را به سیستم شما اضافه می‌کند تا بتوانید وقتی می‌خواهید از آن استفاده کنید. می‌توانید Miri را روی یک پروژه با تایپ `cargo +nightly miri run` یا `cargo +nightly miri test` اجرا کنید.

برای مثالی از اینکه این چقدر می‌تواند مفید باشد، فرض کنید آن را در برابر Listing 20-11 اجرا کنیم.

```
$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
COUNTER: 3
```

Miri به‌درستی به ما هشدار می‌دهد که ارجاع‌های مشترکی به داده‌های تغییرپذیر داریم. در اینجا، Miri فقط یک هشدار صادر می‌کند زیرا این مورد تضمین نمی‌شود که رفتار تعریف‌نشده باشد، و به ما نمی‌گوید چگونه مشکل را برطرف کنیم، اما حداقل می‌دانیم که خطر رفتار تعریف‌نشده وجود دارد و می‌توانیم درباره چگونگی ایمن کردن کد فکر کنیم. در برخی موارد، Miri همچنین می‌تواند خطاهای آشکار را تشخیص دهد—الگوهای کدی که مطمئناً اشتباه هستند—و توصیه‌هایی درباره نحوه رفع آن خطاها ارائه دهد.

Miri همه چیزهایی که ممکن است در نوشتن کد ناامن اشتباه کنید را نمی‌گیرد. Miri یک ابزار تحلیل دینامیک است، بنابراین فقط مشکلاتی را در کدی که واقعاً اجرا می‌شود تشخیص می‌دهد. این به این معناست که باید آن را همراه با تکنیک‌های آزمون خوب استفاده کنید تا اعتمادتان به کد ناامن نوشته‌شده افزایش یابد. Miri همچنین همه روش‌های ممکنی که کد شما می‌تواند نادرست باشد را پوشش نمی‌دهد.

به عبارت دیگر: اگر Miri مشکلی را تشخیص دهد، می‌دانید که یک اشکال وجود دارد، اما فقط به این دلیل که Miri اشکالی را تشخیص نمی‌دهد به این معنا نیست که مشکلی وجود ندارد. با این حال، Miri می‌تواند خیلی چیزها را تشخیص دهد. سعی کنید آن را روی سایر مثال‌های کد ناامن در این فصل اجرا کنید و ببینید چه می‌گوید!

می‌توانید اطلاعات بیشتری درباره Miri در مخزن GitHub آن بیابید.

## چه زمانی از کد ناامن استفاده کنیم

استفاده از `unsafe` برای استفاده از یکی از پنج قدرت فوق‌العاده که بحث کردیم اشتباه یا حتی ناپسند نیست، اما درست کردن کد ناامن پیچیده‌تر است زیرا کامپایلر نمی‌تواند به حفظ ایمنی حافظه کمک کند. وقتی دلیلی برای استفاده از کد ناامن دارید، می‌توانید این کار را انجام دهید، و داشتن حاشیه‌نویسی صریح `unsafe` پیدا کردن منبع مشکلات را وقتی رخ می‌دهند آسان‌تر می‌کند. هرگاه کد ناامن می‌نویسید، می‌توانید از Miri استفاده کنید تا مطمئن‌تر شوید که کدی که نوشته‌اید قوانین Rust را رعایت می‌کند.

برای کاوش عمیق‌تر در چگونگی کار مؤثر با Rust ناامن، راهنمای رسمی Rust در این موضوع، **Rustonomicon**، را بخوانید.
# انتشار یک کریت به Crates.io

ما از بسته‌های موجود در **crates.io** به‌عنوان وابستگی‌های پروژه‌مان استفاده کرده‌ایم، اما شما همچنین می‌توانید کد خود را با دیگران به اشتراک بگذارید با انتشار کریت‌های خودتان. رجیستری کریت در **crates.io** کد منبع بسته‌های شما را توزیع می‌کند، بنابراین عمدتاً میزبان کد منبع باز است.

**Rust** و **Cargo** دارای ویژگی‌هایی هستند که کریت منتشرشده شما را برای دیگران آسان‌تر برای یافتن و استفاده می‌کنند. در ادامه درباره برخی از این ویژگی‌ها صحبت خواهیم کرد و سپس توضیح خواهیم داد که چگونه یک کریت را منتشر کنیم.

## ایجاد کامنت‌ها مستندسازی مفید

مستندسازی دقیق کریت‌های شما به کاربران دیگر کمک می‌کند تا بدانند چگونه و چه زمانی از آن‌ها استفاده کنند، بنابراین ارزش صرف زمان برای نوشتن مستندات را دارد. در فصل سوم، بحث کردیم که چگونه کد **Rust** را با استفاده از دو اسلش `//` کامنت‌گذاری کنیم. **Rust** همچنین نوع خاصی از کامنت برای مستندسازی دارد، که به‌طور مناسب به‌عنوان **کامنت مستندسازی** شناخته می‌شود، و مستندات HTML تولید می‌کند. این HTML محتوای کامنت‌های مستندسازی را برای آیتم‌های API عمومی که برای برنامه‌نویسانی که علاقه‌مند به دانستن نحوه استفاده از کریت شما هستند نمایش می‌دهد، نه اینکه کریت شما چگونه پیاده‌سازی شده است.

کامنت‌های مستندسازی از سه اسلش `///` به جای دو اسلش استفاده می‌کنند و از نشانه‌گذاری **Markdown** برای قالب‌بندی متن پشتیبانی می‌کنند. کامنت‌های مستندسازی را دقیقاً قبل از آیتمی که مستند می‌کنند قرار دهید. **فهرست کد 14-1** کامنت‌های مستندسازی را برای یک تابع `add_one` در یک کریت به نام `my_crate` نشان می‌دهد.

**فایل: src/lib.rs**

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

**فهرست کد 14-1**: یک کامنت مستندسازی برای یک تابع

در اینجا، توضیحی از کاری که تابع `add_one` انجام می‌دهد ارائه می‌دهیم، بخشی را با عنوان **Examples** شروع می‌کنیم، و سپس کدی ارائه می‌دهیم که نشان می‌دهد چگونه از تابع `add_one` استفاده کنیم. می‌توانیم مستندات HTML را از این کامنت مستندسازی با اجرای `cargo doc` تولید کنیم. این دستور ابزار `rustdoc` را که همراه با **Rust** توزیع شده اجرا می‌کند و مستندات HTML تولیدشده را در پوشه `target/doc` قرار می‌دهد.

برای راحتی، اجرای `cargo doc --open` مستندات HTML را برای کریت کنونی شما (و همچنین مستندات تمام وابستگی‌های کریت شما) می‌سازد و نتیجه را در یک مرورگر وب باز می‌کند. به تابع `add_one` بروید و خواهید دید که متن در کامنت‌های مستندسازی چگونه رندر شده است، همان‌طور که در **شکل 14-1** نشان داده شده است:

<img src="img/trpl14-01.png">

**شکل 14-1**: مستندات HTML رندرشده برای تابع `add_one` از `my_crate`

### بخش‌های معمولاً استفاده‌شده

ما در **فهرست کد 14-1** از عنوان **Markdown** با `# Examples` استفاده کردیم تا بخشی در HTML با عنوان "Examples" ایجاد کنیم. در اینجا برخی از بخش‌های دیگری که نویسندگان کریت معمولاً در مستندات خود استفاده می‌کنند آورده شده است:

- **Panics**: سناریوهایی که در آن تابع مستندشده ممکن است **panic** کند. فراخوانندگان تابع که نمی‌خواهند برنامه‌هایشان **panic** کند باید اطمینان حاصل کنند که تابع را در این موقعیت‌ها فراخوانی نمی‌کنند.
- **Errors**: اگر تابع یک `Result` برمی‌گرداند، توصیف انواع خطاهایی که ممکن است رخ دهند و شرایطی که ممکن است باعث بازگشت آن خطاها شوند می‌تواند برای فراخوانندگان مفید باشد تا کدهایی برای مدیریت انواع مختلف خطاها به روش‌های مختلف بنویسند.
- **Safety**: اگر تابع **unsafe** برای فراخوانی باشد (که در فصل بیستم درباره ناامنی بحث می‌کنیم)، باید بخشی وجود داشته باشد که توضیح دهد چرا تابع ناامن است و شرایطی که تابع از فراخوانندگان انتظار دارد رعایت کنند را پوشش دهد.

اکثر کامنت‌های مستندسازی نیازی به همه این بخش‌ها ندارند، اما این یک چک‌لیست خوب است که به شما یادآوری می‌کند جنبه‌های کدتان که کاربران به دانستن آن‌ها علاقه‌مند هستند چیست.

### کامنت‌های مستندسازی به‌عنوان تست‌ها

افزودن بلوک‌های کد نمونه در کامنت‌های مستندسازی شما می‌تواند به نشان دادن نحوه استفاده از کتابخانه‌تان کمک کند، و این کار یک مزیت اضافی دارد: اجرای `cargo test` کدهای نمونه در مستندات شما را به‌عنوان تست اجرا می‌کند! هیچ چیز بهتر از مستنداتی با مثال نیست. اما هیچ چیز بدتر از مثال‌هایی نیست که کار نمی‌کنند چون کد از زمان نوشتن مستندات تغییر کرده است. اگر `cargo test` را با مستندات تابع `add_one` از **فهرست کد 14-1** اجرا کنیم، بخشی در نتایج تست خواهیم دید که به این شکل است:

```
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```

حالا، اگر تابع یا مثال را تغییر دهیم تا `assert_eq!` در مثال **panic** کند و دوباره `cargo test` را اجرا کنیم، خواهیم دید که تست‌های مستندات تشخیص می‌دهند که مثال و کد با یکدیگر همگام نیستند!

### کامنت‌گذاری آیتم‌های داخلی

سبک کامنت مستندسازی `//!` مستندات را به آیتمی که شامل کامنت‌ها است اضافه می‌کند، نه به آیتم‌هایی که پس از کامنت‌ها می‌آیند. ما معمولاً از این کامنت‌های مستندسازی در فایل ریشه کریت (`src/lib.rs` به‌صورت قراردادی) یا داخل یک ماژول برای مستندسازی کل کریت یا ماژول استفاده می‌کنیم.

به عنوان مثال، برای افزودن مستنداتی که هدف کریت `my_crate` را که شامل تابع `add_one` است توصیف می‌کند، کامنت‌های مستندسازی که با `//!` شروع می‌شوند را به ابتدای فایل `src/lib.rs` اضافه می‌کنیم، همان‌طور که در **فهرست کد 14-2** نشان داده شده است:

**فایل: src/lib.rs**

```rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
```

**فهرست کد 14-2**: مستندات برای کل کریت `my_crate`

توجه کنید که هیچ کدی پس از آخرین خط که با `//!` شروع می‌شود وجود ندارد. چون کامنت‌ها را با `//!` به جای `///` شروع کردیم، آیتمی را که شامل این کامنت است مستند می‌کنیم، نه آیتمی که پس از این کامنت می‌آید. در این مورد، آن آیتم فایل `src/lib.rs` است که ریشه کریت است. این کامنت‌ها کل کریت را توصیف می‌کنند.

وقتی `cargo doc --open` را اجرا می‌کنیم، این کامنت‌ها در صفحه اصلی مستندات برای `my_crate` بالای لیست آیتم‌های عمومی در کریت نمایش داده خواهند شد، همان‌طور که در **شکل 14-2** نشان داده شده است:


<img src="img/trpl14-02.png">

**شکل 14-2**: مستندات رندرشده برای `my_crate`، شامل کامنت توصیف‌کننده کل کریت

کامنت‌های مستندسازی درون آیتم‌ها به‌ویژه برای توصیف کریت‌ها و ماژول‌ها مفید هستند. از آن‌ها برای توضیح هدف کلی ظرف استفاده کنید تا به کاربرانتان کمک کنید سازمان‌دهی کریت را درک کنند.

## صادرات یک API عمومی مناسب با `pub use`

ساختار API عمومی شما یکی از ملاحظات اصلی هنگام انتشار یک کریت است. افرادی که از کریت شما استفاده می‌کنند با ساختار آن کمتر از شما آشنا هستند و اگر کریت شما سلسله‌مراتب ماژول بزرگی داشته باشد، ممکن است در یافتن قطعاتی که می‌خواهند استفاده کنند مشکل داشته باشند.

در فصل هفتم، پوشش دادیم که چگونه با استفاده از کلمه کلیدی `pub` آیتم‌ها را عمومی کنیم و آیتم‌ها را با کلمه کلیدی `use` به یک حوزه بیاوریم. با این حال، ساختاری که برای شما هنگام توسعه کریت منطقی است ممکن است برای کاربرانتان خیلی راحت نباشد. ممکن است بخواهید ساختارهای خود را در یک سلسله‌مراتب با چندین سطح سازمان‌دهی کنید، اما سپس افرادی که می‌خواهند از نوعی که در عمق سلسله‌مراتب تعریف کرده‌اید استفاده کنند ممکن است در یافتن وجود آن نوع مشکل داشته باشند. همچنین ممکن است از این که مجبورند `use my_crate::some_module::another_module::UsefulType;` را وارد کنند به جای `use my_crate::UsefulType;` ناراحت شوند.

خبر خوب این است که اگر ساختار برای دیگران که از کتابخانه دیگری استفاده می‌کنند راحت نباشد، نیازی به بازآرایی سازمان‌دهی داخلی خود ندارید: در عوض، می‌توانید با استفاده از `pub use` آیتم‌ها را دوباره صادر کنید تا یک ساختار عمومی متفاوت از ساختار خصوصی خود ایجاد کنید. دوباره صادر کردن یک آیتم عمومی را در یک مکان می‌گیرد و آن را در مکان دیگری عمومی می‌کند، گویی در آن مکان دیگر تعریف شده است.

به عنوان مثال، فرض کنید یک کتابخانه به نام `art` برای مدل‌سازی مفاهیم هنری ساخته‌ایم. در این کتابخانه دو ماژول وجود دارد: یک ماژول `kinds` شامل دو نوع برشمارشگر به نام‌های `PrimaryColor` و `SecondaryColor` و یک ماژول `utils` شامل تابعی به نام `mix`، همان‌طور که در **فهرست کد 14-3** نشان داده شده است:

**فایل: src/lib.rs**

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
        SecondaryColor::Orange // فقط برای مثال
    }
}
```

**فهرست کد 14-3**: یک کتابخانه `art` با آیتم‌های سازمان‌یافته در ماژول‌های `kinds` و `utils`

**شکل 14-3** نشان می‌دهد که صفحه اصلی مستندات برای این کریت که توسط `cargo doc` تولید شده چگونه به نظر می‌رسد:

**شکل 14-3**: صفحه اصلی مستندات برای `art` که ماژول‌های `kinds` و `utils` را لیست می‌کند

<img src="img/trpl14-03.png">

توجه کنید که انواع `PrimaryColor` و `SecondaryColor` در صفحه اصلی لیست نشده‌اند، و تابع `mix` نیز همین‌طور. برای دیدن آن‌ها باید روی `kinds` و `utils` کلیک کنیم.

کریت دیگری که به این کتابخانه وابسته است نیاز به دستورات `use` دارد که آیتم‌ها را از `art` به حوزه می‌آورند، و ساختار ماژولی که در حال حاضر تعریف شده را مشخص می‌کنند. **فهرست کد 14-4** مثالی از یک کریت را نشان می‌دهد که از آیتم‌های `PrimaryColor` و `mix` از کریت `art` استفاده می‌کند:

**فایل: src/main.rs**

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

**فهرست کد 14-4**: یک کریت که از آیتم‌های کریت `art` با ساختار داخلی صادرشده‌اش استفاده می‌کند

نویسنده کد در **فهرست کد 14-4**، که از کریت `art` استفاده می‌کند، باید تشخیص می‌داد که `PrimaryColor` در ماژول `kinds` و `mix` در ماژول `utils` است. ساختار ماژولی کریت `art` برای توسعه‌دهندگانی که روی کریت `art` کار می‌کنند مرتبط‌تر است تا کسانی که از آن استفاده می‌کنند. ساختار داخلی اطلاعات مفیدی برای کسی که سعی دارد نحوه استفاده از کریت `art` را بفهمد ندارد، بلکه باعث سردرگمی می‌شود چون توسعه‌دهندگانی که از آن استفاده می‌کنند باید بفهمند کجا را نگاه کنند، و باید نام‌های ماژول را در دستورات `use` مشخص کنند.

برای حذف سازمان‌دهی داخلی از API عمومی، می‌توانیم کد کریت `art` در **فهرست کد 14-3** را اصلاح کنیم تا دستورات `pub use` را اضافه کنیم تا آیتم‌ها را در سطح بالا دوباره صادر کنیم، همان‌طور که در **فهرست کد 14-5** نشان داده شده است:

**فایل: src/lib.rs**

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
        SecondaryColor::Orange // فقط برای مثال
    }
}
```

**فهرست کد 14-5**: افزودن دستورات `pub use` برای دوباره صادر کردن آیتم‌ها

مستندات API که `cargo doc` برای این کریت تولید می‌کند حالا دوباره‌صادرات را در صفحه اصلی لیست و لینک خواهد کرد، همان‌طور که در **شکل 14-4** نشان داده شده است، و یافتن انواع `PrimaryColor` و `SecondaryColor` و تابع `mix` را آسان‌تر می‌کند.

**شکل 14-4**: صفحه اصلی مستندات برای `art` که دوباره‌صادرات را لیست می‌کند

<img src="img/trpl14-04.png">

کاربران کریت `art` همچنان می‌توانند ساختار داخلی از **فهرست کد 14-3** را ببینند و استفاده کنند همان‌طور که در **فهرست کد 14-4** نشان داده شده است، یا می‌توانند از ساختار راحت‌تر در **فهرست کد 14-5** استفاده کنند، همان‌طور که در **فهرست کد 14-6** نشان داده شده است:

**فایل: src/main.rs**

```rust
use art::PrimaryColor;
use art::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

**فهرست کد 14-6**: برنامه‌ای که از آیتم‌های دوباره صادرشده از کریت `art` استفاده می‌کند

در مواردی که ماژول‌های تودرتوی زیادی وجود دارند، دوباره صادر کردن انواع در سطح بالا با `pub use` می‌تواند تفاوت قابل توجهی در تجربه افرادی که از کریت استفاده می‌کنند ایجاد کند. استفاده رایج دیگر از `pub use` دوباره صادر کردن تعاریف یک وابستگی در کریت کنونی است تا تعاریف آن کریت بخشی از API عمومی کریت شما شود.

ایجاد یک ساختار API عمومی مفید بیشتر یک هنر است تا علم، و می‌توانید تکرار کنید تا API‌ای را پیدا کنید که برای کاربرانتان بهترین کار را می‌کند. انتخاب `pub use` به شما انعطاف‌پذیری در نحوه ساختاردهی داخلی کریت‌تان می‌دهد و این ساختار داخلی را از آنچه به کاربرانتان ارائه می‌دهید جدا می‌کند. به برخی از کدهای کریت‌هایی که نصب کرده‌اید نگاه کنید تا ببینید آیا ساختار داخلی آن‌ها با API عمومی‌شان متفاوت است.

## تنظیم یک حساب Crates.io

قبل از اینکه بتوانید کریت‌هایی را منتشر کنید، باید یک حساب در **crates.io** ایجاد کنید و یک توکن API دریافت کنید. برای این کار، به صفحه اصلی در **crates.io** بروید و از طریق یک حساب **GitHub** وارد شوید. (حساب **GitHub** در حال حاضر یک الزام است، اما ممکن است سایت در آینده از روش‌های دیگری برای ایجاد حساب پشتیبانی کند.) پس از ورود، به تنظیمات حساب خود در **https://crates.io/me/** بروید و کلید API خود را بازیابی کنید. سپس دستور `cargo login` را اجرا کنید و کلید API خود را وقتی درخواست شد وارد کنید، مانند این:

```bash
$ cargo login
abcdefghijklmnopqrstuvwxyz012345
```

این دستور به **Cargo** توکن API شما را اطلاع می‌دهد و آن را به‌صورت محلی در `~/.cargo/credentials` ذخیره می‌کند. توجه کنید که این توکن یک **راز** است: آن را با هیچ‌کس دیگری به اشتراک نگذارید. اگر به هر دلیلی آن را با کسی به اشتراک دادید، باید آن را باطل کنید و یک توکن جدید در **crates.io** تولید کنید.

## افزودن متادیتا به یک کریت جدید

فرض کنید یک کریت دارید که می‌خواهید منتشر کنید. قبل از انتشار، باید مقداری متادیتا را در بخش `[package]` فایل `Cargo.toml` کریت اضافه کنید.

کریت شما نیاز به یک نام یکتا دارد. در حالی که روی یک کریت به‌صورت محلی کار می‌کنید، می‌توانید کریت را هرطور که دوست دارید نام‌گذاری کنید. با این حال، نام‌های کریت در **crates.io** بر اساس اصل اولین آمده، اولین خدمت داده می‌شود تخصیص داده می‌شوند. هنگامی که یک نام کریت گرفته شد، هیچ‌کس دیگری نمی‌تواند کریتی با آن نام منتشر کند. قبل از تلاش برای انتشار یک کریت، نام مورد نظر خود را جستجو کنید. اگر نام قبلاً استفاده شده باشد، باید نام دیگری پیدا کنید و فیلد `name` را در فایل `Cargo.toml` در بخش `[package]` ویرایش کنید تا از نام جدید برای انتشار استفاده کنید، مانند این:

**فایل: Cargo.toml**

```toml
[package]
name = "guessing_game"
```

حتی اگر یک نام یکتا انتخاب کرده باشید، وقتی در این مرحله `cargo publish` را برای انتشار کریت اجرا کنید، یک هشدار و سپس یک خطا دریافت خواهید کرد:

```bash
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
```

این نتیجه در یک خطا است زیرا برخی اطلاعات حیاتی را از دست داده‌اید: یک توضیح و مجوز لازم است تا مردم بدانند کریت شما چه کاری انجام می‌دهد و تحت چه شرایطی می‌توانند از آن استفاده کنند. در `Cargo.toml`، یک توضیح اضافه کنید که فقط یک یا دو جمله باشد، زیرا در نتایج جستجو همراه با کریت شما ظاهر خواهد شد. برای فیلد `license`، باید یک شناسه مجوز ارائه دهید. **Software Package Data Exchange (SPDX)** بنیاد لینوکس شناسه‌هایی را که می‌توانید برای این مقدار استفاده کنید لیست می‌کند. به عنوان مثال، برای مشخص کردن اینکه کریت خود را با مجوز MIT لایسنس کرده‌اید، شناسه MIT را اضافه کنید:

**فایل: Cargo.toml**

```toml
[package]
name = "guessing_game"
license = "MIT"
```

اگر می‌خواهید از مجوزی استفاده کنید که در **SPDX** ظاهر نمی‌شود، باید متن آن مجوز را در یک فایل قرار دهید، فایل را در پروژه خود گنجانید، و سپس از `license-file` برای مشخص کردن نام آن فایل به جای استفاده از کلید `license` استفاده کنید.

راهنمایی در مورد اینکه کدام مجوز برای پروژه شما مناسب است خارج از محدوده این کتاب است. بسیاری از افراد در جامعه **Rust** پروژه‌های خود را مانند **Rust** با استفاده از یک مجوز دوگانه **MIT OR Apache-2.0** لایسنس می‌کنند. این عمل نشان می‌دهد که می‌توانید چندین شناسه مجوز را با **OR** جدا کنید تا پروژه شما چندین مجوز داشته باشد.

با افزودن یک نام یکتا، نسخه، توضیح و مجوز، فایل `Cargo.toml` برای پروژه‌ای که آماده انتشار است ممکن است به این شکل باشد:

**فایل: Cargo.toml**

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

مستندات **Cargo** متادیتاهای دیگری را که می‌توانید مشخص کنید توصیف می‌کند تا دیگران بتوانند کریت شما را راحت‌تر کشف و استفاده کنند.

## انتشار به Crates.io

اکنون که یک حساب ایجاد کرده‌اید، توکن API خود را ذخیره کرده‌اید، یک نام برای کریت خود انتخاب کرده‌اید، و متادیتای مورد نیاز را مشخص کرده‌اید، آماده انتشار هستید! انتشار یک کریت نسخه خاصی را به **crates.io** آپلود می‌کند تا دیگران از آن استفاده کنند.

با احتیاط عمل کنید، زیرا انتشار **دائمی** است. نسخه هرگز نمی‌تواند بازنویسی شود، و کد نمی‌تواند حذف شود. یکی از اهداف اصلی **crates.io** این است که به‌عنوان یک آرشیو دائمی کد عمل کند تا ساخت‌های تمام پروژه‌هایی که به کریت‌های **crates.io** وابسته هستند همچنان کار کنند. اجازه دادن به حذف نسخه‌ها این هدف را غیرممکن می‌کند. با این حال، هیچ محدودیتی برای تعداد نسخه‌های کریتی که می‌توانید منتشر کنید وجود ندارد.

دوباره دستور `cargo publish` را اجرا کنید. حالا باید موفق شود:

```bash
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```

تبریک می‌گوییم! حالا کد خود را با جامعه **Rust** به اشتراک گذاشته‌اید، و هر کسی می‌تواند به‌راحتی کریت شما را به‌عنوان یک وابستگی به پروژه خود اضافه کند.

## انتشار نسخه جدید یک کریت موجود

وقتی تغییراتی در کریت خود ایجاد کرده‌اید و آماده انتشار نسخه جدید هستید، مقدار `version` مشخص‌شده در فایل `Cargo.toml` خود را تغییر دهید و دوباره منتشر کنید. از قوانین **Semantic Versioning** استفاده کنید تا تصمیم بگیرید شماره نسخه بعدی مناسب بر اساس نوع تغییراتی که انجام داده‌اید چیست. سپس `cargo publish` را اجرا کنید تا نسخه جدید را آپلود کنید.

## غیرفعال کردن نسخه‌ها از Crates.io با `cargo yank`

اگرچه نمی‌توانید نسخه‌های قبلی یک کریت را حذف کنید، می‌توانید از افزودن آن‌ها به‌عنوان یک وابستگی جدید توسط پروژه‌های آینده جلوگیری کنید. این کار زمانی مفید است که یک نسخه کریت به دلیلی خراب باشد. در چنین موقعیت‌هایی، **Cargo** از **yanking** یک نسخه کریت پشتیبانی می‌کند.

**Yanking** یک نسخه مانع از این می‌شود که پروژه‌های جدید به آن نسخه وابسته شوند، در حالی که به تمام پروژه‌های موجود که به آن وابسته هستند اجازه می‌دهد ادامه دهند. در واقع، یک **yank** به این معنی است که تمام پروژه‌هایی با فایل `Cargo.lock` خراب نخواهند شد، و هر فایل `Cargo.lock` آینده‌ای که تولید می‌شود از نسخه **yanked** استفاده نخواهد کرد.

برای **yank** کردن یک نسخه از یک کریت، در پوشه کریتی که قبلاً منتشر کرده‌اید، `cargo yank` را اجرا کنید و نسخه‌ای که می‌خواهید **yank** کنید را مشخص کنید. به عنوان مثال، اگر یک کریت به نام `guessing_game` نسخه 1.0.1 منتشر کرده‌ایم و می‌خواهیم آن را **yank** کنیم، در پوشه پروژه برای `guessing_game` این دستور را اجرا می‌کنیم:

```bash
$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
```

با افزودن `--undo` به دستور، می‌توانید یک **yank** را لغو کنید و به پروژه‌ها اجازه دهید دوباره به یک نسخه وابسته شوند:

```bash
$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
```

یک **yank** هیچ کدی را حذف نمی‌کند. به عنوان مثال، نمی‌تواند اسرار آپلودشده به‌صورت تصادفی را حذف کند. اگر چنین اتفاقی بیفتد، باید آن اسرار را فوراً بازنشانی کنید.
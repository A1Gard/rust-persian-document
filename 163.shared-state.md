# همزمانی با حالت اشتراکی

انتقال پیام (message passing) روشی عالی برای مدیریت همزمانی است، اما تنها راه نیست. روش دیگر این است که چندین نخ به داده‌های اشتراکی یکسان دسترسی داشته باشند. دوباره به بخشی از شعار مستندات زبان Go توجه کنید: «با به اشتراک گذاشتن حافظه ارتباط برقرار نکنید.»

ارتباط از طریق به اشتراک گذاشتن حافظه به چه شکل است؟ همچنین، چرا طرفداران انتقال پیام هشدار می‌دهند که از اشتراک حافظه استفاده نکنید؟

به نوعی، کانال‌ها در هر زبان برنامه‌نویسی شبیه به **مالکیت تک‌گانه** (single ownership) هستند، زیرا وقتی مقداری را از طریق یک کانال منتقل می‌کنید، دیگر نباید از آن مقدار استفاده کنید. همزمانی با حافظه اشتراکی شبیه به **مالکیت چندگانه** (multiple ownership) است: چندین نخ می‌توانند به‌طور همزمان به یک مکان حافظه دسترسی داشته باشند. همان‌طور که در فصل پانزدهم دیدید، جایی که اشاره‌گرهای هوشمند مالکیت چندگانه را ممکن ساختند، مالکیت چندگانه می‌تواند پیچیدگی‌هایی را به همراه داشته باشد، زیرا این مالکان مختلف نیاز به مدیریت دارند. سیستم نوع و قوانین مالکیت Rust به شدت در مدیریت صحیح این موضوع کمک می‌کنند. برای مثال، بیایید به **میوتکس‌ها** (mutexes)، یکی از ابزارهای رایج همزمانی برای حافظه اشتراکی، نگاه کنیم.

## استفاده از میوتکس‌ها برای اجازه دسترسی به داده‌ها از یک نخ در هر زمان

**میوتکس** (Mutex) مخفف **mutual exclusion** (انحصار متقابل) است، به این معنا که یک میوتکس فقط به یک نخ در هر زمان اجازه می‌دهد به برخی داده‌ها دسترسی پیدا کند. برای دسترسی به داده‌های داخل یک میوتکس، نخ باید ابتدا با درخواست برای به دست آوردن **قفل** (lock) میوتکس، سیگنال دهد که می‌خواهد دسترسی داشته باشد. قفل یک ساختار داده است که بخشی از میوتکس است و ردیابی می‌کند که چه کسی در حال حاضر دسترسی انحصاری به داده‌ها دارد. بنابراین، میوتکس به عنوان نگهبان داده‌هایی که نگه می‌دارد از طریق سیستم قفل توصیف می‌شود.

میوتکس‌ها به دلیل دشواری استفاده شهرت دارند، زیرا باید دو قانون را به خاطر داشته باشید:

1. باید قبل از استفاده از داده‌ها، قفل را به دست آورید.
2. وقتی کارتان با داده‌هایی که میوتکس نگهبان آن‌هاست تمام شد، باید داده‌ها را باز کنید (unlock) تا نخ‌های دیگر بتوانند قفل را به دست آورند.

برای یک استعاره دنیای واقعی برای میوتکس، یک بحث پنلی در یک کنفرانس را تصور کنید که فقط یک میکروفون دارد. قبل از اینکه یکی از اعضای پنل بتواند صحبت کند، باید درخواست کند یا سیگنال دهد که می‌خواهد از میکروفون استفاده کند. وقتی میکروفون را می‌گیرد، می‌تواند تا زمانی که می‌خواهد صحبت کند و سپس میکروفون را به عضو بعدی پنل که درخواست صحبت کرده است تحویل دهد. اگر یکی از اعضای پنل فراموش کند میکروفون را پس از اتمام کارش تحویل دهد، هیچ‌کس دیگری نمی‌تواند صحبت کند. اگر مدیریت میکروفون اشتراکی اشتباه پیش برود، پنل آن‌طور که برنامه‌ریزی شده کار نخواهد کرد!

مدیریت میوتکس‌ها می‌تواند بسیار دشوار باشد، به همین دلیل بسیاری از افراد به کانال‌ها علاقه‌مند هستند. با این حال، به لطف سیستم نوع و قوانین مالکیت Rust، نمی‌توانید قفل کردن و باز کردن را اشتباه انجام دهید.

### API میوتکس `<T>`

به عنوان مثالی از نحوه استفاده از میوتکس، بیایید با استفاده از یک میوتکس در یک زمینه تک‌نخی شروع کنیم، همان‌طور که در Listing 16-12 نشان داده شده است:

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}
```

**توضیح**:
- مانند بسیاری از نوع‌ها، ما یک `Mutex<T>` را با استفاده از تابع مرتبط `new` ایجاد می‌کنیم.
- برای دسترسی به داده‌های داخل میوتکس، از متد `lock` برای به دست آوردن قفل استفاده می‌کنیم. این فراخوانی نخ فعلی را مسدود می‌کند تا زمانی که نوبت ما برای داشتن قفل برسد.
- فراخوانی `lock` اگر نخی که قفل را در اختیار دارد پنیک کند،失败 خواهد کرد. در این صورت، هیچ‌کس دیگر نمی‌تواند قفل را به دست آورد، بنابراین ما انتخاب کردیم که از `unwrap` استفاده کنیم و اگر در این موقعیت باشیم، این نخ پنیک کند.
- پس از به دست آوردن قفل، می‌توانیم مقدار بازگشتی، که در اینجا `num` نامیده شده، را به عنوان یک ارجاع قابل تغییر به داده‌های داخل در نظر بگیریم.
- سیستم نوع تضمین می‌کند که ما قبل از استفاده از مقدار در `m`، قفل را به دست آوریم. نوع `m` برابر `Mutex<i32>` است، نه `i32`، بنابراین باید `lock` را فراخوانی کنیم تا بتوانیم به مقدار `i32` داخلی دسترسی پیدا کنیم. نمی‌توانیم فراموش کنیم؛ سیستم نوع به ما اجازه دسترسی به `i32` داخلی را بدون این کار نمی‌دهد.
- همان‌طور که ممکن است حدس بزنید، `Mutex<T>` یک اشاره‌گر هوشمند است. دقیق‌تر، فراخوانی `lock` یک اشاره‌گر هوشمند به نام `MutexGuard` برمی‌گرداند که در یک `LockResult` پیچیده شده و ما با فراخوانی `unwrap` آن را مدیریت کردیم. اشاره‌گر هوشمند `MutexGuard` ویژگی `Deref` را پیاده‌سازی می‌کند تا به داده‌های داخلی اشاره کند؛ این اشاره‌گر هوشمند همچنین یک پیاده‌سازی `Drop` دارد که قفل را به‌طور خودکار وقتی یک `MutexGuard` از محدوده خارج می‌شود آزاد می‌کند، که در انتهای محدوده داخلی رخ می‌دهد. در نتیجه، ما خطر فراموش کردن آزاد کردن قفل و مسدود کردن میوتکس از استفاده توسط نخ‌های دیگر را نداریم، زیرا آزادسازی قفل به‌طور خودکار اتفاق می‌افتد.
- پس از حذف قفل، می‌توانیم مقدار میوتکس را چاپ کنیم و ببینیم که توانستیم `i32` داخلی را به 6 تغییر دهیم.

## اشتراک یک `Mutex<T>` بین چندین نخ

حالا بیایید سعی کنیم یک مقدار را بین چندین نخ با استفاده از `Mutex<T>` به اشتراک بگذاریم. ما 10 نخ را راه‌اندازی می‌کنیم و هر کدام یک مقدار شمارشگر را 1 واحد افزایش می‌دهند، بنابراین شمارشگر از 0 به 10 می‌رسد. مثال در Listing 16-13 خطای کامپایل خواهد داشت و ما از این خطا برای یادگیری بیشتر درباره استفاده از `Mutex<T>` و نحوه کمک Rust به استفاده صحیح از آن استفاده خواهیم کرد:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("نتیجه: {}", *counter.lock().unwrap()); // Result: {}
}
```

**توضیح**:
- ما یک متغیر `counter` ایجاد می‌کنیم تا یک `i32` را داخل یک `Mutex<T>` نگه دارد، همان‌طور که در Listing 16-12 انجام دادیم.
- سپس، با پیمایش روی یک محدوده اعداد، 10 نخ ایجاد می‌کنیم. ما از `thread::spawn` استفاده می‌کنیم و به همه نخ‌ها یک کلوژر یکسان می‌دهیم: کلوژری که `counter` را به نخ منتقل می‌کند، قفل روی `Mutex<T>` را با فراخوانی متد `lock` به دست می‌آورد، و سپس 1 را به مقدار داخل میوتکس اضافه می‌کند.
- وقتی یک نخ اجرای کلوژر خود را به پایان می‌رساند، `num` از محدوده خارج می‌شود و قفل را آزاد می‌کند تا نخ دیگری بتواند آن را به دست آورد.
- در نخ اصلی، همه دسته‌های `join` را جمع‌آوری می‌کنیم. سپس، همان‌طور که در Listing 16-2 انجام دادیم، روی هر دسته `join` را فراخوانی می‌کنیم تا مطمئن شویم همه نخ‌ها به پایان رسیده‌اند. در این مرحله، نخ اصلی قفل را به دست می‌آورد و نتیجه این برنامه را چاپ می‌کند.

**خطای کامپایل**:

```
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --> src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("نتیجه: {}", *counter.lock().unwrap()); // Result: {}
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
```

**توضیح خطا**:
- پیام خطا بیان می‌کند که مقدار `counter` در تکرار قبلی حلقه منتقل (moved) شده است. Rust به ما می‌گوید که نمی‌توانیم مالکیت قفل `counter` را به چندین نخ منتقل کنیم.

بیایید خطای کامپایل را با روش مالکیت چندگانه‌ای که در فصل پانزدهم بحث کردیم برطرف کنیم.

### مالکیت چندگانه با چندین نخ

در فصل پانزدهم، با استفاده از اشاره‌گر هوشمند `Rc<T>` برای ایجاد یک مقدار با شمارش مرجع، مقداری را به چندین مالک دادیم. بیایید همین کار را اینجا انجام دهیم و ببینیم چه اتفاقی می‌افتد. ما `Mutex<T>` را در `Rc<T>` در Listing 16-14 می‌پیچیم و `Rc<T>` را قبل از انتقال مالکیت به نخ کلون می‌کنیم:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("نتیجه: {}", *counter.lock().unwrap()); // Result: {}
}
```

**خطای کامپایل**:

```
$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc<Mutex<i32>>` cannot be sent between threads safely
   --> src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc<Mutex<i32>>` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
note: required because it's used within this closure
   --> src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --> file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/std/src/thread/mod.rs:731:8
    |
728 | pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    |        ----- required by a bound in this function
...
731 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
```

**توضیح خطا**:
- بخش مهم خطا این است: ``Rc<Mutex<i32>>` cannot be sent between threads safely`. کامپایلر همچنین دلیل آن را به ما می‌گوید: ویژگی `Send` برای `Rc<Mutex<i32>>` پیاده‌سازی نشده است.
- متأسفانه، `Rc<T>` برای اشتراک‌گذاری بین نخ‌ها ایمن نیست. وقتی `Rc<T>` شمارش مرجع را مدیریت می‌کند، برای هر فراخوانی `clone` به شمارش اضافه می‌کند و وقتی هر کلون حذف می‌شود از شمارش کم می‌کند. اما از هیچ ابزار همزمانی استفاده نمی‌کند تا مطمئن شود که تغییرات در شمارش توسط نخ دیگری قطع نمی‌شود. این می‌تواند منجر به شمارش‌های اشتباه شود—خطاهای ظریفی که می‌توانند به نوبه خود باعث نشت حافظه یا حذف یک مقدار قبل از اینکه کارمان با آن تمام شود، شوند.
- چیزی که نیاز داریم نوعی است که دقیقاً مانند `Rc<T>` باشد اما تغییرات در شمارش مرجع را به روشی ایمن برای نخ انجام دهد.

### شمارش مرجع اتمیک با `Arc<T>`

خوشبختانه، `Arc<T>` نوعی مانند `Rc<T>` است که برای استفاده در موقعیت‌های همزمان ایمن است. حرف «a» مخفف **atomic** است، به این معنا که یک نوع با شمارش مرجع اتمیک است. اتمیک‌ها نوع دیگری از ابزارهای همزمانی هستند که در اینجا به جزئیات آن‌ها نمی‌پردازیم: برای اطلاعات بیشتر به مستندات کتابخانه استاندارد برای `std::sync::atomic` مراجعه کنید. در این مرحله، فقط باید بدانید که اتمیک‌ها مانند نوع‌های اولیه عمل می‌کنند اما برای اشتراک‌گذاری بین نخ‌ها ایمن هستند.

ممکن است بپرسید چرا همه نوع‌های اولیه اتمیک نیستند و چرا نوع‌های کتابخانه استاندارد به‌طور پیش‌فرض برای استفاده از `Arc<T>` پیاده‌سازی نشده‌اند. دلیلش این است که ایمنی نخ هزینه عملکردی دارد که فقط وقتی واقعاً به آن نیاز دارید می‌خواهید بپردازید. اگر فقط عملیات‌هایی روی مقادیر در یک نخ واحد انجام می‌دهید، کد شما می‌تواند سریع‌تر اجرا شود اگر مجبور نباشد تضمین‌هایی که اتمیک‌ها ارائه می‌دهند را اعمال کند.

بیایید به مثال خود برگردیم: `Arc<T>` و `Rc<T>` API یکسانی دارند، بنابراین برنامه خود را با تغییر خط `use`، فراخوانی `new`، و فراخوانی `clone` اصلاح می‌کنیم. کد در Listing 16-15 بالاخره کامپایل و اجرا خواهد شد:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("نتیجه: {}", *counter.lock().unwrap()); // Result: {}
}
```

**خروجی**:

```
نتیجه: 10
```

**توضیح**:
- ما موفق شدیم! از 0 تا 10 شمردیم، که شاید خیلی چشمگیر به نظر نیاید، اما چیزهای زیادی درباره `Mutex<T>` و ایمنی نخ به ما آموخت.
- می‌توانید از ساختار این برنامه برای انجام عملیات پیچیده‌تر از صرفاً افزایش یک شمارشگر استفاده کنید. با استفاده از این استراتژی، می‌توانید یک محاسبه را به بخش‌های مستقل تقسیم کنید، این بخش‌ها را بین نخ‌ها پخش کنید، و سپس از یک `Mutex<T>` استفاده کنید تا هر نخ نتیجه نهایی را با بخش خود به‌روزرسانی کند.
- توجه داشته باشید که اگر عملیات عددی ساده‌ای انجام می‌دهید، نوع‌های ساده‌تری نسبت به نوع‌های `Mutex<T>` در ماژول `std::sync::atomic` کتابخانه استاندارد وجود دارند. این نوع‌ها دسترسی اتمیک، همزمان و ایمن به نوع‌های اولیه را فراهم می‌کنند. ما در این مثال از `Mutex<T>` با یک نوع اولیه استفاده کردیم تا بتوانیم روی نحوه کار `Mutex<T>` تمرکز کنیم.

## شباهت‌ها بین `RefCell<T>`/`Rc<T>` و `Mutex<T>`/`Arc<T>`

ممکن است متوجه شده باشید که `counter` غیرقابل تغییر (immutable) است اما ما توانستیم یک ارجاع قابل تغییر به مقدار داخل آن به دست آوریم؛ این به این معناست که `Mutex<T>` مانند خانواده `Cell` تغییرپذیری داخلی (interior mutability) فراهم می‌کند. همان‌طور که در فصل پانزدهم از `RefCell<T>` برای اجازه دادن به ما برای تغییر محتویات داخل یک `Rc<T>` استفاده کردیم، از `Mutex<T>` برای تغییر محتویات داخل یک `Arc<T>` استفاده می‌کنیم.

جزئیات دیگری که باید توجه کنید این است که Rust نمی‌تواند شما را از همه نوع خطاهای منطقی هنگام استفاده از `Mutex<T>` محافظت کند. به یاد بیاورید که در فصل پانزدهم، استفاده از `Rc<T>` خطر ایجاد چرخه‌های مرجع را به همراه داشت، جایی که دو مقدار `Rc<T>` به یکدیگر اشاره می‌کنند و باعث نشت حافظه می‌شوند. به‌طور مشابه، `Mutex<T>` خطر ایجاد **بن‌بست‌ها** (deadlocks) را به همراه دارد. بن‌بست‌ها زمانی رخ می‌دهند که عملیاتی نیاز به قفل کردن دو منبع دارد و دو نخ هر کدام یکی از قفل‌ها را به دست آورده‌اند و باعث می‌شوند برای همیشه منتظر یکدیگر بمانند.

اگر به بن‌بست‌ها علاقه‌مند هستید، سعی کنید یک برنامه Rust بنویسید که بن‌بست داشته باشد؛ سپس استراتژی‌های کاهش بن‌بست برای میوتکس‌ها را در هر زبانی تحقیق کنید و سعی کنید آن‌ها را در Rust پیاده‌سازی کنید. مستندات API کتابخانه استاندارد برای `Mutex<T>` و `MutexGuard` اطلاعات مفیدی ارائه می‌دهد.

در ادامه این فصل، درباره ویژگی‌های `Send` و `Sync` صحبت خواهیم کرد و اینکه چگونه می‌توانیم از آن‌ها با نوع‌های سفارشی استفاده کنیم.
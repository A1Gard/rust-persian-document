# ویژگی‌های پیشرفته

در فصل دهم، در بخش «ویژگی‌ها: تعریف رفتار مشترک»، برای اولین بار ویژگی‌ها را پوشش دادیم، اما به جزئیات پیشرفته‌تر نپرداختیم. حالا که اطلاعات بیشتری درباره Rust دارید، می‌توانیم به جزئیات دقیق‌تر بپردازیم.

## انواع مرتبط

انواع مرتبط یک نوع جای‌نگهدار را به یک ویژگی متصل می‌کنند به‌گونه‌ای که تعریف‌های متدهای ویژگی می‌توانند از این انواع جای‌نگهدار در امضاهای خود استفاده کنند. پیاده‌سازی‌کننده یک ویژگی، نوع مشخصی را که باید به‌جای نوع جای‌نگهدار برای پیاده‌سازی خاص استفاده شود، مشخص خواهد کرد. به این ترتیب، می‌توانیم یک ویژگی را تعریف کنیم که از برخی انواع استفاده می‌کند بدون اینکه نیاز باشد دقیقاً بدانیم این انواع چیستند تا زمانی که ویژگی پیاده‌سازی شود.

ما اکثر ویژگی‌های پیشرفته در این فصل را به‌عنوان مواردی که به‌ندرت مورد نیاز هستند توصیف کرده‌ایم. انواع مرتبط جایی در میانه قرار دارند: آن‌ها کمتر از ویژگی‌های توضیح‌داده‌شده در بقیه کتاب استفاده می‌شوند، اما بیشتر از بسیاری از ویژگی‌های دیگر که در این فصل بحث شده‌اند رایج هستند.

یک مثال از ویژگی با نوع مرتبط، ویژگی `Iterator` است که کتابخانه استاندارد ارائه می‌دهد. نوع مرتبط به نام `Item` است و نماینده نوع مقادیر است که نوع پیاده‌سازی‌کننده ویژگی `Iterator` روی آن‌ها پیمایش می‌کند. تعریف ویژگی `Iterator` به‌صورت نشان‌داده‌شده در Listing 20-13 است.

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

**Listing 20-13: تعریف ویژگی Iterator که دارای یک نوع مرتبط Item است**

نوع `Item` یک جای‌نگهدار است، و تعریف متد `next` نشان می‌دهد که مقادیری از نوع `Option<Self::Item>` را برمی‌گرداند. پیاده‌سازی‌کنندگان ویژگی `Iterator` نوع مشخصی را برای `Item` مشخص خواهند کرد، و متد `next` یک `Option` شامل مقداری از آن نوع مشخص را برمی‌گرداند.

انواع مرتبط ممکن است شبیه مفهوم ژنریک‌ها به نظر برسند، زیرا ژنریک‌ها به ما امکان می‌دهند تابعی را تعریف کنیم بدون مشخص کردن اینکه چه انواعی را می‌تواند مدیریت کند. برای بررسی تفاوت بین این دو مفهوم، به پیاده‌سازی ویژگی `Iterator` روی یک نوع به نام `Counter` نگاه خواهیم کرد که مشخص می‌کند نوع `Item` برابر `u32` است:

**فایل: src/lib.rs**

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
```

این سینتکس به نظر شبیه ژنریک‌ها می‌آید. پس چرا ویژگی `Iterator` را با ژنریک‌ها تعریف نکنیم، همان‌طور که در Listing 20-14 نشان داده شده است؟

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

**Listing 20-14: یک تعریف فرضی از ویژگی Iterator با استفاده از ژنریک‌ها**

تفاوت این است که وقتی از ژنریک‌ها استفاده می‌کنیم، همان‌طور که در Listing 20-14 نشان داده شده، باید در هر پیاده‌سازی نوع‌ها را حاشیه‌نویسی کنیم؛ چون می‌توانیم ویژگی `Iterator<String>` را برای `Counter` یا هر نوع دیگری نیز پیاده‌سازی کنیم، می‌توانیم چندین پیاده‌سازی از `Iterator` برای `Counter` داشته باشیم. به عبارت دیگر، وقتی یک ویژگی دارای یک پارامتر ژنریک است، می‌توان آن را برای یک نوع چندین بار پیاده‌سازی کرد و هر بار نوع‌های مشخص پارامترهای نوع ژنریک را تغییر داد. وقتی از متد `next` روی `Counter` استفاده می‌کنیم، باید حاشیه‌نویسی نوع را ارائه دهیم تا مشخص کنیم کدام پیاده‌سازی از `Iterator` را می‌خواهیم استفاده کنیم.

با انواع مرتبط، نیازی به حاشیه‌نویسی نوع‌ها نداریم زیرا نمی‌توانیم یک ویژگی را روی یک نوع چندین بار پیاده‌سازی کنیم. در Listing 20-13 با تعریفی که از انواع مرتبط استفاده می‌کند، فقط یک بار می‌توانیم نوع `Item` را انتخاب کنیم، زیرا فقط یک `impl Iterator` برای `Counter` می‌تواند وجود داشته باشد. نیازی به مشخص کردن اینکه می‌خواهیم یک تکرارکننده از مقادیر `u32` در هر جایی که `next` را روی `Counter` فراخوانی می‌کنیم، نداریم.

انواع مرتبط همچنین بخشی از قرارداد ویژگی می‌شوند: پیاده‌سازی‌کنندگان ویژگی باید نوعی را برای جایگزینی جای‌نگهدار نوع مرتبط ارائه دهند. انواع مرتبط اغلب نامی دارند که نحوه استفاده از نوع را توصیف می‌کند، و مستندسازی نوع مرتبط در مستندات API یک عمل خوب است.

## پارامترهای نوع ژنریک پیش‌فرض و بارگذاری عملگر

وقتی از پارامترهای نوع ژنریک استفاده می‌کنیم، می‌توانیم یک نوع مشخص پیش‌فرض برای نوع ژنریک مشخص کنیم. این کار نیاز به مشخص کردن یک نوع مشخص توسط پیاده‌سازی‌کنندگان ویژگی را اگر نوع پیش‌فرض کار کند، از بین می‌برد. شما یک نوع پیش‌فرض را هنگام اعلان یک نوع ژنریک با سینتکس `<PlaceholderType=ConcreteType>` مشخص می‌کنید.

یک مثال عالی از موقعیتی که این تکنیک مفید است، با **بارگذاری عملگر** است، که در آن رفتار یک عملگر (مانند `+`) را در موقعیت‌های خاص سفارشی می‌کنید.

Rust به شما اجازه نمی‌دهد عملگرهای خودتان را ایجاد کنید یا عملگرهای دلخواه را بارگذاری کنید. اما می‌توانید عملیات و ویژگی‌های مربوطه فهرست‌شده در `std::ops` را با پیاده‌سازی ویژگی‌های مرتبط با عملگر بارگذاری کنید. برای مثال، در Listing 20-15 ما عملگر `+` را بارگذاری می‌کنیم تا دو نمونه `Point` را با هم جمع کند. این کار را با پیاده‌سازی ویژگی `Add` روی یک ساختار `Point` انجام می‌دهیم.

**فایل: src/main.rs**

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

**Listing 20-15: پیاده‌سازی ویژگی Add برای بارگذاری عملگر + برای نمونه‌های Point**

متد `add` مقادیر `x` دو نمونه `Point` و مقادیر `y` دو نمونه `Point` را جمع می‌کند تا یک `Point` جدید ایجاد کند. ویژگی `Add` دارای یک نوع مرتبط به نام `Output` است که نوع بازگشتی از متد `add` را تعیین می‌کند.

نوع ژنریک پیش‌فرض در این کد در داخل ویژگی `Add` است. این تعریف آن است:

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

این کد باید به‌طور کلی آشنا به نظر برسد: یک ویژگی با یک متد و یک نوع مرتبط. بخش جدید `Rhs=Self` است: این سینتکس به نام **پارامترهای نوع پیش‌فرض** شناخته می‌شود. پارامتر نوع ژنریک `Rhs` (مخفف «سمت راست») نوع پارامتر `rhs` در متد `add` را تعریف می‌کند. اگر هنگام پیاده‌سازی ویژگی `Add` نوع مشخصی برای `Rhs` مشخص نکنیم، نوع `Rhs` به‌طور پیش‌فرض به `Self` خواهد بود، که نوع پیاده‌سازی‌کننده `Add` خواهد بود.

وقتی ویژگی `Add` را برای `Point` پیاده‌سازی کردیم، از پیش‌فرض برای `Rhs` استفاده کردیم زیرا می‌خواستیم دو نمونه `Point` را جمع کنیم. بیایید به مثالی از پیاده‌سازی ویژگی `Add` نگاه کنیم که در آن می‌خواهیم نوع `Rhs` را به‌جای استفاده از پیش‌فرض سفارشی کنیم.

ما دو ساختار، `Millimeters` و `Meters`، داریم که مقادیر را در واحدهای مختلف نگه می‌دارند. این بسته‌بندی نازک یک نوع موجود در یک ساختار دیگر به نام **الگوی نوع جدید (newtype pattern)** شناخته می‌شود، که در بخش «استفاده از الگوی نوع جدید برای پیاده‌سازی ویژگی‌های خارجی روی انواع خارجی» با جزئیات بیشتری توصیف می‌کنیم. می‌خواهیم مقادیر در میلی‌متر را به مقادیر در متر اضافه کنیم و پیاده‌سازی `Add` تبدیل را به‌درستی انجام دهد. می‌توانیم ویژگی `Add` را برای `Millimeters` با `Meters` به‌عنوان `Rhs` پیاده‌سازی کنیم، همان‌طور که در Listing 20-16 نشان داده شده است.

**فایل: src/lib.rs**

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

**Listing 20-16: پیاده‌سازی ویژگی Add روی Millimeters برای افزودن Millimeters به Meters**

برای جمع کردن `Millimeters` و `Meters`، ما `impl Add<Meters>` را مشخص می‌کنیم تا مقدار پارامتر نوع `Rhs` را به‌جای استفاده از پیش‌فرض `Self` تنظیم کنیم.

شما از پارامترهای نوع پیش‌فرض به دو روش اصلی استفاده خواهید کرد:

1. برای گسترش یک نوع بدون شکستن کد موجود
2. برای اجازه دادن به سفارشی‌سازی در موارد خاصی که اکثر کاربران به آن نیاز ندارند

ویژگی `Add` کتابخانه استاندارد مثالی از هدف دوم است: معمولاً شما دو نوع مشابه را جمع می‌کنید، اما ویژگی `Add` توانایی سفارشی‌سازی فراتر از آن را فراهم می‌کند. استفاده از یک پارامتر نوع پیش‌فرض در تعریف ویژگی `Add` به این معناست که بیشتر اوقات نیازی به مشخص کردن پارامتر اضافی ندارید. به عبارت دیگر، کمی از کد تکراری پیاده‌سازی لازم نیست، که استفاده از ویژگی را آسان‌تر می‌کند.

هدف اول شبیه به هدف دوم است اما به‌صورت معکوس: اگر بخواهید یک پارامتر نوع به یک ویژگی موجود اضافه کنید، می‌توانید یک پیش‌فرض به آن بدهید تا امکان گسترش عملکرد ویژگی را بدون شکستن کد پیاده‌سازی موجود فراهم کنید.

## رفع ابهام بین متدهایی با نام یکسان

هیچ چیزی در Rust مانع از این نمی‌شود که یک ویژگی متدی با همان نام متد ویژگی دیگری داشته باشد، و Rust همچنین از پیاده‌سازی هر دو ویژگی روی یک نوع جلوگیری نمی‌کند. همچنین امکان پیاده‌سازی یک متد مستقیماً روی نوع با همان نام متدهای ویژگی‌ها وجود دارد.

وقتی متدهایی با نام یکسان را فراخوانی می‌کنید، باید به Rust بگویید که کدام یک را می‌خواهید استفاده کنید. کد در Listing 20-17 را در نظر بگیرید که در آن ما دو ویژگی، `Pilot` و `Wizard`، تعریف کرده‌ایم که هر دو دارای متدی به نام `fly` هستند. سپس هر دو ویژگی را روی یک نوع `Human` پیاده‌سازی می‌کنیم که خودش نیز متدی به نام `fly` مستقیماً روی آن پیاده‌سازی شده است. هر متد `fly` کار متفاوتی انجام می‌دهد.

**فایل: src/main.rs**

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("این کاپیتان شما صحبت می‌کند."); // This is your captain speaking.
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("بالا!"); // Up!
    }
}

impl Human {
    fn fly(&self) {
        println!("*با شدت دست‌ها را تکان می‌دهد*"); // *waving arms furiously*
    }
}
```

**Listing 20-17: دو ویژگی تعریف شده‌اند که دارای متدی هستند و روی نوع Human پیاده‌سازی شده‌اند، و یک متد fly مستقیماً روی Human پیاده‌سازی شده است.**

وقتی `fly` را روی یک نمونه از `Human` فراخوانی می‌کنیم، کامپایلر به‌طور پیش‌فرض متدی را که مستقیماً روی نوع پیاده‌سازی شده است فراخوانی می‌کند، همان‌طور که در Listing 20-18 نشان داده شده است.

**فایل: src/main.rs**

```rust
fn main() {
    let person = Human;
    person.fly();
}
```

**Listing 20-18: فراخوانی fly روی یک نمونه از Human**

اجرای این کد `*با شدت دست‌ها را تکان می‌دهد*` را چاپ خواهد کرد، که نشان می‌دهد Rust متد `fly` که مستقیماً روی `Human` پیاده‌سازی شده را فراخوانی کرده است.

برای فراخوانی متدهای `fly` از ویژگی `Pilot` یا ویژگی `Wizard`، باید از سینتکس صریح‌تری استفاده کنیم تا مشخص کنیم منظورمان کدام متد `fly` است. Listing 20-19 این سینتکس را نشان می‌دهد.

**فایل: src/main.rs**

```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

**Listing 20-19: مشخص کردن اینکه کدام متد fly از ویژگی را می‌خواهیم فراخوانی کنیم**

مشخص کردن نام ویژگی قبل از نام متد به Rust روشن می‌کند که کدام پیاده‌سازی از `fly` را می‌خواهیم فراخوانی کنیم. همچنین می‌توانستیم `Human::fly(&person)` را بنویسیم، که معادل `person.fly()` است که در Listing 20-19 استفاده کردیم، اما اگر نیازی به رفع ابهام نداشته باشیم، این کمی طولانی‌تر است.

اجرای این کد خروجی زیر را چاپ می‌کند:

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
```

چون متد `fly` یک پارامتر `self` می‌گیرد، اگر دو نوع داشتیم که هر دو یک ویژگی را پیاده‌سازی کرده باشند، Rust می‌توانست بر اساس نوع `self` تشخیص دهد که کدام پیاده‌سازی از ویژگی را استفاده کند.

با این حال، توابع مرتبطی که متد نیستند پارامتر `self` ندارند. وقتی چندین نوع یا ویژگی توابع غیرمتدی با نام تابع یکسان تعریف می‌کنند، Rust همیشه نمی‌داند منظور شما کدام نوع است مگر اینکه از سینتکس کاملاً مشخص استفاده کنید. برای مثال، در Listing 20-20 ما یک ویژگی برای یک پناهگاه حیوانات ایجاد می‌کنیم که می‌خواهد همه توله‌سگ‌های بچه را Spot نام‌گذاری کند. ما یک ویژگی `Animal` با یک تابع مرتبط غیرمتدی به نام `baby_name` ایجاد می‌کنیم. ویژگی `Animal` برای ساختار `Dog` پیاده‌سازی شده است، که روی آن همچنین یک تابع مرتبط غیرمتدی `baby_name` را مستقیماً ارائه می‌دهیم.

**فایل: src/main.rs**

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("یک سگ بچه به نام {} خوانده می‌شود", Dog::baby_name()); // A baby dog is called a {}
}
```

**Listing 20-20: یک ویژگی با یک تابع مرتبط و یک نوع با یک تابع مرتبط با همان نام که همچنین ویژگی را پیاده‌سازی می‌کند**

ما کد را برای نام‌گذاری همه توله‌سگ‌ها به Spot در تابع مرتبط `baby_name` که روی `Dog` تعریف شده است پیاده‌سازی می‌کنیم. نوع `Dog` همچنین ویژگی `Animal` را پیاده‌سازی می‌کند، که ویژگی‌هایی را که همه حیوانات دارند توصیف می‌کند. سگ‌های بچه به‌عنوان توله‌سگ نامیده می‌شوند، و این در پیاده‌سازی ویژگی `Animal` روی `Dog` در تابع `baby_name` مرتبط با ویژگی `Animal` بیان شده است.

در `main`، ما تابع `Dog::baby_name` را فراخوانی می‌کنیم، که تابع مرتبط تعریف‌شده مستقیماً روی `Dog` را فراخوانی می‌کند. این کد خروجی زیر را چاپ می‌کند:

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
```

این خروجی چیزی نیست که ما می‌خواستیم. ما می‌خواهیم تابع `baby_name` را که بخشی از ویژگی `Animal` است که روی `Dog` پیاده‌سازی کردیم فراخوانی کنیم تا کد «یک سگ بچه به نام puppy» را چاپ کند. تکنیک مشخص کردن نام ویژگی که در Listing 20-19 استفاده کردیم اینجا کمکی نمی‌کند؛ اگر `main` را به کد در Listing 20-21 تغییر دهیم، یک خطای کامپایل دریافت خواهیم کرد.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
fn main() {
    println!("یک سگ بچه به نام {} خوانده می‌شود", Animal::baby_name()); // A baby dog is called a {}
}
```

**Listing 20-21: تلاش برای فراخوانی تابع baby_name از ویژگی Animal، اما Rust نمی‌داند کدام پیاده‌سازی را استفاده کند**

چون `Animal::baby_name` پارامتر `self` ندارد، و ممکن است انواع دیگری وجود داشته باشند که ویژگی `Animal` را پیاده‌سازی کنند، Rust نمی‌تواند تشخیص دهد که کدام پیاده‌سازی از `Animal::baby_name` را می‌خواهیم. ما این خطای کامپایلر را دریافت خواهیم کرد:

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --> src/main.rs:20:43
   |
2  |     fn baby_name() -> String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
```

برای رفع ابهام و گفتن به Rust که می‌خواهیم از پیاده‌سازی `Animal` برای `Dog` به‌جای پیاده‌سازی `Animal` برای نوع دیگری استفاده کنیم، باید از سینتکس کاملاً مشخص استفاده کنیم. Listing 20-22 نشان می‌دهد چگونه از سینتکس کاملاً مشخص استفاده کنیم.

**فایل: src/main.rs**

```rust
fn main() {
    println!("یک سگ بچه به نام {} خوانده می‌شود", <Dog as Animal>::baby_name()); // A baby dog is called a {}
}
```

**Listing 20-22: استفاده از سینتکس کاملاً مشخص برای مشخص کردن اینکه می‌خواهیم تابع baby_name را از ویژگی Animal که روی Dog پیاده‌سازی شده است فراخوانی کنیم**

ما به Rust یک حاشیه‌نویسی نوع در داخل کروشه‌ها ارائه می‌دهیم، که نشان می‌دهد می‌خواهیم متد `baby_name` را از ویژگی `Animal` که روی `Dog` پیاده‌سازی شده است فراخوانی کنیم با گفتن اینکه می‌خواهیم نوع `Dog` را به‌عنوان یک `Animal` برای این فراخوانی تابع در نظر بگیریم. این کد حالا چیزی که می‌خواهیم را چاپ خواهد کرد:

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
```

به‌طور کلی، سینتکس کاملاً مشخص به‌صورت زیر تعریف می‌شود:

```rust
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

برای توابع مرتبطی که متد نیستند، گیرنده‌ای وجود نخواهد داشت: فقط فهرست سایر آرگومان‌ها خواهد بود. می‌توانید از سینتکس کاملاً مشخص در هر جایی که توابع یا متدها را فراخوانی می‌کنید استفاده کنید. با این حال، اجازه دارید هر بخشی از این سینتکس را که Rust می‌تواند از اطلاعات دیگر در برنامه تشخیص دهد حذف کنید. فقط در مواردی که چندین پیاده‌سازی از نام یکسان استفاده می‌کنند و Rust برای شناسایی اینکه کدام پیاده‌سازی را می‌خواهید فراخوانی کنید به کمک نیاز دارد، باید از این سینتکس پرجزئیات‌تر استفاده کنید.

## استفاده از سوپرویژگی‌ها

گاهی اوقات ممکن است یک تعریف ویژگی بنویسید که به ویژگی دیگری وابسته باشد: برای اینکه یک نوع ویژگی اول را پیاده‌سازی کند، می‌خواهید الزام کنید که آن نوع ویژگی دوم را نیز پیاده‌سازی کند. این کار را انجام می‌دهید تا تعریف ویژگی شما بتواند از آیتم‌های مرتبط ویژگی دوم استفاده کند. ویژگی‌ای که تعریف ویژگی شما به آن وابسته است، **سوپرویژگی** ویژگی شما نامیده می‌شود.

برای مثال، فرض کنید می‌خواهیم یک ویژگی `OutlinePrint` با یک متد `outline_print` ایجاد کنیم که مقدار داده‌شده را به‌گونه‌ای فرمت‌شده چاپ کند که با ستاره‌ها قاب‌بندی شده باشد. یعنی، با توجه به یک ساختار `Point` که ویژگی استاندارد کتابخانه `Display` را پیاده‌سازی می‌کند تا نتیجه `(x, y)` را بدهد، وقتی `outline_print` را روی یک نمونه `Point` که برای `x` مقدار 1 و برای `y` مقدار 3 دارد فراخوانی می‌کنیم، باید خروجی زیر را چاپ کند:

```
**********
*        *
* (1, 3) *
*        *
**********
```

در پیاده‌سازی متد `outline_print`، می‌خواهیم از عملکرد ویژگی `Display` استفاده کنیم. بنابراین، باید مشخص کنیم که ویژگی `OutlinePrint` فقط برای انواعی کار خواهد کرد که ویژگی `Display` را نیز پیاده‌سازی کرده‌اند و عملکردی که `OutlinePrint` نیاز دارد را فراهم می‌کنند. می‌توانیم این کار را در تعریف ویژگی با مشخص کردن `OutlinePrint: Display` انجام دهیم. این تکنیک شبیه افزودن یک قید ویژگی به ویژگی است. Listing 20-23 پیاده‌سازی ویژگی `OutlinePrint` را نشان می‌دهد.

**فایل: src/main.rs**

```rust
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
```

**Listing 20-23: پیاده‌سازی ویژگی OutlinePrint که به عملکرد از Display نیاز دارد**

چون مشخص کرده‌ایم که `OutlinePrint` به ویژگی `Display` نیاز دارد، می‌توانیم از تابع `to_string` استفاده کنیم که به‌صورت خودکار برای هر نوعی که `Display` را پیاده‌سازی می‌کند، پیاده‌سازی شده است. اگر سعی می‌کردیم از `to_string` بدون افزودن دونقطه و مشخص کردن ویژگی `Display` پس از نام ویژگی استفاده کنیم، خطایی دریافت می‌کردیم که می‌گفت هیچ متدی به نام `to_string` برای نوع `&Self` در حوزه فعلی یافت نشد.

بیایید ببینیم وقتی سعی می‌کنیم `OutlinePrint` را روی نوعی که `Display` را پیاده‌سازی نکرده است، مانند ساختار `Point`، پیاده‌سازی کنیم چه اتفاقی می‌افتد:

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
```

ما خطایی دریافت می‌کنیم که می‌گوید `Display` مورد نیاز است اما پیاده‌سازی نشده است:

```
$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --> src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --> src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
```

برای رفع این مشکل، ما `Display` را روی `Point` پیاده‌سازی می‌کنیم و قیدی که `OutlinePrint` نیاز دارد را برآورده می‌کنیم، مانند زیر:

**فایل: src/main.rs**

```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

سپس، پیاده‌سازی ویژگی `OutlinePrint` روی `Point` با موفقیت کامپایل خواهد شد، و می‌توانیم `outline_print` را روی یک نمونه `Point` فراخوانی کنیم تا آن را در قابی از ستاره‌ها نمایش دهیم.

## استفاده از الگوی نوع جدید برای پیاده‌سازی ویژگی‌های خارجی روی انواع خارجی

در بخش «پیاده‌سازی یک ویژگی روی یک نوع» در فصل دهم، به قانون یتیم اشاره کردیم که بیان می‌کند فقط می‌توانیم یک ویژگی را روی یک نوع پیاده‌سازی کنیم اگر یا ویژگی یا نوع، یا هر دو، محلی به crate ما باشند. می‌توان با استفاده از **الگوی نوع جدید (newtype pattern)** از این محدودیت عبور کرد، که شامل ایجاد یک نوع جدید در یک ساختار تاپل است. (ما ساختارهای تاپل را در بخش «استفاده از ساختارهای تاپل بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف» در فصل پنجم پوشش دادیم.) ساختار تاپل یک فیلد خواهد داشت و یک بسته‌بندی نازک دور نوع‌ای که می‌خواهیم ویژگی را برای آن پیاده‌سازی کنیم خواهد بود. سپس نوع بسته‌بندی محلی به crate ما است، و می‌توانیم ویژگی را روی بسته‌بندی پیاده‌سازی کنیم. نوع جدید اصطلاحی است که از زبان برنامه‌نویسی Haskell سرچشمه گرفته است. هیچ جریمه عملکردی در زمان اجرا برای استفاده از این الگو وجود ندارد، و نوع بسته‌بندی در زمان کامپایل حذف می‌شود.

به‌عنوان مثال، فرض کنید می‌خواهیم `Display` را روی `Vec<T>` پیاده‌سازی کنیم، که قانون یتیم از انجام مستقیم آن جلوگیری می‌کند زیرا ویژگی `Display` و نوع `Vec<T>` خارج از crate ما تعریف شده‌اند. می‌توانیم یک ساختار `Wrapper` ایجاد کنیم که یک نمونه از `Vec<T>` را نگه می‌دارد؛ سپس می‌توانیم `Display` را روی `Wrapper` پیاده‌سازی کنیم و از مقدار `Vec<T>` استفاده کنیم، همان‌طور که در Listing 20-24 نشان داده شده است.

**فایل: src/main.rs**

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```

**Listing 20-24: ایجاد یک نوع Wrapper دور Vec<String> برای پیاده‌سازی Display**

پیاده‌سازی `Display` از `self.0` برای دسترسی به `Vec<T>` داخلی استفاده می‌کند، زیرا `Wrapper` یک ساختار تاپل است و `Vec<T>` آیتم در شاخص 0 در تاپل است. سپس می‌توانیم از عملکرد ویژگی `Display` روی `Wrapper` استفاده کنیم.

نقطه ضعف استفاده از این تکنیک این است که `Wrapper` یک نوع جدید است، بنابراین متدهای مقداری که نگه می‌دارد را ندارد. باید تمام متدهای `Vec<T>` را مستقیماً روی `Wrapper` پیاده‌سازی کنیم به‌گونه‌ای که متدها به `self.0` واگذار شوند، که به ما امکان می‌دهد `Wrapper` را دقیقاً مانند یک `Vec<T>` رفتار کنیم. اگر بخواهیم نوع جدید تمام متدهای نوع داخلی را داشته باشد، پیاده‌سازی ویژگی `Deref` روی `Wrapper` برای بازگرداندن نوع داخلی یک راه‌حل خواهد بود (ما پیاده‌سازی ویژگی `Deref` را در بخش «رفتار با اشاره‌گرهای هوشمند مانند ارجاع‌های معمولی با ویژگی Deref» در فصل پانزدهم بحث کردیم). اگر نخواهیم نوع `Wrapper` تمام متدهای نوع داخلی را داشته باشد—برای مثال، برای محدود کردن رفتار نوع `Wrapper`—باید فقط متدهایی که می‌خواهیم را به‌صورت دستی پیاده‌سازی کنیم.

این الگوی نوع جدید حتی زمانی که ویژگی‌ها درگیر نیستند نیز مفید است. حالا بیایید تمرکز را تغییر دهیم و به برخی روش‌های پیشرفته برای تعامل با سیستم نوع Rust نگاه کنیم.
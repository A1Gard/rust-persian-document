# مقایسه عملکرد: حلقه‌ها در مقابل تکرارسازها

برای تصمیم‌گیری در مورد استفاده از حلقه‌ها یا تکرارسازها، باید بدانید کدام پیاده‌سازی سریع‌تر است: نسخه تابع `search` با یک حلقه `for` صریح یا نسخه با تکرارسازها.

ما یک بنچمارک اجرا کردیم که کل محتوای کتاب *ماجراهای شرلوک هولمز* نوشته سر آرتور کانن دویل را در یک `String` بارگذاری کرد و به دنبال کلمه `the` در محتوا گشتیم. نتایج بنچمارک برای نسخه `search` با استفاده از حلقه `for` و نسخه با استفاده از تکرارسازها به این صورت است:

```
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

هر دو پیاده‌سازی عملکرد مشابهی دارند! ما اینجا کد بنچمارک را توضیح نمی‌دهیم، زیرا هدف اثبات برابری این دو نسخه نیست، بلکه به‌دست‌آوردن حس کلی از مقایسه عملکرد این دو پیاده‌سازی است.

برای یک بنچمارک جامع‌تر، باید از متون مختلف با اندازه‌های گوناگون به‌عنوان محتوا، کلمات مختلف و کلماتی با طول‌های متفاوت به‌عنوان پرس‌وجو، و انواع دیگر تغییرات استفاده کنید. نکته این است: تکرارسازها، با وجود اینکه یک انتزاع سطح بالا هستند، به کدی تقریباً مشابه آنچه خودتان به‌صورت سطح پایین می‌نوشتید کامپایل می‌شوند. تکرارسازها یکی از **انتزاع‌های بدون هزینه** در **Rust** هستند، به این معنی که استفاده از این انتزاع هیچ سربار اجرایی اضافی تحمیل نمی‌کند. این مشابه تعریف بی‌یارنه استراس‌تروپ، طراح و پیاده‌ساز اصلی ++C، از بدون سربار در مقاله "مبانی ++C" (2012) است:

> به‌طور کلی، پیاده‌سازی‌های ++C از اصل بدون سربار پیروی می‌کنند: برای چیزی که استفاده نمی‌کنید، هزینه‌ای پرداخت نمی‌کنید. و بیشتر: چیزی که استفاده می‌کنید، نمی‌توانید بهتر از آن به‌صورت دستی کدنویسی کنید.

به عنوان مثال دیگری، کد زیر از یک رمزگشای صوتی گرفته شده است. الگوریتم رمزگشایی از عملیات ریاضی پیش‌بینی خطی استفاده می‌کند تا مقادیر آینده را بر اساس یک تابع خطی از نمونه‌های قبلی تخمین بزند. این کد از یک زنجیره تکرارساز استفاده می‌کند تا عملیاتی ریاضی را روی سه متغیر در حوزه انجام دهد: یک برش بافر از داده‌ها، یک آرایه از ۱۲ ضریب، و مقداری برای جابجایی داده‌ها در `qlp_shift`. ما متغیرها را در این مثال تعریف کرده‌ایم اما به آن‌ها مقداری نداده‌ایم؛ اگرچه این کد خارج از زمینه‌اش معنای زیادی ندارد، اما همچنان یک مثال مختصر و واقعی از این است که چگونه **Rust** ایده‌های سطح بالا را به کد سطح پایین ترجمه می‌کند.

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

برای محاسبه مقدار `prediction`، این کد روی هر یک از ۱۲ مقدار در `coefficients` پیمایش می‌کند و از متد `zip` برای جفت کردن مقادیر ضریب با ۱۲ مقدار قبلی در `buffer` استفاده می‌کند. سپس، برای هر جفت، مقادیر را با هم ضرب می‌کنیم، تمام نتایج را جمع می‌کنیم، و بیت‌های مجموع را به اندازه `qlp_shift` بیت به سمت راست جابجا می‌کنیم.

محاسبات در برنامه‌هایی مانند رمزگشاهای صوتی اغلب عملکرد را در اولویت قرار می‌دهند. اینجا، ما یک تکرارساز ایجاد می‌کنیم، از دو آداپتور استفاده می‌کنیم، و سپس مقدار را مصرف می‌کنیم. این کد **Rust** به چه کد اسمبلی کامپایل می‌شود؟ خب، تا زمان نگارش این متن، این کد به همان اسمبلی‌ای کامپایل می‌شود که شما خودتان به‌صورت دستی می‌نوشتید. هیچ حلقه‌ای متناظر با پیمایش روی مقادیر در `coefficients` وجود ندارد: **Rust** می‌داند که ۱۲ تکرار وجود دارد، بنابراین حلقه را **باز می‌کند (unrolls)**. باز کردن حلقه یک بهینه‌سازی است که سربار کد کنترل حلقه را حذف می‌کند و در عوض کد تکراری برای هر تکرار از حلقه تولید می‌کند.

تمام ضرایب در رجیسترها ذخیره می‌شوند، که به این معنی است که دسترسی به مقادیر بسیار سریع است. هیچ بررسی مرزی روی دسترسی به آرایه در زمان اجرا وجود ندارد. تمام این بهینه‌سازی‌هایی که **Rust** قادر به اعمال آن‌هاست، کد حاصل را بسیار کارآمد می‌کند. حالا که این را می‌دانید، می‌توانید بی‌باک از تکرارسازها و بسته‌بندی‌ها استفاده کنید! آن‌ها باعث می‌شوند کد به نظر سطح بالا بیاید اما جریمه عملکردی اجرایی برای این کار تحمیل نمی‌کنند.

## خلاصه

بسته‌بندی‌ها و تکرارسازها ویژگی‌های **Rust** هستند که از ایده‌های زبان‌های برنامه‌نویسی تابعی الهام گرفته شده‌اند. آن‌ها به توانایی **Rust** برای بیان واضح ایده‌های سطح بالا با عملکرد سطح پایین کمک می‌کنند. پیاده‌سازی‌های بسته‌بندی‌ها و تکرارسازها به‌گونه‌ای هستند که عملکرد اجرایی تحت تأثیر قرار نمی‌گیرد. این بخشی از هدف **Rust** برای ارائه **انتزاع‌های بدون هزینه** است.

حالا که بیان‌پذیری پروژه ورودی/خروجی خود را بهبود داده‌ایم، بیایید به برخی ویژگی‌های دیگر `cargo` نگاه کنیم که به ما کمک می‌کنند پروژه را با جهان به اشتراک بگذاریم.
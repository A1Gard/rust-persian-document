# استفاده از اشیاء ویژگی که امکان استفاده از مقادیر با نوع‌های مختلف را فراهم می‌کنند

در فصل هشتم، اشاره کردیم که یکی از محدودیت‌های وکتورها این است که آن‌ها فقط می‌توانند عناصری از یک نوع را ذخیره کنند. در Listing 8-9 یک راه‌حل ارائه کردیم که در آن یک برشمارش (enum) به نام `SpreadsheetCell` تعریف کردیم که گونه‌هایی برای نگه‌داری اعداد صحیح، اعداد اعشاری، و متن داشت. این به این معنا بود که می‌توانستیم نوع‌های مختلف داده را در هر سلول ذخیره کنیم و همچنان یک وکتور داشته باشیم که یک ردیف از سلول‌ها را نشان می‌داد. این یک راه‌حل کاملاً مناسب است وقتی آیتم‌های قابل تعویض ما مجموعه‌ای ثابت از نوع‌هایی هستند که در زمان کامپایل کد می‌دانیم.

با این حال، گاهی اوقات می‌خواهیم کاربر کتابخانه ما بتواند مجموعه نوع‌هایی که در موقعیت خاصی معتبر هستند را گسترش دهد. برای نشان دادن اینکه چگونه می‌توانیم به این هدف برسیم، یک ابزار رابط کاربری گرافیکی (GUI) نمونه ایجاد می‌کنیم که از یک لیست از آیتم‌ها پیمایش می‌کند و متد `draw` را روی هر یک فراخوانی می‌کند تا آن را روی صفحه نمایش دهد—تکنیکی رایج برای ابزارهای GUI. ما یک کریت کتابخانه‌ای به نام `gui` ایجاد خواهیم کرد که ساختار یک کتابخانه GUI را شامل می‌شود. این کریت ممکن است شامل برخی نوع‌ها برای استفاده افراد باشد، مانند `Button` یا `TextField`. علاوه بر این، کاربران `gui` می‌خواهند نوع‌های خودشان را ایجاد کنند که بتوانند ترسیم شوند: برای مثال، یک برنامه‌نویس ممکن است یک `Image` اضافه کند و دیگری ممکن است یک24 `SelectBox` اضافه کند.

ما در این مثال یک کتابخانه GUI کامل را پیاده‌سازی نمی‌کنیم، اما نشان خواهیم داد که قطعات چگونه کنار هم قرار می‌گیرند. در زمان نوشتن کتابخانه، نمی‌توانیم همه نوع‌هایی که برنامه‌نویسان دیگر ممکن است بخواهند ایجاد کنند را بدانیم و تعریف کنیم. اما می‌دانیم که `gui` نیاز به پیگیری مقادیر زیادی از نوع‌های مختلف دارد، و نیاز دارد که متد `draw` را روی هر یک از این مقادیر با نوع‌های مختلف فراخوانی کند. نیازی نیست دقیقاً بداند وقتی متد `draw` را فراخوانی می‌کنیم چه اتفاقی می‌افتد، فقط اینکه مقدار آن متد را برای فراخوانی در دسترس ما خواهد داشت.

برای انجام این کار در زبانی با وراثت، ممکن است کلاسی به نام `Component` تعریف کنیم که متدی به نام `draw` روی آن دارد. کلاس‌های دیگر، مانند `Button`، `Image`، و `SelectBox`، از `Component` ارث می‌برند و بنابراین متد `draw` را به ارث می‌برند. هر کدام می‌توانند متد `draw` را بازنویسی کنند تا رفتار سفارشی خود را تعریف کنند، اما چارچوب می‌تواند همه نوع‌ها را به‌عنوان نمونه‌های `Component` در نظر بگیرد و `draw` را روی آن‌ها فراخوانی کند. اما چون Rust وراثت ندارد، نیاز به راه دیگری برای ساختاردهی کتابخانه `gui` داریم تا به کاربران اجازه دهیم آن را با نوع‌های جدید گسترش دهند.

## تعریف یک ویژگی برای رفتار مشترک

برای پیاده‌سازی رفتاری که می‌خواهیم `gui` داشته باشد، ویژگی‌ای به نام `Draw` تعریف می‌کنیم که یک متد به نام `draw` خواهد داشت. سپس می‌توانیم یک وکتور تعریف کنیم که یک شیء ویژگی (trait object) را می‌گیرد. یک شیء ویژگی به یک نمونه از نوع‌ای که ویژگی مشخص‌شده ما را پیاده‌سازی می‌کند و یک جدول که برای جستجوی متدهای ویژگی روی آن نوع در زمان اجرا استفاده می‌شود، اشاره می‌کند. ما یک شیء ویژگی را با مشخص کردن نوعی اشاره‌گر، مانند یک ارجاع `&` یا یک اشاره‌گر هوشمند `Box<T>`، سپس کلمه کلیدی `dyn`، و سپس مشخص کردن ویژگی مرتبط ایجاد می‌کنیم. (در فصل بیستم درباره دلیل اینکه اشیاء ویژگی باید از یک اشاره‌گر استفاده کنند در بخش «نوع‌های با اندازه پویا و ویژگی Sized» صحبت خواهیم کرد.) ما می‌توانیم از اشیاء ویژگی به جای یک نوع Generic یا مشخص استفاده کنیم. هر جا که از یک شیء ویژگی استفاده می‌کنیم، سیستم نوع Rust در زمان کامپایل اطمینان حاصل می‌کند که هر مقداری که در آن زمینه استفاده می‌شود، ویژگی شیء ویژگی را پیاده‌سازی کرده است. در نتیجه، نیازی به دانستن همه نوع‌های ممکن در زمان کامپایل نداریم.

اشاره کردیم که در Rust، از نامیدن ساختارها و برشمارش‌ها به‌عنوان «اشیاء» خودداری می‌کنیم تا آن‌ها را از اشیاء زبان‌های دیگر متمایز کنیم. در یک ساختار یا برشمارش، داده‌های موجود در فیلدهای ساختار و رفتار در بلوک‌های `impl` جدا هستند، در حالی که در زبان‌های دیگر، داده و رفتار ترکیب‌شده در یک مفهوم اغلب به‌عنوان یک شیء برچسب‌گذاری می‌شود. با این حال، اشیاء ویژگی بیشتر شبیه اشیاء در زبان‌های دیگر هستند به این معنا که داده و رفتار را ترکیب می‌کنند. اما اشیاء ویژگی از اشیاء سنتی متفاوت هستند به این دلیل که نمی‌توانیم داده به یک شیء ویژگی اضافه کنیم. اشیاء ویژگی به‌طور کلی به اندازه اشیاء در زبان‌های دیگر مفید نیستند: هدف خاص آن‌ها امکان انتزاع روی رفتار مشترک است.

Listing 18-3 نشان می‌دهد چگونه یک ویژگی به نام `Draw` با یک متد به نام `draw` تعریف کنیم.

**فایل: src/lib.rs**

```rust
pub trait Draw {
    fn draw(&self);
}
```

**Listing 18-3: تعریف ویژگی Draw**

این نحو باید از بحث‌های ما درباره نحوه تعریف ویژگی‌ها در فصل دهم آشنا به نظر برسد. در ادامه، نحو جدیدی می‌آید: Listing 18-4 یک ساختار به نام `Screen` تعریف می‌کند که یک وکتور به نام `components` را نگه می‌دارد. این وکتور از نوع `Box<dyn Draw>` است، که یک شیء ویژگی است؛ این یک جایگزین برای هر نوع‌ای در یک `Box` است که ویژگی `Draw` را پیاده‌سازی می‌کند.

**فایل: src/lib.rs**

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

**Listing 18-4: تعریف ساختار Screen با یک فیلد components که یک وکتور از اشیاء ویژگی را نگه می‌دارد که ویژگی Draw را پیاده‌سازی می‌کنند**

روی ساختار `Screen`، متدی به نام `run` تعریف می‌کنیم که متد `draw` را روی هر یک از مؤلفه‌هایش فراخوانی می‌کند، همان‌طور که در Listing 18-5 نشان داده شده است.

**فایل: src/lib.rs**

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

**Listing 18-5: یک متد run روی Screen که متد draw را روی هر مؤلفه فراخوانی می‌کند**

این با تعریف یک ساختار که از یک پارامتر نوع Generic با محدودیت‌های ویژگی استفاده می‌کند متفاوت عمل می‌کند. یک پارامتر نوع Generic فقط می‌تواند در هر زمان با یک نوع مشخص جایگزین شود، در حالی که اشیاء ویژگی امکان پر شدن با چندین نوع مشخص را در زمان اجرا فراهم می‌کنند. برای مثال، می‌توانستیم ساختار `Screen` را با استفاده از یک نوع Generic و یک محدودیت ویژگی همان‌طور که در Listing 18-6 نشان داده شده تعریف کنیم:

**فایل: src/lib.rs**

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

**Listing 18-6: یک پیاده‌سازی جایگزین از ساختار Screen و متد run آن با استفاده از Generic‌ها و محدودیت‌های ویژگی**

این ما را محدود می‌کند به یک نمونه `Screen` که لیستی از مؤلفه‌ها همه از نوع `Button` یا همه از نوع `TextField` دارد. اگر همیشه فقط مجموعه‌های همگن خواهید داشت، استفاده از Generic‌ها و محدودیت‌های ویژگی ترجیح داده می‌شود زیرا تعریف‌ها در زمان کامپایل به نوع‌های مشخص مونومورفیزه می‌شوند.

از سوی دیگر، با روش استفاده از اشیاء ویژگی، یک نمونه `Screen` می‌تواند یک `Vec<T>` را نگه دارد که شامل یک `Box<Button>` و همچنین یک `Box<TextField>` باشد. بیایید ببینیم این چگونه کار می‌کند، و سپس درباره پیامدهای عملکردی در زمان اجرا صحبت خواهیم کرد.

## پیاده‌سازی ویژگی

حالا چند نوع که ویژگی `Draw` را پیاده‌سازی می‌کنند اضافه خواهیم کرد. ما نوع `Button` را ارائه می‌دهیم. باز هم، پیاده‌سازی واقعی یک کتابخانه GUI خارج از حوزه این کتاب است، بنابراین متد `draw` در بدنه‌اش هیچ پیاده‌سازی مفیدی نخواهد داشت. برای تصور اینکه پیاده‌سازی ممکن است چگونه باشد، یک ساختار `Button` ممکن است فیلدهایی برای عرض، ارتفاع، و برچسب داشته باشد، همان‌طور که در Listing 18-7 نشان داده شده است:

**فایل: src/lib.rs**

```rust
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // کد برای ترسیم واقعی یک دکمه
    }
}
```

**Listing 18-7: یک ساختار Button که ویژگی Draw را پیاده‌سازی می‌کند**

فیلدهای عرض، ارتفاع، و برچسب روی `Button` از فیلدهای سایر مؤلفه‌ها متفاوت خواهند بود؛ برای مثال، یک نوع `TextField` ممکن است همان فیلدها به علاوه یک فیلد نگهدارنده متن (placeholder) داشته باشد. هر یک از نوع‌هایی که می‌خواهیم روی صفحه ترسیم شوند، ویژگی `Draw` را پیاده‌سازی می‌کنند اما از کد متفاوتی در متد `draw` برای تعریف نحوه ترسیم آن نوع خاص استفاده می‌کنند، همان‌طور که `Button` اینجا دارد (بدون کد GUI واقعی، همان‌طور که اشاره شد). نوع `Button`، برای مثال، ممکن است یک بلوک `impl` اضافی داشته باشد که شامل متدهایی مربوط به اتفاقاتی است که وقتی کاربر روی دکمه کلیک می‌کند رخ می‌دهد. این نوع متدها برای نوع‌هایی مثل `TextField` اعمال نمی‌شوند.

اگر کسی که از کتابخانه ما استفاده می‌کند تصمیم بگیرد یک ساختار `SelectBox` پیاده‌سازی کند که فیلدهای عرض، ارتفاع، و گزینه‌ها را دارد، ویژگی `Draw` را روی نوع `SelectBox` نیز پیاده‌سازی می‌کند، همان‌طور که در Listing 18-8 نشان داده شده است.

**فایل: src/main.rs**

```rust
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // کد برای ترسیم واقعی یک جعبه انتخاب
    }
}
```

**Listing 18-8: کریت دیگری که از gui استفاده می‌کند و ویژگی Draw را روی یک ساختار SelectBox پیاده‌سازی می‌کند**

کاربر کتابخانه ما حالا می‌تواند تابع `main` خود را بنویسد تا یک نمونه `Screen` ایجاد کند. به نمونه `Screen`، می‌توانند یک `SelectBox` و یک `Button` را با قرار دادن هر کدام در یک `Box<T>` برای تبدیل شدن به یک شیء ویژگی اضافه کنند. سپس می‌توانند متد `run` را روی نمونه `Screen` فراخوانی کنند، که `draw` را روی هر یک از مؤلفه‌ها فراخوانی خواهد کرد. Listing 18-9 این پیاده‌سازی را نشان می‌دهد:

**فایل: src/main.rs**

```rust
use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("بله"), // Yes
                    String::from("شاید"), // Maybe
                    String::from("خیر"), // No
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("تأیید"), // OK
            }),
        ],
    };

    screen.run();
}
```

**Listing 18-9: استفاده از اشیاء ویژگی برای ذخیره مقادیر از نوع‌های مختلف که یک ویژگی یکسان را پیاده‌سازی می‌کنند**

وقتی کتابخانه را نوشتیم، نمی‌دانستیم که کسی ممکن است نوع `SelectBox` را اضافه کند، اما پیاده‌سازی `Screen` ما قادر به کار با نوع جدید و ترسیم آن بود زیرا `SelectBox` ویژگی `Draw` را پیاده‌سازی می‌کند، به این معنا که متد `draw` را پیاده‌سازی کرده است.

این مفهوم—فقط نگران پیام‌هایی که یک مقدار به آن‌ها پاسخ می‌دهد به جای نوع مشخص مقدار—مشابه مفهوم **تایپ اردکی** (duck typing) در زبان‌های با تایپ پویا است: اگر مثل اردک راه می‌رود و مثل اردک قارقار می‌کند، پس حتماً اردک است! در پیاده‌سازی `run` روی `Screen` در Listing 18-5، `run` نیازی به دانستن نوع مشخص هر مؤلفه ندارد. بررسی نمی‌کند که آیا یک مؤلفه نمونه‌ای از `Button` یا `SelectBox` است، فقط متد `draw` را روی مؤلفه فراخوانی می‌کند. با مشخص کردن `Box<dyn Draw>` به‌عنوان نوع مقادیر در وکتور `components`، ما `Screen` را تعریف کردیم که به مقادیر نیاز دارد که بتوانیم متد `draw` را روی آن‌ها فراخوانی کنیم.

مزیت استفاده از اشیاء ویژگی و سیستم نوع Rust برای نوشتن کدی مشابه کد با استفاده از تایپ اردکی این است که ما هرگز مجبور نیستیم در زمان اجرا بررسی کنیم که آیا یک مقدار متد خاصی را پیاده‌سازی می‌کند یا نگران خطاهایی باشیم که اگر مقداری متدی را پیاده‌سازی نکند اما ما آن را فراخوانی کنیم رخ می‌دهد. Rust کد ما را کامپایل نمی‌کند اگر مقادیر ویژگی‌هایی که اشیاء ویژگی به آن‌ها نیاز دارند را پیاده‌سازی نکنند.

برای مثال، Listing 18-10 نشان می‌دهد اگر سعی کنیم یک `Screen` با یک `String` به‌عنوان مؤلفه ایجاد کنیم چه اتفاقی می‌افتد.

**فایل: src/main.rs**

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("سلام"))], // Hi
    };

    screen.run();
}
```

**Listing 18-10: تلاش برای استفاده از نوع‌ای که ویژگی شیء ویژگی را پیاده‌سازی نمی‌کند**

ما این خطا را دریافت خواهیم کرد زیرا `String` ویژگی `Draw` را پیاده‌سازی نمی‌کند:

```
$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --> src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("سلام"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box<String>` to `Box<dyn Draw>`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
```

این خطا به ما اطلاع می‌دهد که یا چیزی را به `Screen` پاس می‌دهیم که قصد نداشتیم پاس دهیم و بنابراین باید نوع دیگری پاس دهیم، یا باید `Draw` را روی `String` پیاده‌سازی کنیم تا `Screen` بتواند `draw` را روی آن فراخوانی کند.

## اشیاء ویژگی ارسال پویا (Dynamic Dispatch) انجام می‌دهند

در بخش «عملکرد کد با استفاده از Generic‌ها» در فصل دهم، درباره فرآیند مونومورفیزاسیون که توسط کامپایلر روی Generic‌ها انجام می‌شود بحث کردیم: کامپایلر پیاده‌سازی‌های غیرGeneric از توابع و متدها را برای هر نوع مشخصی که به جای یک پارامتر نوع Generic استفاده می‌کنیم تولید می‌کند. کدی که از مونومورفیزاسیون نتیجه می‌شود، ارسال ایستا (static dispatch) انجام می‌دهد، یعنی زمانی که کامپایلر در زمان کامپایل می‌داند چه متدی را فراخوانی می‌کنید. این برخلاف ارسال پویا (dynamic dispatch) است، یعنی زمانی که کامپایلر نمی‌تواند در زمان کامپایل بگوید چه متدی را فراخوانی می‌کنید. در موارد ارسال پویا، کامپایلر کدی تولید می‌کند که در زمان اجرا تشخیص خواهد داد که کدام متد را فراخوانی کند.

وقتی از اشیاء ویژگی استفاده می‌کنیم، Rust باید از ارسال پویا استفاده کند. کامپایلر نمی‌داند همه نوع‌هایی که ممکن است با کدی که از اشیاء ویژگی استفاده می‌کند استفاده شوند، بنابراین نمی‌داند کدام متد پیاده‌سازی‌شده روی کدام نوع را باید فراخوانی کند. در عوض، در زمان اجرا، Rust از اشاره‌گرهای داخل شیء ویژگی برای دانستن اینکه کدام متد را فراخوانی کند استفاده می‌کند. این جستجو هزینه‌ای در زمان اجرا ایجاد می‌کند که در ارسال ایستا رخ نمی‌دهد. ارسال پویا همچنین مانع از انتخاب کامپایلر برای این‌لاین کردن کد یک متد می‌شود، که به نوبه خود برخی بهینه‌سازی‌ها را جلوگیری می‌کند، و Rust قوانینی دارد، به نام سازگاری dyn، درباره اینکه کجا می‌توانید و نمی‌توانید از ارسال پویا استفاده کنید. این قوانین خارج از حوزه این بحث هستند، اما می‌توانید اطلاعات بیشتری درباره آن‌ها در مرجع بخوانید. با این حال، ما انعطاف‌پذیری بیشتری در کدی که در Listing 18-5 نوشتیم به دست آوردیم و توانستیم در Listing 18-9 پشتیبانی کنیم، بنابراین این یک معاوضه است که باید در نظر گرفت.
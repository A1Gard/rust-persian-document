# خطاهای قابل بازیابی با `Result`

بیشتر خطاها آن‌قدر جدی نیستند که نیاز باشد برنامه کاملاً متوقف شود. گاهی اوقات وقتی یک تابع با شکست مواجه می‌شود، دلیلی دارد که می‌توانید به‌راحتی آن را تفسیر کرده و به آن پاسخ دهید. برای مثال، اگر بخواهید فایلی را باز کنید و این عملیات به دلیل عدم وجود فایل با شکست مواجه شود، ممکن است بخواهید به‌جای خاتمه دادن به فرآیند، فایل را ایجاد کنید.

از بخش «مدیریت شکست‌های احتمالی با `Result`» در فصل دوم به خاطر بیاورید که انوم `Result` به‌صورت زیر تعریف شده و دارای دو واریانت `Ok` و `Err` است:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` و `E` پارامترهای نوع Generic هستند که در فصل دهم مفصل‌تر درباره آن‌ها بحث خواهیم کرد. آنچه اکنون باید بدانید این است که `T` نوع مقداری را نشان می‌دهد که در حالت موفقیت در واریانت `Ok` برگردانده می‌شود و `E` نوع خطایی را نشان می‌دهد که در حالت شکست در واریانت `Err` برگردانده می‌شود. به دلیل وجود این پارامترهای Generic، می‌توان از نوع `Result` و توابعی که روی آن تعریف شده‌اند در موقعیت‌های مختلفی استفاده کرد که مقدار موفقیت و خطا ممکن است متفاوت باشد.

## فراخوانی تابعی که مقدار `Result` برمی‌گرداند

بیایید تابعی را فراخوانی کنیم که به دلیل احتمال شکست، مقدار `Result` برمی‌گرداند. در **جدول 9-3**، تلاش می‌کنیم یک فایل را باز کنیم.

**فایل: src/main.rs**

```rust
use std::fs::File;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file_result = File::open("hello.txt");
}
```

**جدول 9-3**: باز کردن یک فایل

نوع بازگشتی تابع `File::open` یک `Result<T, E>` است. پارامتر Generic `T` توسط پیاده‌سازی `File::open` با نوع مقدار موفقیت، یعنی `std::fs::File` (یک دسته فایل)، پر شده است. نوع `E` که در مقدار خطا استفاده شده، `std::io::Error` است. این نوع بازگشتی به این معناست که فراخوانی `File::open` ممکن است موفق شود و یک دسته فایل را برگرداند که می‌توانیم از آن بخوانیم یا به آن بنویسیم. همچنین ممکن است این فراخوانی با شکست مواجه شود: مثلاً فایل ممکن است وجود نداشته باشد یا ممکن است اجازه دسترسی به فایل را نداشته باشیم. تابع `File::open` باید راهی داشته باشد تا به ما بگوید که موفق شده یا خیر، و در عین حال دسته فایل یا اطلاعات خطا را به ما بدهد. این دقیقاً همان اطلاعاتی است که انوم `Result` منتقل می‌کند.

اگر `File::open` موفق شود، مقدار موجود در متغیر `greeting_file_result` یک نمونه از `Ok` خواهد بود که حاوی یک دسته فایل است. اگر با شکست مواجه شود، مقدار `greeting_file_result` یک نمونه از `Err` خواهد بود که اطلاعات بیشتری درباره نوع خطای رخ‌داده دارد.

## مدیریت مقدار بازگشتی `Result`

برای انجام اقدامات مختلف بسته به مقدار بازگشتی `File::open`، باید به کد **جدول 9-3** اضافه کنیم. **جدول 9-4** یک روش برای مدیریت `Result` با استفاده از ابزار پایه‌ای یعنی عبارت `match` را نشان می‌دهد که در فصل ششم بحث کردیم.

**فایل: src/main.rs**

```rust
use std::fs::File;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
```

**جدول 9-4**: استفاده از عبارت `match` برای مدیریت واریانت‌های `Result` که ممکن است برگردانده شوند.

> **توجه**: مانند انوم `Option`، انوم `Result` و واریانت‌های آن به‌طور خودکار توسط **prelude** به حوزه (scope) آورده شده‌اند، بنابراین نیازی به مشخص کردن `Result::` قبل از واریانت‌های `Ok` و `Err` در شاخه‌های `match` نداریم.

وقتی نتیجه `Ok` باشد، این کد مقدار داخلی فایل را از واریانت `Ok` برمی‌گرداند و ما آن دسته فایل را به متغیر `greeting_file` اختصاص می‌دهیم. بعد از `match`، می‌توانیم از دسته فایل برای خواندن یا نوشتن استفاده کنیم.

شاخه دیگر `match` حالتی را مدیریت می‌کند که مقدار `Err` از `File::open` دریافت می‌کنیم. در این مثال، ما انتخاب کرده‌ایم که ماکروی `panic!` را فراخوانی کنیم. اگر فایل `hello.txt` در دایرکتوری فعلی ما وجود نداشته باشد و این کد را اجرا کنیم، خروجی زیر را از ماکروی `panic!` خواهیم دید:

```bash
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

این خروجی به ما دقیقاً می‌گوید چه مشکلی رخ داده است.

## مدیریت انواع مختلف خطاها

کد **جدول 9-4** صرف‌نظر از دلیل شکست `File::open`، دچار `panic!` می‌شود. اما ما می‌خواهیم برای دلایل مختلف شکست، اقدامات متفاوتی انجام دهیم. اگر `File::open` به دلیل عدم وجود فایل شکست خورد، می‌خواهیم فایل را ایجاد کنیم و دسته فایل جدید را برگردانیم. اگر `File::open` به هر دلیل دیگری شکست خورد—مثلاً به دلیل نداشتن مجوز دسترسی به فایل—می‌خواهیم کد همچنان مانند **جدول 9-4** دچار `panic!` شود. برای این منظور، یک عبارت `match` داخلی اضافه می‌کنیم، همان‌طور که در **جدول 9-5** نشان داده شده است.

**فایل: src/main.rs**

```rust
use std::fs::File;
use std::io::ErrorKind;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            },
            _ => {
                panic!("Problem opening the file: {error:?}");
            }
        },
    };
}
```

**جدول 9-5**: مدیریت انواع مختلف خطاها به روش‌های متفاوت

نوع مقداری که `File::open` در واریانت `Err` برمی‌گرداند، `io::Error` است که یک ساختار (struct) ارائه‌شده توسط کتابخانه استاندارد است. این ساختار متدی به نام `kind` دارد که می‌توانیم آن را فراخوانی کنیم تا یک مقدار `io::ErrorKind` دریافت کنیم. انوم `io::ErrorKind` توسط کتابخانه استاندارد ارائه شده و دارای واریانت‌هایی است که انواع مختلف خطاهایی را که ممکن است از عملیات ورودی/خروجی (io) ناشی شوند، نشان می‌دهد. واریانتی که ما می‌خواهیم استفاده کنیم `ErrorKind::NotFound` است که نشان می‌دهد فایلی که سعی در باز کردن آن داریم هنوز وجود ندارد. بنابراین، ما روی `greeting_file_result` یک `match` انجام می‌دهیم، اما همچنین یک `match` داخلی روی `error.kind()` داریم.

شرطی که می‌خواهیم در `match` داخلی بررسی کنیم این است که آیا مقدار برگردانده‌شده توسط `error.kind()` واریانت `NotFound` از انوم `ErrorKind` است یا خیر. اگر باشد، سعی می‌کنیم با `File::create` فایل را ایجاد کنیم. اما چون `File::create` هم ممکن است شکست بخورد، به یک شاخه دوم در عبارت `match` داخلی نیاز داریم. وقتی فایل نمی‌تواند ایجاد شود، یک پیام خطای متفاوت چاپ می‌شود. شاخه دوم `match` خارجی همان‌طور باقی می‌ماند، بنابراین برنامه برای هر خطایی به‌جز خطای عدم وجود فایل، دچار `panic!` می‌شود.

## جایگزین‌هایی برای استفاده از `match` با `Result<T, E>`

استفاده از `match` بسیار زیاد است! عبارت `match` بسیار مفید است اما همچنین بسیار ابتدایی است. در فصل سیزدهم، درباره کلوژرها (closures) خواهید آموخت که با بسیاری از متدهای تعریف‌شده روی `Result<T, E>` استفاده می‌شوند. این متدها می‌توانند در مقایسه با استفاده از `match`، هنگام مدیریت مقادیر `Result<T, E>` در کد شما، مختصرتر باشند.

برای مثال، در اینجا روش دیگری برای نوشتن همان منطق نشان‌داده‌شده در **جدول 9-5** آورده شده است، این بار با استفاده از کلوژرها و متد `unwrap_or_else`:

```rust
use std::fs::File;
use std::io::ErrorKind;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
```

اگرچه این کد همان رفتار **جدول 9-5** را دارد، اما هیچ عبارت `match` ندارد و خواندن آن تمیزتر است. بعد از خواندن فصل سیزدهم، به این مثال برگردید و متد `unwrap_or_else` را در مستندات کتابخانه استاندارد جستجو کنید. متدهای بیشتری وجود دارند که می‌توانند هنگام برخورد با خطاها، عبارت‌های `match` تودرتو و بزرگ را ساده‌تر کنند.

## میانبرها برای `panic!` در صورت خطا: `unwrap` و `expect`

استفاده از `match` به‌اندازه کافی خوب کار می‌کند، اما می‌تواند کمی طولانی باشد و همیشه نیت (intent) را به‌خوبی منتقل نمی‌کند. نوع `Result<T, E>` متدهای کمکی زیادی دارد که برای انجام وظایف خاص‌تر تعریف شده‌اند. متد `unwrap` یک متد میانبر است که دقیقاً مانند عبارت `match` که در **جدول 9-4** نوشتیم، پیاده‌سازی شده است. اگر مقدار `Result` واریانت `Ok` باشد، `unwrap` مقدار داخل `Ok` را برمی‌گرداند. اگر `Result` واریانت `Err` باشد، `unwrap` ماکروی `panic!` را برای ما فراخوانی می‌کند. در اینجا یک مثال از عملکرد `unwrap` آورده شده است:

**فایل: src/main.rs**

```rust
use std::fs::File;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

اگر این کد را بدون وجود فایل `hello.txt` اجرا کنیم، پیام خطایی از فراخوانی `panic!` که متد `unwrap` ایجاد می‌کند، خواهیم دید:

```bash
thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

به‌طور مشابه، متد `expect` به ما اجازه می‌دهد پیام خطای `panic!` را خودمان انتخاب کنیم. استفاده از `expect` به‌جای `unwrap` و ارائه پیام‌های خطای خوب می‌تواند نیت شما را منتقل کرده و ردیابی منبع `panic` را آسان‌تر کند. نحو `expect` به این شکل است:

**فایل: src/main.rs**

```rust
use std::fs::File;

// این کد یک فایل را باز می‌کند!
fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

ما از `expect` به همان روش `unwrap` استفاده می‌کنیم: برای برگرداندن دسته فایل یا فراخوانی ماکروی `panic!`. پیام خطایی که `expect` در فراخوانی `panic!` استفاده می‌کند، پارامتری است که به `expect` پاس می‌دهیم، نه پیام پیش‌فرض `panic!` که `unwrap` استفاده می‌کند. خروجی به این شکل خواهد بود:

```bash
thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
```

در کدهای با کیفیت تولیدی، اکثر برنامه‌نویسان **Rust** (Rustaceans) ترجیح می‌دهند از `expect` به‌جای `unwrap` استفاده کنند و زمینه بیشتری درباره اینکه چرا انتظار می‌رود عملیات همیشه موفق شود، ارائه دهند. به این ترتیب، اگر فرضیات شما اشتباه از آب دربیاید، اطلاعات بیشتری برای دیباگ خواهید داشت.

## انتشار خطاها (Propagating Errors)

وقتی پیاده‌سازی یک تابع چیزی را فراخوانی می‌کند که ممکن است شکست بخورد، به‌جای مدیریت خطا در خود تابع، می‌توانید خطا را به کد فراخواننده برگردانید تا تصمیم بگیرد چه کاری انجام دهد. این روش به نام **انتشار خطا** شناخته می‌شود و کنترل بیشتری به کد فراخواننده می‌دهد، جایی که ممکن است اطلاعات یا منطق بیشتری وجود داشته باشد که نحوه مدیریت خطا را تعیین کند، نسبت به آنچه در زمینه کد شما در دسترس است.

برای مثال، **جدول 9-6** تابعی را نشان می‌دهد که نام کاربری را از یک فایل می‌خواند. اگر فایل وجود نداشته باشد یا قابل خواندن نباشد، این تابع آن خطاها را به کدی که تابع را فراخوانی کرده برمی‌گرداند.

**فایل: src/main.rs**

```rust
use std::fs::File;
use std::io::{self, Read};

// این تابع نام کاربری را از فایل می‌خواند!
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

**جدول 9-6**: تابعی که خطاها را با استفاده از `match` به کد فراخواننده برمی‌گرداند

این تابع را می‌توان به روش بسیار کوتاه‌تری نوشت، اما ما ابتدا آن را به‌صورت دستی و مفصل می‌نویسیم تا مدیریت خطاها را بررسی کنیم؛ در انتها، روش کوتاه‌تر را نشان خواهیم داد. ابتدا به نوع بازگشتی تابع نگاه کنیم: `Result<String, io::Error>`. این یعنی تابع مقداری از نوع `Result<T, E>` برمی‌گرداند که پارامتر Generic `T` با نوع مشخص `String` و نوع Generic `E` با نوع مشخص `io::Error` پر شده است.

اگر این تابع بدون هیچ مشکلی موفق شود، کدی که این تابع را فراخوانی می‌کند یک مقدار `Ok` دریافت خواهد کرد که حاوی یک `String` است—نام کاربری که این تابع از فایل خوانده است. اگر این تابع با مشکلی مواجه شود، کد فراخواننده یک مقدار `Err` دریافت خواهد کرد که حاوی یک نمونه از `io::Error` است که اطلاعات بیشتری درباره مشکلات رخ‌داده دارد. ما `io::Error` را به‌عنوان نوع بازگشتی این تابع انتخاب کردیم زیرا این نوع خطایی است که از هر دو عملیاتی که در بدنه این تابع فراخوانی می‌کنیم و ممکن است شکست بخورند، برگردانده می‌شود: تابع `File::open` و متد `read_to_string`.

بدنه تابع با فراخوانی تابع `File::open` شروع می‌شود. سپس مقدار `Result` را با یک `match` مشابه آنچه در **جدول 9-4** داشتیم مدیریت می‌کنیم. اگر `File::open` موفق شود، دسته فایل در متغیر الگو `file` به متغیر قابل تغییر `username_file` تبدیل می‌شود و تابع ادامه می‌یابد. در حالت `Err`، به‌جای فراخوانی `panic!`، از کلمه‌کلیدی `return` استفاده می‌کنیم تا زودتر از تابع خارج شویم و مقدار خطای `File::open` را که حالا در متغیر الگو `e` است، به‌عنوان مقدار خطای این تابع به کد فراخواننده برگردانیم.

بنابراین، اگر یک دسته فایل در `username_file` داشته باشیم، تابع سپس یک `String` جدید در متغیر `username` ایجاد می‌کند و متد `read_to_string` را روی دسته فایل در `username_file` فراخوانی می‌کند تا محتویات فایل را به `username` بخواند. متد `read_to_string` نیز یک `Result` برمی‌گرداند زیرا ممکن است شکست بخورد، حتی اگر `File::open` موفق شده باشد. بنابراین به یک `match` دیگر نیاز داریم تا آن `Result` را مدیریت کنیم: اگر `read_to_string` موفق شود، تابع ما موفق شده است و ما `username` را که حالا در آن است، در یک `Ok` بسته‌بندی کرده و برمی‌گردانیم. اگر `read_to_string` شکست بخورد، مقدار خطا را به همان روشی که مقدار خطای `match` مربوط به مقدار بازگشتی `File::open` را مدیریت کردیم، برمی‌گردانیم. با این حال، نیازی به گفتن صریح `return` نداریم، زیرا این آخرین عبارت در تابع است.

کدی که این کد را فراخوانی می‌کند سپس باید یا یک مقدار `Ok` که حاوی نام کاربری است یا یک مقدار `Err` که حاوی یک `io::Error` است را مدیریت کند. این به کد فراخواننده بستگی دارد که با این مقادیر چه کند. اگر کد فراخواننده یک مقدار `Err` دریافت کند، می‌تواند `panic!` را فراخوانی کند و برنامه را خراب کند، از یک نام کاربری پیش‌فرض استفاده کند یا نام کاربری را از جایی غیر از فایل جستجو کند، برای مثال. ما اطلاعات کافی درباره آنچه کد فراخواننده واقعاً سعی در انجام آن دارد نداریم، بنابراین تمام اطلاعات موفقیت یا خطا را به بالا منتشر می‌کنیم تا به‌طور مناسب مدیریت شود.

این الگوی انتشار خطاها در **Rust** آن‌قدر رایج است که **Rust** عملگر علامت سؤال `?` را برای ساده‌تر کردن این کار ارائه می‌دهد.

## میانبر برای انتشار خطاها: عملگر `?`

**جدول 9-7** پیاده‌سازی `read_username_from_file` را نشان می‌دهد که همان عملکرد **جدول 9-6** را دارد، اما این پیاده‌سازی از عملگر `?` استفاده می‌کند.

**فایل: src/main.rs**

```rust
use std::fs::File;
use std::io::{self, Read};

// این تابع نام کاربری را از فایل می‌خواند!
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

**جدول 9-7**: تابعی که خطاها را با استفاده از عملگر `?` به کد فراخواننده برمی‌گرداند

عملگر `?` که بعد از یک مقدار `Result` قرار می‌گیرد، تقریباً به همان روش عبارت‌های `match` که در **جدول 9-6** برای مدیریت مقادیر `Result` تعریف کردیم، کار می‌کند. اگر مقدار `Result` یک `Ok` باشد، مقدار داخل `Ok` از این عبارت برگردانده می‌شود و برنامه ادامه می‌یابد. اگر مقدار یک `Err` باشد، `Err` از کل تابع برگردانده می‌شود، گویی از کلمه‌کلیدی `return` استفاده کرده‌ایم، بنابراین مقدار خطا به کد فراخواننده منتشر می‌شود.

تفاوتی بین آنچه عبارت `match` در **جدول 9-6** انجام می‌دهد و آنچه عملگر `?` انجام می‌دهد وجود دارد: مقادیر خطایی که عملگر `?` روی آن‌ها فراخوانی می‌شود، از تابع `from` که در ترییت `From` در کتابخانه استاندارد تعریف شده، عبور می‌کنند و برای تبدیل مقادیر از یک نوع به نوع دیگر استفاده می‌شوند. وقتی عملگر `?` تابع `from` را فراخوانی می‌کند، نوع خطای دریافت‌شده به نوع خطایی تبدیل می‌شود که در نوع بازگشتی تابع فعلی تعریف شده است. این زمانی مفید است که یک تابع یک نوع خطا را برمی‌گرداند تا تمام روش‌هایی که تابع ممکن است شکست بخورد را نشان دهد، حتی اگر بخش‌هایی به دلایل مختلف شکست بخورند.

برای مثال، می‌توانیم تابع `read_username_from_file` در **جدول 9-7** را تغییر دهیم تا یک نوع خطای سفارشی به نام `OurError` که خودمان تعریف می‌کنیم، برگرداند. اگر همچنین `impl From<io::Error> for OurError` را تعریف کنیم تا یک نمونه از `OurError` را از یک `io::Error` بسازیم، тогда فراخوانی‌های عملگر `?` در بدنه `read_username_from_file` تابع `from` را فراخوانی می‌کنند و نوع‌های خطا را بدون نیاز به افزودن کد بیشتر به تابع تبدیل می‌کنند.

در زمینه **جدول 9-7**، عملگر `?` در انتهای فراخوانی `File::open` مقدار داخل یک `Ok` را به متغیر `username_file` برمی‌گرداند. اگر خطایی رخ دهد، عملگر `?` زودتر از کل تابع خارج می‌شود و هر مقدار `Err` را به کد فراخواننده می‌دهد. همین موضوع برای عملگر `?` در انتهای فراخوانی `read_to_string` اعمال می‌شود.

عملگر `?` کدهای تکراری زیادی را حذف می‌کند و پیاده‌سازی این تابع را ساده‌تر می‌کند. حتی می‌توانیم این کد را با زنجیره کردن فراخوانی‌های متد بلافاصله بعد از `?` کوتاه‌تر کنیم، همان‌طور که در **جدول 9-8** نشان داده شده است.

**فایل: src/main.rs**

```rust
use std::fs::File;
use std::io::{self, Read};

// این تابع نام کاربری را از فایل می‌خواند!
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

**جدول 9-8**: زنجیره کردن فراخوانی‌های متد بعد از عملگر `?`

ما ایجاد `String` جدید در `username` را به ابتدای تابع منتقل کرده‌ایم؛ این بخش تغییر نکرده است. به‌جای ایجاد یک متغیر `username_file`، فراخوانی `read_to_string` را مستقیماً روی نتیجه `File::open("hello.txt")؟` زنجیره کرده‌ایم. همچنان یک `?` در انتهای فراخوانی `read_to_string` داریم و همچنان وقتی هر دو `File::open` و `read_to_string` موفق شوند، مقدار `Ok` حاوی `username` را برمی‌گردانیم، به‌جای اینکه خطاها را برگردانیم. عملکرد دوباره همانند **جدول 9-6** و **جدول 9-7** است؛ این فقط یک روش متفاوت و ارگونومیک‌تر برای نوشتن آن است.

**جدول 9-9** روشی را نشان می‌دهد که این را حتی کوتاه‌تر با استفاده از `fs::read_to_string` می‌کند.

**فایل: src/main.rs**

```rust
use std::fs;
use std::io;

// این تابع نام کاربری را از فایل می‌خواند!
fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

**جدول 9-9**: استفاده از `fs::read_to_string` به‌جای باز کردن و سپس خواندن فایل

خواندن یک فایل به یک رشته یک عملیات نسبتاً رایج است، بنابراین کتابخانه استاندارد تابع راحت `fs::read_to_string` را ارائه می‌دهد که فایل را باز می‌کند، یک `String` جدید ایجاد می‌کند، محتویات فایل را می‌خواند، محتویات را در آن `String` قرار می‌دهد و آن را برمی‌گرداند. البته، استفاده از `fs::read_to_string` به ما فرصتی برای توضیح تمام مدیریت خطاها نمی‌دهد، بنابراین ابتدا روش طولانی‌تر را انجام دادیم.

## مکان‌هایی که عملگر `?` می‌تواند استفاده شود

عملگر `?` فقط در توابعی می‌تواند استفاده شود که نوع بازگشتی آن‌ها با مقداری که `?` روی آن استفاده شده، سازگار باشد. این به این دلیل است که عملگر `?` برای انجام بازگشت زودهنگام یک مقدار از تابع تعریف شده است، به همان روشی که عبارت `match` در **جدول 9-6** تعریف کردیم. در **جدول 9-6**، `match` از یک مقدار `Result` استفاده می‌کرد و شاخه بازگشت زودهنگام یک مقدار `Err(e)` را برمی‌گرداند. نوع بازگشتی تابع باید یک `Result` باشد تا با این بازگشت سازگار باشد.

در **جدول 9-10**، بیایید خطایی را که دریافت می‌کنیم اگر عملگر `?` را در یک تابع `main` با نوع بازگشتی که با نوع مقداری که `?` روی آن استفاده می‌کنیم ناسازگار است، بررسی کنیم.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
```

**جدول 9-10**: تلاش برای استفاده از `?` در تابع `main` که `()` برمی‌گرداند، کامپایل نمی‌شود.

این کد یک فایل را باز می‌کند که ممکن است شکست بخورد. عملگر `?` مقدار `Result` برگردانده‌شده توسط `File::open` را دنبال می‌کند، اما این تابع `main` نوع بازگشتی `()` دارد، نه `Result`. وقتی این کد را کامپایل کنیم، پیام خطای زیر را دریافت می‌کنیم:

```bash
$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -> Result<(), Box<dyn std::error::Error>> {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
```

این خطا اشاره می‌کند که ما فقط اجازه داریم از عملگر `?` در تابعی استفاده کنیم که `Result`، `Option` یا نوع دیگری که ترییت `FromResidual` را پیاده‌سازی کرده، برمی‌گرداند.

برای رفع این خطا، دو انتخاب دارید. یک انتخاب این است که نوع بازگشتی تابع خود را به نوع سازگار با مقداری که عملگر `?` روی آن استفاده می‌کنید تغییر دهید، به شرطی که هیچ محدودیتی مانع این کار نشود. انتخاب دیگر این است که از یک `match` یا یکی از متدهای `Result<T, E>` برای مدیریت `Result<T, E>` به روشی مناسب استفاده کنید.

پیام خطا همچنین اشاره کرد که `?` می‌تواند با مقادیر `Option<T>` نیز استفاده شود. مانند استفاده از `?` روی `Result`، شما فقط می‌توانید از `?` روی `Option` در تابعی استفاده کنید که یک `Option` برمی‌گرداند. رفتار عملگر `?` وقتی روی یک `Option<T>` فراخوانی می‌شود مشابه رفتار آن وقتی روی یک `Result<T, E>` فراخوانی می‌شود است: اگر مقدار `None` باشد، `None` در آن نقطه زودتر از تابع برگردانده می‌شود. اگر مقدار `Some` باشد، مقدار داخل `Some` مقدار نتیجه این عبارت است و تابع ادامه می‌یابد. **جدول 9-11** مثالی از تابعی را نشان می‌دهد که آخرین کاراکتر خط اول در متن داده‌شده را پیدا می‌کند.

```rust
// این تابع آخرین کاراکتر خط اول متن را پیدا می‌کند!
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

**جدول 9-11**: استفاده از عملگر `?` روی یک مقدار `Option<T>`

این تابع `Option<char>` برمی‌گرداند زیرا ممکن است کاراکتری وجود داشته باشد، اما ممکن است وجود نداشته باشد. این کد یک برش رشته‌ای (string slice) به‌عنوان آرگومان می‌گیرد و متد `lines` را روی آن فراخوانی می‌کند که یک تکرارگر (iterator) روی خطوط رشته برمی‌گرداند. چون این تابع می‌خواهد خط اول را بررسی کند، `next` را روی تکرارگر فراخوانی می‌کند تا اولین مقدار را از تکرارگر بگیرد. اگر `text` یک رشته خالی باشد، این فراخوانی به `next` مقدار `None` را برمی‌گرداند، در این صورت ما از `?` برای توقف و برگرداندن `None` از `last_char_of_first_line` استفاده می‌کنیم. اگر `text` رشته خالی نباشد، `next` یک مقدار `Some` را برمی‌گرداند که حاوی یک برش رشته‌ای از خط اول در `text` است.

عملگر `?` برش رشته‌ای را استخراج می‌کند و ما می‌توانیم `chars` را روی آن برش رشته‌ای فراخوانی کنیم تا یک تکرارگر از کاراکترهایش بگیریم. ما به آخرین کاراکتر در این خط اول علاقه‌مندیم، بنابراین `last` را فراخوانی می‌کنیم تا آخرین مورد در تکرارگر را برگردانیم. این یک `Option` است زیرا ممکن است خط اول یک رشته خالی باشد؛ برای مثال، اگر `text` با یک خط خالی شروع شود اما در خطوط دیگر کاراکترهایی داشته باشد، مانند `"\nhi"`. با این حال، اگر آخرین کاراکتری در خط اول وجود داشته باشد، در واریانت `Some` برگردانده خواهد شد. عملگر `?` در وسط به ما راهی مختصر برای بیان این منطق می‌دهد و به ما امکان می‌دهد این تابع را در یک خط پیاده‌سازی کنیم. اگر نمی‌توانستیم از عملگر `?` روی `Option` استفاده کنیم، باید این منطق را با فراخوانی‌های متد بیشتر یا یک عبارت `match` پیاده‌سازی می‌کردیم.

> **توجه**: شما می‌توانید عملگر `?` را روی یک `Result` در تابعی که `Result` برمی‌گرداند و روی یک `Option` در تابعی که `Option` برمی‌گرداند استفاده کنید، اما نمی‌توانید این دو را با هم مخلوط کنید. عملگر `?` به‌طور خودکار یک `Result` را به `Option` یا برعکس تبدیل نمی‌کند؛ در این موارد، می‌توانید از متدهایی مانند متد `ok` روی `Result` یا متد `ok_or` روی `Option` برای انجام تبدیل به‌صورت صریح استفاده کنید.

تا کنون، تمام توابع `main` که استفاده کرده‌ایم `()` برمی‌گردانند. تابع `main` خاص است زیرا نقطه ورود و خروج یک برنامه قابل اجرا است و محدودیت‌هایی در نوع بازگشتی آن وجود دارد تا برنامه به‌صورت مورد انتظار رفتار کند.

خوشبختانه، `main` همچنین می‌تواند یک `Result<(), E>` برگرداند. **جدول 9-12** کد **جدول 9-10** را دارد، اما ما نوع بازگشتی `main` را به `Result<(), Box<dyn Error>>` تغییر داده‌ایم و یک مقدار بازگشتی `Ok(())` به انتها اضافه کرده‌ایم. این کد حالا کامپایل خواهد شد.

**فایل: src/main.rs**

```rust
use std::error::Error;
use std::fs::File;

// این تابع یک فایل را باز می‌کند!
fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
```

**جدول 9-12**: تغییر `main` برای برگرداندن `Result<(), E>` امکان استفاده از عملگر `?` روی مقادیر `Result` را می‌دهد.

نوع `Box<dyn Error>` یک شیء ترییت (trait object) است که در فصل هجدهم در بخش «استفاده از اشیاء ترییت که امکان استفاده از مقادیر انواع مختلف را می‌دهند» درباره آن صحبت خواهیم کرد. برای حالا، می‌توانید `Box<dyn Error>` را به معنای «هر نوع خطایی» بخوانید. استفاده از `?` روی یک مقدار `Result` در یک تابع `main` با نوع خطای `Box<dyn Error>` مجاز است زیرا امکان بازگشت زودهنگام هر مقدار `Err` را فراهم می‌کند. اگرچه بدنه این تابع `main` فقط خطاهایی از نوع `std::io::Error` را برمی‌گرداند، با مشخص کردن `Box<dyn Error>`، این امضا حتی اگر کد بیشتری که خطاهای دیگر را برمی‌گرداند به بدنه `main` اضافه شود، همچنان درست باقی خواهد ماند.

وقتی یک تابع `main` یک `Result<(), E>` برمی‌گرداند، برنامه قابل اجرا اگر `main` مقدار `Ok(())` را برگرداند با مقدار 0 خارج می‌شود و اگر `main` یک مقدار `Err` را برگرداند با یک مقدار غیرصفر خارج خواهد شد. برنامه‌های قابل اجرا نوشته‌شده در **C** هنگام خروج اعداد صحیح را برمی‌گردانند: برنامه‌هایی که با موفقیت خارج می‌شوند عدد صحیح 0 را برمی‌گردانند و برنامه‌هایی که خطا دارند عدد صحیحی غیر از 0 را برمی‌گردانند. **Rust** همچنین اعداد صحیح را از برنامه‌های قابل اجرا برمی‌گرداند تا با این قرارداد سازگار باشد.

تابع `main` می‌تواند هر نوعی را که ترییت `std::process::Termination` را پیاده‌سازی کرده باشد، برگرداند، که شامل یک تابع `report` است که یک `ExitCode` برمی‌گرداند. برای اطلاعات بیشتر درباره پیاده‌سازی ترییت `Termination` برای انواع خودتان، به مستندات کتابخانه استاندارد مراجعه کنید.

اکنون که جزئیات فراخوانی `panic!` یا برگرداندن `Result` را بحث کردیم، بیایید به موضوع این که کدام‌یک در چه مواردی مناسب است، برگردیم.
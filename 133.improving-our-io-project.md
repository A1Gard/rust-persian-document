# بهبود پروژه ورودی/خروجی ما

با دانش جدیدمان درباره تکرارسازها، می‌توانیم پروژه ورودی/خروجی در فصل دوازدهم را با استفاده از تکرارسازها بهبود دهیم تا بخش‌هایی از کد واضح‌تر و مختصرتر شوند. بیایید ببینیم چگونه تکرارسازها می‌توانند پیاده‌سازی تابع `Config::build` و تابع `search` را بهبود دهند.

## حذف یک `clone` با استفاده از تکرارساز

در **جدول 12-6**، کدی اضافه کردیم که یک برش از مقادیر `String` را گرفت و یک نمونه از ساختار `Config` را با شاخص‌گذاری در برش و کپی کردن مقادیر ایجاد کرد، که به ساختار `Config` اجازه می‌داد مالک آن مقادیر باشد. در **جدول 13-17**، پیاده‌سازی تابع `Config::build` را همان‌طور که در **جدول 12-23** بود بازتولید کرده‌ایم.

**فایل: src/lib.rs**

```rust
use std::env;

pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}

impl Config {
    pub fn build(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

**جدول 13-17**: بازتولید تابع `Config::build` از **جدول 12-23**

در آن زمان، گفتیم نگران فراخوانی‌های غیرکارآمد `clone` نباشید چون در آینده آن‌ها را حذف خواهیم کرد. حالا آن زمان فرا رسیده است!

ما اینجا به `clone` نیاز داشتیم چون یک برش با عناصر `String` در پارامتر `args` داریم، اما تابع `build` مالک `args` نیست. برای بازگرداندن مالکیت یک نمونه `Config`، باید مقادیر را از فیلدهای `query` و `file_path` ساختار `Config` کپی می‌کردیم تا نمونه `Config` بتواند مالک مقادیر خود باشد.

با دانش جدیدمان درباره تکرارسازها، می‌توانیم تابع `build` را تغییر دهیم تا به جای قرض گرفتن یک برش، مالکیت یک تکرارساز را به‌عنوان آرگومان خود بگیرد. ما از قابلیت‌های تکرارساز به جای کدی که طول برش را بررسی می‌کند و به مکان‌های خاصی شاخص‌گذاری می‌کند استفاده خواهیم کرد. این کار روشن‌تر خواهد کرد که تابع `Config::build` چه کاری انجام می‌دهد زیرا تکرارساز به مقادیر دسترسی خواهد داشت.

هنگامی که `Config::build` مالکیت تکرارساز را بگیرد و دیگر از عملیات شاخص‌گذاری که قرض می‌گیرند استفاده نکند، می‌توانیم مقادیر `String` را از تکرارساز به `Config` منتقل کنیم به جای اینکه `clone` را فراخوانی کنیم و تخصیص جدیدی انجام دهیم.

## استفاده مستقیم از تکرارساز برگردانده‌شده

فایل `src/main.rs` پروژه ورودی/خروجی خود را باز کنید، که باید شبیه این باشد:

**فایل: src/main.rs**

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

ابتدا ابتدای تابع `main` را که در **جدول 12-24** داشتیم به کد در **جدول 13-18** تغییر خواهیم داد، که این بار از یک تکرارساز استفاده می‌کند. این کد تا زمانی که `Config::build` را نیز به‌روزرسانی نکنیم کامپایل نخواهد شد.

**فایل: src/main.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
}
```

**جدول 13-18**: پاس دادن مقدار بازگشتی `env::args` به `Config::build`

تابع `env::args` یک تکرارساز برمی‌گرداند! به جای جمع‌آوری مقادیر تکرارساز در یک بردار و سپس پاس دادن یک برش به `Config::build`، حالا مالکیت تکرارسازی که از `env::args` برگردانده شده را مستقیماً به `Config::build` پاس می‌دهیم.

بعد، باید تعریف `Config::build` را به‌روزرسانی کنیم. در فایل `src/lib.rs` پروژه ورودی/خروجی خود، امضای `Config::build` را به شکل **جدول 13-19** تغییر دهیم. این هنوز کامپایل نخواهد شد چون باید بدنه تابع را به‌روزرسانی کنیم.

**فایل: src/lib.rs**

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
impl Config {
    pub fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        // --snip--
```

**جدول 13-19**: به‌روزرسانی امضای `Config::build` برای انتظار یک تکرارساز

مستندات کتابخانه استاندارد برای تابع `env::args` نشان می‌دهد که نوع تکرارسازی که برمی‌گرداند `std::env::Args` است، و این نوع ویژگی‌ `Iterator` را پیاده‌سازی می‌کند و مقادیر `String` را برمی‌گرداند.

ما امضای تابع `Config::build` را به‌روزرسانی کرده‌ایم تا پارامتر `args` یک نوع عمومی با محدودیت‌های ویژگی‌ `impl Iterator<Item = String>` به جای `&[String]` داشته باشد. این استفاده از نحو `impl Trait` که در بخش "صفات به‌عنوان پارامترها" در فصل دهم بحث کردیم، به این معنی است که `args` می‌تواند هر نوع‌ای باشد که ویژگی‌ `Iterator` را پیاده‌سازی می‌کند و آیتم‌های `String` را برمی‌گرداند.

چون مالکیت `args` را می‌گیریم و با پیمایش روی آن، `args` را تغییر خواهیم داد، می‌توانیم کلمه کلیدی `mut` را به مشخصات پارامتر `args` اضافه کنیم تا آن را قابل تغییر کنیم.

## استفاده از متدهای ویژگی‌ Iterator به جای شاخص‌گذاری

بعد، بدنه `Config::build` را اصلاح خواهیم کرد. چون `args` ویژگی‌ `Iterator` را پیاده‌سازی می‌کند، می‌دانیم که می‌توانیم متد `next` را روی آن فراخوانی کنیم! **جدول 13-20** کد را از **جدول 12-23** به‌روزرسانی می‌کند تا از متد `next` استفاده کند.

**فایل: src/lib.rs**

```rust
use std::env;

pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}

impl Config {
    pub fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
        args.next(); // نام برنامه را نادیده می‌گیریم

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
```

**جدول 13-20**: تغییر بدنه `Config::build` برای استفاده از متدهای تکرارساز

به یاد بیاورید که اولین مقدار در مقدار بازگشتی `env::args` نام برنامه است. ما می‌خواهیم آن را نادیده بگیریم و به مقدار بعدی برسیم، بنابراین ابتدا `next` را فراخوانی می‌کنیم و با مقدار بازگشتی کاری انجام نمی‌دهیم. سپس `next` را فراخوانی می‌کنیم تا مقداری که می‌خواهیم در فیلد `query` از `Config` قرار دهیم را بگیریم. اگر `next` یک `Some` برگرداند، از یک `match` برای استخراج مقدار استفاده می‌کنیم. اگر `None` برگرداند، به این معنی است که آرگومان‌های کافی ارائه نشده‌اند و ما زودتر با یک مقدار `Err` برمی‌گردیم. همین کار را برای مقدار `file_path` انجام می‌دهیم.

این پیاده‌سازی دیگر نیازی به فراخوانی‌های `clone` ندارد، زیرا ما مستقیماً مالکیت مقادیر `String` را از تکرارساز می‌گیریم و آن‌ها را به `Config` منتقل می‌کنیم، که باعث می‌شود کد کارآمدتر و واضح‌تر شود.

## ساده‌تر کردن کد با آداپتورهای تکرارساز

ما همچنین می‌توانیم از تکرارسازها در تابع `search` در پروژه ورودی/خروجی خود بهره ببریم، که در اینجا در **جدول 13-21** همان‌طور که در **جدول 12-19** بود بازتولید شده است:

**فایل: src/lib.rs**

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

**جدول 13-21**: پیاده‌سازی تابع `search` از **جدول 12-19**

ما می‌توانیم این کد را با استفاده از متدهای آداپتور تکرارساز به روشی مختصرتر بنویسیم. این کار همچنین به ما امکان می‌دهد از داشتن یک بردار موقت قابل تغییر `results` اجتناب کنیم. سبک برنامه‌نویسی تابعی ترجیح می‌دهد مقدار حالت قابل تغییر را به حداقل برساند تا کد واضح‌تر شود. حذف حالت قابل تغییر ممکن است بهبود آینده‌ای را برای انجام جستجو به‌صورت موازی فراهم کند، زیرا نیازی به مدیریت دسترسی هم‌زمان به بردار `results` نخواهیم داشت. **جدول 13-22** این تغییر را نشان می‌دهد:

**فایل: src/lib.rs**

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
```

**جدول 13-22**: استفاده از متدهای آداپتور تکرارساز در پیاده‌سازی تابع `search`

به یاد بیاورید که هدف تابع `search` بازگرداندن تمام خطوط در `contents` است که شامل `query` هستند. مشابه مثال `filter` در **جدول 13-16**، این کد از آداپتور `filter` استفاده می‌کند تا فقط خطوطی را نگه دارد که `line.contains(query)` برای آن‌ها `true` برمی‌گرداند. سپس خطوط مطابق را با `collect` در یک بردار دیگر جمع‌آوری می‌کنیم. بسیار ساده‌تر! می‌توانید همین تغییر را برای استفاده از متدهای تکرارساز در تابع `search_case_insensitive` نیز انجام دهید.

به عنوان مثال، بیایید تابع `search_case_insensitive` را که در **جدول 12-21** بود به‌روزرسانی کنیم:

**فایل: src/lib.rs**

```rust
pub fn search_case_insensitive<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let query = query.to_lowercase();
    contents
        .lines()
        .filter(|line| line.to_lowercase().contains(&query))
        .collect()
}
```

اینجا، ما همان رویکرد را اعمال کرده‌ایم: به جای حلقه `for` و یک بردار موقت، از `lines` برای دریافت یک تکرارساز استفاده می‌کنیم، `filter` را برای نگه داشتن خطوطی که شامل `query` به‌صورت بدون حساسیت به حروف هستند به کار می‌بریم، و سپس با `collect` نتایج را در یک بردار جمع‌آوری می‌کنیم.

## انتخاب بین حلقه‌ها یا تکرارسازها

سؤال منطقی بعدی این است که در کد خود کدام سبک را باید انتخاب کنید و چرا: پیاده‌سازی اصلی در **جدول 13-21** یا نسخه با استفاده از تکرارسازها در **جدول 13-22**. اکثر برنامه‌نویسان **Rust** ترجیح می‌دهند از سبک تکرارساز استفاده کنند. در ابتدا ممکن است کمی سخت باشد، اما هنگامی که با آداپتورهای مختلف تکرارساز و کارکرد آن‌ها آشنا شوید، درک تکرارسازها می‌تواند آسان‌تر باشد. به جای دستکاری با بخش‌های مختلف حلقه‌ها و ساخت بردارهای جدید، کد روی هدف سطح بالای حلقه تمرکز می‌کند. این کار برخی از کدهای رایج را انتزاعی می‌کند تا مفاهیمی که برای این کد خاص هستند، مانند شرط فیلتری که هر عنصر در تکرارساز باید آن را پاس کند، آسان‌تر دیده شوند.

اما آیا این دو پیاده‌سازی واقعاً معادل هستند؟ فرض بصری ممکن است این باشد که حلقه سطح پایین‌تر سریع‌تر خواهد بود. بیایید درباره عملکرد صحبت کنیم.

## بحث درباره عملکرد

برای بررسی عملکرد، باید در نظر بگیریم که تکرارسازها در **Rust** به کد ماشین بسیار بهینه‌ای کامپایل می‌شوند، به لطف بهینه‌سازی‌های کامپایلر مانند **inline کردن** و **حذف حلقه (loop unrolling)**. نسخه تکرارساز در **جدول 13-22** معمولاً به همان دستورات اسمبلی یا مشابه نسخه حلقه در **جدول 13-21** کامپایل می‌شود، به این معنی که معمولاً هیچ جریمه عملکردی برای استفاده از تکرارسازها وجود ندارد.

علاوه بر این، نسخه تکرارساز مزایایی را ارائه می‌دهد:
- **خوانایی**: کد مختصرتر است و منطق سطح بالا را به‌وضوح بیان می‌کند، که نگهداری و درک آن را آسان‌تر می‌کند.
- **ایمنی**: با حذف حالت قابل تغییر (مانند بردار موقت `results`)، احتمال خطاها مانند دسترسی‌های ناامن یا شرایط رقابتی در کدهای موازی کاهش می‌یابد.
- **انعطاف‌پذیری**: آداپتورهای تکرارساز امکان ترکیب آسان عملیات پیچیده را فراهم می‌کنند، مانند زنجیره کردن چندین تبدیل یا فیلتر، بدون نیاز به حلقه‌های تو در تو.

با این حال، مواردی وجود دارد که حلقه‌های صریح ممکن است ترجیح داده شوند:
- وقتی منطق پیمایش پیچیده است و به‌طور مستقیم در الگوهای آداپتورهای تکرارساز قرار نمی‌گیرد.
- وقتی به کنترل دقیق‌تر روی جریان پیمایش نیاز دارید، مانند مدیریت شاخص‌ها به‌صورت دستی یا پرش از آیتم‌ها به روش‌های غیراستاندارد.

در مورد پروژه `minigrep` ما، نسخه تکرارساز (**جدول 13-22**) به دلیل سادگی و وضوح آن انتخاب بهتری است. این نسخه همان عملکرد نسخه حلقه را حفظ می‌کند در حالی که کد را قابل خواندن‌تر و کمتر مستعد خطا می‌کند.

به عنوان یک تمرین، می‌توانید عملکرد این دو پیاده‌سازی را با استفاده از یک ابزار بنچمارک مانند `criterion` مقایسه کنید تا تأیید کنید که تفاوت عملکرد ناچیز است. این کار شامل افزودن یک بنچمارک به پروژه شما می‌شود، که می‌توانید در مستندات **Rust** درباره بنچمارکینگ اطلاعات بیشتری درباره آن پیدا کنید.

در پایان، انتخاب بین حلقه‌ها و تکرارسازها اغلب به خوانایی و نیازهای خاص پروژه شما بستگی دارد، اما در بسیاری از موارد، سبک تکرارساز به دلیل ترکیب بهینه‌سازی عملکرد و وضوح کد، رویکرد ارجح در **Rust** است.
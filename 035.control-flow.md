## جریان کنترل

قابلیت اجرای برخی کدها بر اساس اینکه آیا شرطی درست است یا اجرای مکرر برخی کدها در حالی که شرطی درست است، بلوک‌های سازنده اساسی در اکثر زبان‌های برنامه‌نویسی هستند. رایج‌ترین ساختارهایی که به شما امکان کنترل جریان اجرای کد Rust را می‌دهند، عبارات `if` و حلقه‌ها هستند.

### عبارات `if`

عبارت `if` به شما امکان می‌دهد کد خود را بر اساس شرایط شاخه‌بندی کنید. شما یک شرط ارائه می‌دهید و سپس بیان می‌کنید: «اگر این شرط برقرار باشد، این بلوک کد را اجرا کن. اگر شرط برقرار نباشد، این بلوک کد را اجرا نکن.»

یک پروژه جدید به نام `branches` در پوشه پروژه‌های خود ایجاد کنید تا عبارت `if` را بررسی کنیم. در فایل `src/main.rs`، کد زیر را وارد کنید:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("شرط درست بود");
    } else {
        println!("شرط نادرست بود");
    }
}
```

همه عبارات `if` با کلیدواژه `if` شروع می‌شوند، که به دنبال آن یک شرط می‌آید. در این مورد، شرط بررسی می‌کند که آیا متغیر `number` مقداری کمتر از ۵ دارد یا خیر. بلوک کدی که باید در صورت درست بودن شرط اجرا شود، بلافاصله پس از شرط در داخل کروشه‌ها قرار می‌گیرد. بلوک‌های کد مرتبط با شرایط در عبارات `if` گاهی اوقات بازو (arm) نامیده می‌شوند، مشابه بازوها در عبارات `match` که در بخش «مقایسه حدس با عدد مخفی» در فصل دوم بحث کردیم.

به‌صورت اختیاری، می‌توانیم یک عبارت `else` نیز اضافه کنیم، که در اینجا انتخاب کردیم، تا به برنامه یک بلوک کد جایگزین برای اجرا در صورتی که شرط به `false` ارزیابی شود، بدهیم. اگر عبارت `else` ارائه ندهید و شرط `false` باشد، برنامه صرفاً بلوک `if` را نادیده می‌گیرد و به بخش بعدی کد می‌رود.

این کد را اجرا کنید؛ باید خروجی زیر را ببینید:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
شرط درست بود
```

بیایید مقدار `number` را به مقداری تغییر دهیم که شرط را `false` کند تا ببینیم چه اتفاقی می‌افتد:

```rust
    let number = 7;
```

برنامه را دوباره اجرا کنید و خروجی را ببینید:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
شرط نادرست بود
```

همچنین值得注意的是 که شرط در این کد باید یک `bool` باشد. اگر شرط یک `bool` نباشد، خطا دریافت خواهیم کرد. برای مثال، کد زیر را اجرا کنید:

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let number = 3;

    if number {
        println!("عدد سه بود");
    }
}
```

شرط `if` این بار به مقدار `3` ارزیابی می‌شود و Rust خطایی تولید می‌کند:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

خطا نشان می‌دهد که Rust یک `bool` انتظار داشت اما یک عدد صحیح دریافت کرد. برخلاف زبان‌هایی مانند Ruby و JavaScript، Rust به‌صورت خودکار نوع‌های غیربولین را به بولین تبدیل نمی‌کند. شما باید صراحتاً همیشه یک مقدار بولین به‌عنوان شرط به `if` بدهید. برای مثال، اگر بخواهیم بلوک کد `if` فقط وقتی عددی غیر از صفر است اجرا شود، می‌توانیم عبارت `if` را به این صورت تغییر دهیم:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("عدد چیزی غیر از صفر بود");
    }
}
```

اجرای این کد چاپ خواهد کرد: `عدد چیزی غیر از صفر بود`.

#### مدیریت چندین شرط با `else if`

می‌توانید با ترکیب `if` و `else` در یک عبارت `else if` از چندین شرط استفاده کنید. برای مثال:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("عدد بر ۴ قابل‌تقسیم است");
    } else if number % 3 == 0 {
        println!("عدد بر ۳ قابل‌تقسیم است");
    } else if number % 2 == 0 {
        println!("عدد بر ۲ قابل‌تقسیم است");
    } else {
        println!("عدد بر ۴، ۳ یا ۲ قابل‌تقسیم نیست");
    }
}
```

این برنامه چهار مسیر ممکن برای اجرا دارد. پس از اجرای آن، باید خروجی زیر را ببینید:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
عدد بر ۳ قابل‌تقسیم است
```

وقتی این برنامه اجرا می‌شود، هر عبارت `if` را به نوبت بررسی می‌کند و اولین بدنه‌ای را که شرط آن به `true` ارزیابی می‌شود، اجرا می‌کند. توجه کنید که گرچه ۶ بر ۲ قابل‌تقسیم است، خروجی `عدد بر ۲ قابل‌تقسیم است` را نمی‌بینیم، و همچنین متن `عدد بر ۴، ۳ یا ۲ قابل‌تقسیم نیست` از بلوک `else` را نمی‌بینیم. این به این دلیل است که Rust فقط بلوک مربوط به اولین شرط درست را اجرا می‌کند و پس از یافتن یکی، بقیه را حتی بررسی نمی‌کند.

استفاده از تعداد زیادی عبارات `else if` می‌تواند کد شما را شلوغ کند، بنابراین اگر بیش از یکی دارید، ممکن است بخواهید کد خود را بازسازی کنید. فصل ششم یک ساختار شاخه‌بندی قدرتمند Rust به نام `match` را برای این موارد توضیح می‌دهد.

#### استفاده از `if` در یک دستور `let`

چون `if` یک عبارت است، می‌توانیم از آن در سمت راست یک دستور `let` برای تخصیص نتیجه به یک متغیر استفاده کنیم، همان‌طور که در لیست ۳-۲ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("مقدار number برابر است با: {number}");
}
```

**لیست ۳-۲:** تخصیص نتیجه یک عبارت `if` به یک متغیر

متغیر `number` به مقداری بر اساس نتیجه عبارت `if` متصل خواهد شد. این کد را اجرا کنید تا ببینید چه اتفاقی می‌افتد:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
مقدار number برابر است با: 5
```

به یاد داشته باشید که بلوک‌های کد به آخرین عبارت در آن‌ها ارزیابی می‌شوند، و اعداد به‌خودی‌خود نیز عبارات هستند. در این مورد، مقدار کل عبارت `if` به این بستگی دارد که کدام بلوک کد اجرا شود. این یعنی مقادیری که پتانسیل نتیجه شدن از هر بازوی `if` را دارند باید از یک نوع باشند؛ در لیست ۳-۲، نتایج هر دو بازوی `if` و `else` اعداد صحیح `i32` بودند. اگر نوع‌ها ناسازگار باشند، همان‌طور که در مثال زیر نشان داده شده، خطا دریافت خواهیم کرد:

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "شش" };

    println!("مقدار number برابر است با: {number}");
}
```

وقتی سعی می‌کنیم این کد را کامپایل کنیم، خطا دریافت خواهیم کرد. بازوهای `if` و `else` نوع‌های مقداری ناسازگار دارند، و Rust دقیقاً نشان می‌دهد که مشکل در کجای برنامه است:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "شش" };
  |                                 -          ^^^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
```

عبارت در بلوک `if` به یک عدد صحیح ارزیابی می‌شود، و عبارت در بلوک `else` به یک رشته ارزیابی می‌شود. این کار نمی‌کند زیرا متغیرها باید یک نوع واحد داشته باشند، و Rust باید در زمان کامپایل دقیقاً بداند که نوع متغیر `number` چیست. دانستن نوع `number` به کامپایلر اجازه می‌دهد بررسی کند که نوع در همه جا که از `number` استفاده می‌کنیم معتبر است. اگر نوع `number` فقط در زمان اجرا تعیین می‌شد، Rust نمی‌توانست این کار را انجام دهد؛ کامپایلر پیچیده‌تر می‌شد و تضمین‌های کمتری درباره کد ارائه می‌داد اگر مجبور بود چندین نوع فرضی برای هر متغیر را ردیابی کند.

### تکرار با حلقه‌ها

اغلب اجرای یک بلوک کد بیش از یک بار مفید است. برای این کار، Rust چندین حلقه ارائه می‌دهد که کد داخل بدنه حلقه را تا انتها اجرا می‌کنند و سپس بلافاصله به ابتدا برمی‌گردند. برای آزمایش با حلقه‌ها، بیایید یک پروژه جدید به نام `loops` بسازیم.

Rust سه نوع حلقه دارد: `loop`، `while`، و `for`. بیایید هر یک را امتحان کنیم.

#### تکرار کد با `loop`

کلیدواژه `loop` به Rust می‌گوید که یک بلوک کد را بارها و بارها برای همیشه یا تا زمانی که صراحتاً به آن بگویید متوقف شود، اجرا کند.

به‌عنوان مثال، فایل `src/main.rs` را در پوشه `loops` خود به این صورت تغییر دهید:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    loop {
        println!("دوباره!");
    }
}
```

وقتی این برنامه را اجرا کنیم، `دوباره!` را بارها و بارها به‌صورت مداوم چاپ خواهد کرد تا زمانی که برنامه را به‌صورت دستی متوقف کنیم. اکثر ترمینال‌ها از میانبر صفحه‌کلید `ctrl-c` برای قطع برنامه‌ای که در یک حلقه مداوم گیر کرده است پشتیبانی می‌کنند. آن را امتحان کنید:

```bash
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
دوباره!
دوباره!
دوباره!
دوباره!
^Cدوباره!
```

نماد `^C` نشان‌دهنده جایی است که شما `ctrl-c` را فشار داده‌اید. ممکن است کلمه `دوباره!` را بعد از `^C` ببینید یا نه، بسته به اینکه کد در کجای حلقه بود وقتی سیگنال قطع را دریافت کرد.

خوشبختانه، Rust همچنین راهی برای خروج از یک حلقه با استفاده از کد فراهم می‌کند. می‌توانید کلیدواژه `break` را در داخل حلقه قرار دهید تا به برنامه بگویید چه زمانی اجرای حلقه را متوقف کند. به یاد بیاورید که این کار را در بازی حدس در بخش «خروج پس از حدس درست» در فصل دوم انجام دادیم تا وقتی کاربر با حدس درست بازی را برد، برنامه را خارج کنیم.

ما همچنین از `continue` در بازی حدس استفاده کردیم، که در یک حلقه به برنامه می‌گوید هر کد باقی‌مانده در این تکرار حلقه را نادیده بگیرد و به تکرار بعدی برود.

#### بازگشت مقادیر از حلقه‌ها

یکی از کاربردهای حلقه، تلاش مجدد برای عملیاتی است که می‌دانید ممکن است شکست بخورد، مانند بررسی اینکه آیا یک نخ کار خود را کامل کرده است. ممکن است همچنین نیاز داشته باشید نتیجه آن عملیات را از حلقه به بقیه کد خود منتقل کنید. برای این کار، می‌توانید مقداری که می‌خواهید برگردانده شود را پس از عبارت `break` که برای متوقف کردن حلقه استفاده می‌کنید، اضافه کنید؛ آن مقدار از حلقه برگردانده می‌شود تا بتوانید از آن استفاده کنید، همان‌طور که اینجا نشان داده شده است:

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("نتیجه برابر است با {result}");
}
```

قبل از حلقه، یک متغیر به نام `counter` اعلان می‌کنیم و آن را به `0` مقداردهی می‌کنیم. سپس یک متغیر به نام `result` اعلان می‌کنیم تا مقدار برگشتی از حلقه را نگه دارد. در هر تکرار حلقه، به متغیر `counter` یک واحد اضافه می‌کنیم و سپس بررسی می‌کنیم که آیا `counter` برابر با `10` است. وقتی این‌طور باشد، از کلیدواژه `break` با مقدار `counter * 2` استفاده می‌کنیم. پس از حلقه، از یک سمی‌کالن برای پایان دادن به دستوری که مقدار را به `result` تخصیص می‌دهد، استفاده می‌کنیم. در نهایت، مقدار موجود در `result` را چاپ می‌کنیم، که در این مورد `20` است.

همچنین می‌توانید از داخل یک حلقه بازگشت کنید. در حالی که `break` فقط حلقه فعلی را خارج می‌کند، `return` همیشه تابع فعلی را خارج می‌کند.

#### برچسب‌های حلقه برای تمایز بین چندین حلقه

اگر حلقه‌هایی درون حلقه‌ها دارید، `break` و `continue` به نزدیک‌ترین حلقه در آن نقطه اعمال می‌شوند. می‌توانید به‌صورت اختیاری یک برچسب حلقه روی یک حلقه مشخص کنید که سپس می‌توانید با `break` یا `continue` استفاده کنید تا مشخص کنید که این کلیدواژه‌ها به حلقه برچسب‌دار به‌جای نزدیک‌ترین حلقه اعمال شوند. برچسب‌های حلقه باید با یک نقل‌قول تکی شروع شوند. در اینجا یک مثال با دو حلقه تو در تو آورده شده است:

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("پایان شمارش = {count}");
}
```

حلقه خارجی برچسب `'counting_up` دارد و از `0` تا `2` می‌شمارد. حلقه داخلی بدون برچسب از `10` تا `9` می‌شمارد. اولین `break` که برچسبی مشخص نمی‌کند، فقط حلقه داخلی را خارج می‌کند. عبارت `break 'counting_up;` حلقه خارجی را خارج می‌کند. این کد چاپ می‌کند:

```bash
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
پایان شمارش = 2
```

#### حلقه‌های شرطی با `while`

یک برنامه اغلب نیاز دارد که یک شرط را در داخل یک حلقه ارزیابی کند. در حالی که شرط درست است، حلقه اجرا می‌شود. وقتی شرط دیگر درست نباشد، برنامه `break` را فراخوانی می‌کند و حلقه را متوقف می‌کند. می‌توان این رفتار را با ترکیب `loop`، `if`، `else`، و `break` پیاده‌سازی کرد؛ اگر بخواهید، می‌توانید این را در یک برنامه امتحان کنید. با این حال، این الگو آن‌قدر رایج است که Rust یک ساختار زبانی داخلی برای آن دارد، به نام حلقه `while`. در لیست ۳-۳، ما از `while` استفاده می‌کنیم تا برنامه را سه بار حلقه کنیم، هر بار شمارش معکوس کنیم، و سپس، پس از حلقه، پیامی چاپ کنیم و خارج شویم.

**نام فایل:** `src/main.rs**

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("پرتاب!!!");
}
```

**لیست ۳-۳:** استفاده از حلقه `while` برای اجرای کد در حالی که یک شرط به `true` ارزیابی می‌شود

این ساختار نیاز به تودرتو بودن زیادی را که در صورت استفاده از `loop`، `if`، `else`، و `break` لازم بود، حذف می‌کند و واضح‌تر است. در حالی که شرط به `true` ارزیابی می‌شود، کد اجرا می‌شود؛ در غیر این صورت، از حلقه خارج می‌شود.

#### حلقه‌زدن از طریق یک مجموعه با `for`

همچنین می‌توانید از ساختار `while` برای حلقه‌زدن روی عناصر یک مجموعه، مانند یک آرایه، استفاده کنید. برای مثال، حلقه در لیست ۳-۴ هر عنصر در آرایه `a` را چاپ می‌کند.

**نام فایل:** `src/main.rs**

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("مقدار برابر است با: {}", a[index]);

        index += 1;
    }
}
```

**لیست ۳-۴:** حلقه‌زدن از طریق هر عنصر یک مجموعه با استفاده از حلقه `while`

در اینجا، کد از طریق عناصر آرایه شمارش می‌کند. از ایندکس `0` شروع می‌کند و سپس تا رسیدن به ایندکس نهایی آرایه (یعنی وقتی `index < 5` دیگر درست نباشد) حلقه می‌زند. اجرای این کد هر عنصر آرایه را چاپ خواهد کرد:

```bash
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
مقدار برابر است با: 10
مقدار برابر است با: 20
مقدار برابر است با: 30
مقدار برابر است با: 40
مقدار برابر است با: 50
```

هر پنج مقدار آرایه همان‌طور که انتظار می‌رفت در ترمینال ظاهر می‌شوند. گرچه `index` در مقطعی به مقدار `5` می‌رسد، حلقه قبل از تلاش برای گرفتن مقدار ششم از آرایه متوقف می‌شود.

با این حال، این رویکرد مستعد خطاست؛ اگر مقدار ایندکس یا شرط آزمایش نادرست باشد، ممکن است باعث پنیک برنامه شویم. برای مثال، اگر تعریف آرایه `a` را به داشتن چهار عنصر تغییر دهید اما فراموش کنید شرط را به `while index < 4` به‌روزرسانی کنید، کد پنیک خواهد کرد. همچنین این روش کند است، زیرا کامپایلر کد زمان اجرا را برای بررسی شرطی که آیا ایندکس در محدوده آرایه است در هر تکرار حلقه اضافه می‌کند.

به‌عنوان جایگزینی مختصرتر، می‌توانید از یک حلقه `for` استفاده کنید و کدی را برای هر آیتم در یک مجموعه اجرا کنید. یک حلقه `for` شبیه کد در لیست ۳-۵ است.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("مقدار برابر است با: {element}");
    }
}
```

**لیست ۳-۵:** حلقه‌زدن از طریق هر عنصر یک مجموعه با استفاده از حلقه `for`

وقتی این کد را اجرا کنیم، همان خروجی لیست ۳-۴ را خواهیم دید. مهم‌تر از آن، حالا ایمنی کد را افزایش داده‌ایم و احتمال باگ‌هایی که ممکن است از فراتر رفتن از انتهای آرایه یا نرفتن به‌اندازه کافی و از دست دادن برخی آیتم‌ها ناشی شود را حذف کرده‌ایم.

با استفاده از حلقه `for`، اگر تعداد مقادیر در آرایه را تغییر دهید، نیازی به یادآوری برای تغییر کدهای دیگر ندارید، برخلاف روش استفاده‌شده در لیست ۳-۴.

ایمنی و مختصر بودن حلقه‌های `for` آن‌ها را به رایج‌ترین ساختار حلقه در Rust تبدیل کرده است. حتی در موقعیت‌هایی که می‌خواهید کدی را تعداد مشخصی بار اجرا کنید، مانند مثال شمارش معکوس که از حلقه `while` در لیست ۳-۳ استفاده کرد، اکثر Rustaceanها از حلقه `for` استفاده می‌کنند. راه انجام این کار استفاده از یک `Range` است، که توسط کتابخانه استاندارد ارائه شده و تمام اعداد را به‌صورت متوالی از یک عدد شروع و قبل از عدد دیگر پایان می‌دهد.

در اینجا نحوه شمارش معکوس با استفاده از حلقه `for` و روش دیگری که هنوز درباره‌اش صحبت نکرده‌ایم، `rev`، برای معکوس کردن محدوده، آورده شده است:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("پرتاب!!!");
}
```

این کد کمی زیباتر است، نه؟

**توضیح اضافی:** متد `rev()` محدوده را معکوس می‌کند، بنابراین `(1..4).rev()` از `3` به `1` می‌شمارد، که خروجی مشابه حلقه `while` در لیست ۳-۳ را تولید می‌کند اما مختصرتر و ایمن‌تر است.

---

### خلاصه

شما موفق شدید! این یک فصل بزرگ بود: شما درباره متغیرها، نوع‌های داده مقیاس‌پذیر و ترکیبی، توابع، کامنت‌ها، عبارات `if`، و حلقه‌ها آموختید! برای تمرین با مفاهیم بحث‌شده در این فصل، سعی کنید برنامه‌هایی برای انجام موارد زیر بسازید:

- تبدیل دما بین فارنهایت و سلسیوس.
- تولید عدد nام فیبوناچی.
- چاپ اشعار سرود کریسمس «دوازده روز کریسمس»، با بهره‌گیری از تکرار در آهنگ.

وقتی آماده حرکت به جلو هستید، درباره مفهومی در Rust صحبت خواهیم کرد که معمولاً در زبان‌های برنامه‌نویسی دیگر وجود ندارد: مالکیت (ownership).


# پیاده‌سازی یک الگوی طراحی شیءگرا

الگوی حالت (State Pattern) یک الگوی طراحی شیءگرا است. هسته این الگو این است که مجموعه‌ای از حالت‌هایی که یک مقدار می‌تواند به‌صورت داخلی داشته باشد را تعریف می‌کنیم. این حالت‌ها توسط مجموعه‌ای از اشیاء حالت نشان داده می‌شوند، و رفتار مقدار بر اساس حالت آن تغییر می‌کند. ما قصد داریم مثالی از یک ساختار پست وبلاگ را بررسی کنیم که یک فیلد برای نگه‌داری حالت خود دارد، که یکی از اشیاء حالت از مجموعه «پیش‌نویس»، «در انتظار بررسی»، یا «منتشرشده» خواهد بود.

اشیاء حالت عملکرد مشترکی دارند: در Rust، البته، ما به جای اشیاء و وراثت از ساختارها و ویژگی‌ها استفاده می‌کنیم. هر شیء حالت مسئول رفتار خود و تعیین زمان تغییر به حالت دیگر است. مقداری که یک شیء حالت را نگه می‌دارد هیچ اطلاعی از رفتارهای مختلف حالت‌ها یا زمان انتقال بین حالت‌ها ندارد.

مزیت استفاده از الگوی حالت این است که وقتی نیازهای کسب‌وکار برنامه تغییر می‌کند، نیازی به تغییر کد مقداری که حالت را نگه می‌دارد یا کدی که از مقدار استفاده می‌کند نداریم. فقط باید کد داخل یکی از اشیاء حالت را به‌روزرسانی کنیم تا قوانین آن تغییر کند یا شاید اشیاء حالت بیشتری اضافه کنیم.

ابتدا قصد داریم الگوی حالت را به روش سنتی‌تر شیءگرا پیاده‌سازی کنیم، سپس از رویکردی استفاده می‌کنیم که در Rust طبیعی‌تر است. بیایید به‌صورت تدریجی یک جریان کاری پست وبلاگ را با استفاده از الگوی حالت پیاده‌سازی کنیم.

عملکرد نهایی به این شکل خواهد بود:

- یک پست وبلاگ به‌عنوان یک پیش‌نویس خالی شروع می‌شود.
- وقتی پیش‌نویس آماده شد، بررسی پست درخواست می‌شود.
- وقتی پست تأیید شد، منتشر می‌شود.
- فقط پست‌های منتشرشده محتوایی برای چاپ برمی‌گردانند، بنابراین پست‌های تأییدنشده نمی‌توانند به‌طور تصادفی منتشر شوند.
- هر تغییر دیگری که روی یک پست امتحان شود، نباید تأثیری داشته باشد. برای مثال، اگر سعی کنیم یک پست پیش‌نویس را قبل از درخواست بررسی تأیید کنیم، پست باید همچنان یک پیش‌نویس منتشرنشده باقی بماند.

Listing 18-11 این جریان کاری را به‌صورت کد نشان می‌دهد: این یک نمونه استفاده از API است که در یک کریت کتابخانه‌ای به نام `blog` پیاده‌سازی خواهیم کرد. این کد هنوز کامپایل نمی‌شود چون هنوز کریت `blog` را پیاده‌سازی نکرده‌ایم.

**فایل: src/main.rs**

```rust
// این کد کامپایل نمی‌شود!
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("امروز برای ناهار سالاد خوردم"); // I ate a salad for lunch today
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("امروز برای ناهار سالاد خوردم", post.content()); // I ate a salad for lunch today
}
```

**Listing 18-11: کدی که رفتار مورد نظر ما را برای کریت blog نشان می‌دهد**

ما می‌خواهیم به کاربر اجازه دهیم یک پست وبلاگ پیش‌نویس جدید با `Post::new` ایجاد کند. می‌خواهیم امکان افزودن متن به پست وبلاگ وجود داشته باشد. اگر فوراً سعی کنیم محتوای پست را دریافت کنیم، قبل از تأیید، نباید هیچ متنی دریافت کنیم چون پست هنوز پیش‌نویس است. برای اهداف نمایشی، `assert_eq!` را به کد اضافه کرده‌ایم. یک تست واحد عالی برای این می‌تواند این باشد که بررسی کنیم یک پست وبلاگ پیش‌نویس یک رشته خالی از متد `content` برمی‌گرداند، اما در این مثال تست‌ها را نخواهیم نوشت.

در ادامه، می‌خواهیم امکان درخواست بررسی پست را فعال کنیم، و می‌خواهیم `content` یک رشته خالی را در حالی که در انتظار بررسی است برگرداند. وقتی پست تأیید می‌شود، باید منتشر شود، به این معنا که متن پست وقتی `content` فراخوانی می‌شود برگردانده خواهد شد.

توجه کنید که تنها نوعی که از کریت با آن تعامل داریم، نوع `Post` است. این نوع از الگوی حالت استفاده خواهد کرد و مقداری را نگه می‌دارد که یکی از سه شیء حالت خواهد بود که نشان‌دهنده حالت‌های مختلف یک پست است—پیش‌نویس، در انتظار بررسی، یا منتشرشده. تغییر از یک حالت به حالت دیگر به‌صورت داخلی در نوع `Post` مدیریت خواهد شد. حالت‌ها در پاسخ به متدهایی که کاربران کتابخانه ما روی نمونه `Post` فراخوانی می‌کنند تغییر می‌کنند، اما آن‌ها نیازی به مدیریت مستقیم تغییرات حالت ندارند. همچنین، کاربران نمی‌توانند با حالت‌ها اشتباه کنند، مانند انتشار یک پست قبل از بررسی آن.

## تعریف Post و ایجاد یک نمونه جدید در حالت پیش‌نویس

بیایید با پیاده‌سازی کتابخانه شروع کنیم! می‌دانیم که به یک ساختار عمومی `Post` نیاز داریم که مقداری محتوا را نگه می‌دارد، بنابراین با تعریف ساختار و یک تابع عمومی مرتبط `new` برای ایجاد یک نمونه از `Post` شروع می‌کنیم، همان‌طور که در Listing 18-12 نشان داده شده است. همچنین یک ویژگی خصوصی `State` ایجاد خواهیم کرد که رفتارهایی را که همه اشیاء حالت برای یک `Post` باید داشته باشند تعریف می‌کند.

سپس `Post` یک شیء ویژگی از `Box<dyn State>` را در یک `Option<T>` در یک فیلد خصوصی به نام `state` برای نگه‌داری شیء حالت نگه خواهد داشت. به زودی خواهید دید چرا `Option<T>` لازم است.

**فایل: src/lib.rs**

```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
```

**Listing 18-12: تعریف ساختار Post و تابع new که یک نمونه جدید Post ایجاد می‌کند، ویژگی State، و ساختار Draft**

ویژگی `State` رفتار مشترکی را که حالت‌های مختلف پست دارند تعریف می‌کند. اشیاء حالت، `Draft`، `PendingReview`، و `Published` هستند، و همه آن‌ها ویژگی `State` را پیاده‌سازی خواهند کرد. در حال حاضر، این ویژگی هیچ متدی ندارد، و ما با تعریف فقط حالت `Draft` شروع می‌کنیم زیرا این حالتی است که می‌خواهیم یک پست از آن شروع شود.

وقتی یک `Post` جدید ایجاد می‌کنیم، فیلد `state` آن را به یک مقدار `Some` تنظیم می‌کنیم که یک `Box` را نگه می‌دارد. این `Box` به یک نمونه جدید از ساختار `Draft` اشاره می‌کند. این اطمینان می‌دهد که هر زمان یک نمونه جدید از `Post` ایجاد می‌کنیم، به‌عنوان پیش‌نویس شروع می‌شود. چون فیلد `state` از `Post` خصوصی است، هیچ راهی برای ایجاد یک `Post` در حالت دیگری وجود ندارد! در تابع `Post::new`، فیلد `content` را به یک رشته جدید و خالی تنظیم می‌کنیم.

## ذخیره متن محتوای پست

در Listing 18-11 دیدیم که می‌خواهیم بتوانیم متدی به نام `add_text` فراخوانی کنیم و یک `&str` به آن پاس دهیم که سپس به‌عنوان محتوای متنی پست اضافه می‌شود. ما این را به‌عنوان یک متد پیاده‌سازی می‌کنیم، به جای اینکه فیلد `content` را به‌صورت `pub` افشا کنیم، تا بعداً بتوانیم متدی پیاده‌سازی کنیم که نحوه خواندن داده‌های فیلد `content` را کنترل کند. متد `add_text` بسیار ساده است، بنابراین بیایید پیاده‌سازی آن را در Listing 18-13 به بلوک `impl Post` اضافه کنیم.

**فایل: src/lib.rs**

```rust
impl Post {
    // --snip--
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```

**Listing 18-13: پیاده‌سازی متد add_text برای افزودن متن به محتوای پست**

متد `add_text` یک ارجاع قابل‌تغییر به `self` می‌گیرد زیرا ما نمونه `Post` که `add_text` روی آن فراخوانی شده را تغییر می‌دهیم. سپس `push_str` را روی `String` در `content` فراخوانی می‌کنیم و آرگومان `text` را برای افزودن به محتوای ذخیره‌شده پاس می‌دهیم. این رفتار به حالت پست بستگی ندارد، بنابراین بخشی از الگوی حالت نیست. متد `add_text` اصلاً با فیلد `state` تعامل ندارد، اما بخشی از رفتاری است که می‌خواهیم پشتیبانی کنیم.

## اطمینان از خالی بودن محتوای یک پست پیش‌نویس

حتی پس از اینکه `add_text` را فراخوانی کردیم و مقداری محتوا به پست خود اضافه کردیم، همچنان می‌خواهیم متد `content` یک برش رشته خالی برگرداند زیرا پست هنوز در حالت پیش‌نویس است، همان‌طور که در خط 7 از Listing 18-11 نشان داده شده است. برای حالا، بیایید متد `content` را با ساده‌ترین چیزی که این نیاز را برآورده می‌کند پیاده‌سازی کنیم: همیشه یک برش رشته خالی برگرداندن. بعداً وقتی امکان تغییر حالت پست را برای انتشار پیاده‌سازی کردیم، این را تغییر خواهیم داد. تا حالا، پست‌ها فقط می‌توانند در حالت پیش‌نویس باشند، بنابراین محتوای پست همیشه باید خالی باشد. Listing 18-14 این پیاده‌سازی نگهدارنده را نشان می‌دهد.

**فایل: src/lib.rs**

```rust
impl Post {
    // --snip--
    pub fn content(&self) -> &str {
        ""
    }
}
```

**Listing 18-14: افزودن یک پیاده‌سازی نگهدارنده برای متد content روی Post که همیشه یک برش رشته خالی برمی‌گرداند**

با این متد `content` اضافه‌شده، همه چیز در Listing 18-11 تا خط 7 همان‌طور که در نظر گرفته شده بود کار می‌کند.

## درخواست بررسی، تغییر حالت پست

در ادامه، باید قابلیتی برای درخواست بررسی یک پست اضافه کنیم، که باید حالت آن را از `Draft` به `PendingReview` تغییر دهد. Listing 18-15 این کد را نشان می‌دهد.

**فایل: src/lib.rs**

```rust
impl Post {
    // --snip--
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```

**Listing 18-15: پیاده‌سازی متدهای request_review روی Post و ویژگی State**

ما به `Post` یک متد عمومی به نام `request_review` می‌دهیم که یک ارجاع قابل‌تغییر به `self` می‌گیرد. سپس یک متد داخلی `request_review` را روی حالت فعلی `Post` فراخوانی می‌کنیم، و این متد دوم حالت فعلی را مصرف می‌کند و یک حالت جدید برمی‌گرداند.

ما متد `request_review` را به ویژگی `State` اضافه می‌کنیم؛ همه نوع‌هایی که این ویژگی را پیاده‌سازی می‌کنند حالا باید متد `request_review` را پیاده‌سازی کنند. توجه کنید که به جای داشتن `self`، `&self`، یا `&mut self` به‌عنوان پارامتر اول متد، ما `self: Box<Self>` داریم. این نحو به این معناست که متد فقط وقتی معتبر است که روی یک `Box` که نوع را نگه می‌دارد فراخوانی شود. این نحو مالکیت `Box<Self>` را می‌گیرد، حالت قدیمی را باطل می‌کند تا مقدار حالت `Post` بتواند به یک حالت جدید تبدیل شود.

برای مصرف حالت قدیمی، متد `request_review` نیاز به گرفتن مالکیت مقدار حالت دارد. اینجا جایی است که `Option` در فیلد `state` از `Post` وارد می‌شود: ما متد `take` را فراخوانی می‌کنیم تا مقدار `Some` را از فیلد `state` بگیریم و یک `None` در جای آن بگذاریم، زیرا Rust به ما اجازه نمی‌دهد فیلدهای پرنشده در ساختارها داشته باشیم. این به ما اجازه می‌دهد مقدار حالت را از `Post` منتقل کنیم به جای اینکه آن را قرض بگیریم. سپس مقدار حالت پست را به نتیجه این عملیات تنظیم می‌کنیم.

ما باید `state` را به‌طور موقت به `None` تنظیم کنیم به جای اینکه مستقیماً با کدی مثل `self.state = self.state.request_review();` آن را تنظیم کنیم تا مالکیت مقدار حالت را بگیریم. این اطمینان می‌دهد که `Post` نمی‌تواند از مقدار حالت قدیمی پس از تبدیل آن به حالت جدید استفاده کند.

متد `request_review` روی `Draft` یک نمونه جدید و بسته‌بندی‌شده از یک ساختار `PendingReview` جدید برمی‌گرداند، که نشان‌دهنده حالتی است که پست در انتظار بررسی است. ساختار `PendingReview` نیز متد `request_review` را پیاده‌سازی می‌کند اما هیچ تبدیلی انجام نمی‌دهد. در عوض، خودش را برمی‌گرداند زیرا وقتی بررسی را برای پستی که قبلاً در حالت `PendingReview` است درخواست می‌کنیم، باید در حالت `PendingReview` باقی بماند.

حالا می‌توانیم مزایای الگوی حالت را ببینیم: متد `request_review` روی `Post` صرف‌نظر از مقدار حالت آن یکسان است. هر حالت مسئول قوانین خود است.

ما متد `content` روی `Post` را همان‌طور که هست نگه می‌داریم، که یک برش رشته خالی برمی‌گرداند. حالا می‌توانیم یک `Post` در حالت `PendingReview` و همچنین در حالت `Draft` داشته باشیم، اما می‌خواهیم همان رفتار را در حالت `PendingReview` داشته باشیم. Listing 18-11 حالا تا خط 10 کار می‌کند!

## افزودن approve برای تغییر رفتار content

متد `approve` مشابه متد `request_review` خواهد بود: آن حالت را به مقداری که حالت فعلی می‌گوید باید وقتی آن حالت تأیید می‌شود تنظیم خواهد کرد، همان‌طور که در Listing 18-16 نشان داده شده است:

**فایل: src/lib.rs**

```rust
impl Post {
    // --snip--
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```

**Listing 18-16: پیاده‌سازی متد approve روی Post و ویژگی State**

ما متد `approve` را به ویژگی `State` اضافه می‌کنیم و یک ساختار جدید که ویژگی `State` را پیاده‌سازی می‌کند، یعنی حالت `Published`، اضافه می‌کنیم.

مشابه نحوه کار `request_review` روی `PendingReview`، اگر متد `approve` را روی یک `Draft` فراخوانی کنیم، تأثیری نخواهد داشت زیرا `approve` خودش را برمی‌گرداند. وقتی `approve` را روی `PendingReview` فراخوانی می‌کنیم، یک نمونه جدید و بسته‌بندی‌شده از ساختار `Published` برمی‌گرداند. ساختار `Published` ویژگی `State` را پیاده‌سازی می‌کند، و برای هر دو متد `request_review` و `approve`، خودش را برمی‌گرداند، زیرا پست در این موارد باید در حالت `Published` باقی بماند.

حالا باید متد `content` روی `Post` را به‌روزرسانی کنیم. ما می‌خواهیم مقداری که از `content` برگردانده می‌شود به حالت فعلی `Post` بستگی داشته باشد، بنابراین قصد داریم `Post` را وادار کنیم به یک متد `content` که روی حالت آن تعریف شده واگذار کند، همان‌طور که در Listing 18-17 نشان داده شده است:

**فایل: src/lib.rs**

```rust
// این کد کامپایل نمی‌شود!
impl Post {
    // --snip--
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
}
```

**Listing 18-17: به‌روزرسانی متد content روی Post برای واگذاری به یک متد content روی State**

چون هدف این است که همه این قوانین را در ساختارهایی که `State` را پیاده‌سازی می‌کنند نگه داریم، یک متد `content` را روی مقدار در `state` فراخوانی می‌کنیم و نمونه پست (یعنی `self`) را به‌عنوان آرگومان پاس می‌دهیم. سپس مقداری را که از استفاده از متد `content` روی مقدار حالت برگردانده می‌شود برمی‌گردانیم.

ما متد `as_ref` را روی `Option` فراخوانی می‌کنیم زیرا می‌خواهیم یک ارجاع به مقدار داخل `Option` داشته باشیم نه مالکیت مقدار. چون `state` یک `Option<Box<dyn State>>` است، وقتی `as_ref` را فراخوانی می‌کنیم، یک `Option<&Box<dyn State>>` برگردانده می‌شود. اگر `as_ref` را فراخوانی نمی‌کردیم، خطایی دریافت می‌کردیم زیرا نمی‌توانیم `state` را از پارامتر تابع قرض‌شده `&self` منتقل کنیم.

سپس متد `unwrap` را فراخوانی می‌کنیم، که می‌دانیم هرگز پنیک نمی‌کند، زیرا می‌دانیم متدهای روی `Post` اطمینان می‌دهند که `state` همیشه وقتی این متدها تمام می‌شوند یک مقدار `Some` خواهد داشت. این یکی از مواردی است که در بخش «مواردی که شما اطلاعات بیشتری از کامپایلر دارید» در فصل نهم صحبت کردیم، وقتی می‌دانیم که مقدار `None` هرگز ممکن نیست، حتی اگر کامپایلر نتواند این را درک کند.

در این مرحله، وقتی `content` را روی `&Box<dyn State>` فراخوانی می‌کنیم، اجبار لغو ارجاع (deref coercion) روی `&` و `Box` اثر می‌گذارد تا متد `content` در نهایت روی نوعی که ویژگی `State` را پیاده‌سازی می‌کند فراخوانی شود. این به این معناست که باید `content` را به تعریف ویژگی `State` اضافه کنیم، و اینجا جایی است که منطق مربوط به اینکه چه محتوایی بسته به اینکه در کدام حالت هستیم برگردانده شود را قرار خواهیم داد، همان‌طور که در Listing 18-18 نشان داده شده است:

**فایل: src/lib.rs**

```rust
trait State {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```

**Listing 18-18: افزودن متد content به ویژگی State**

ما یک پیاده‌سازی پیش‌فرض برای متد `content` اضافه می‌کنیم که یک برش رشته خالی برمی‌گرداند. این به این معناست که نیازی به پیاده‌سازی `content` روی ساختارهای `Draft` و `PendingReview` نداریم. ساختار `Published` متد `content` را بازنویسی می‌کند و مقدار موجود در `post.content` را برمی‌گرداند.

توجه کنید که این متد نیاز به حاشیه‌نویسی طول عمر دارد، همان‌طور که در فصل دهم بحث کردیم. ما یک ارجاع به یک پست به‌عنوان آرگومان می‌گیریم و یک ارجاع به بخشی از آن پست را برمی‌گردانیم، بنابراین طول عمر ارجاع برگردانده‌شده به طول عمر آرگومان پست مرتبط است.

و تمام شد—حالا همه Listing 18-11 کار می‌کند! ما الگوی حالت را با قوانین جریان کاری پست وبلاگ پیاده‌سازی کردیم. منطق مربوط به قوانین در اشیاء حالت قرار دارد به جای اینکه در سراسر `Post` پراکنده باشد.

## چرا از شمارش (Enum) استفاده نکردیم؟

ممکن است فکر کرده باشید که چرا از یک شمارش با حالت‌های مختلف ممکن پست به‌عنوان گونه‌ها استفاده نکردیم. این قطعاً یک راه‌حل ممکن است؛ آن را امتحان کنید و نتایج نهایی را مقایسه کنید تا ببینید کدام را ترجیح می‌دهید! یکی از معایب استفاده از شمارش این است که هر جایی که مقدار شمارش را بررسی می‌کند نیاز به یک عبارت `match` یا مشابه آن برای مدیریت هر گونه ممکن خواهد داشت. این می‌تواند تکراری‌تر از این راه‌حل شیء ویژگی باشد.

## معاوضه‌های الگوی حالت

ما نشان دادیم که Rust قادر به پیاده‌سازی الگوی حالت شیءگرا برای کپسوله‌سازی انواع مختلف رفتاری است که یک پست باید در هر حالت داشته باشد. متدهای روی `Post` هیچ اطلاعی از رفتارهای مختلف ندارند. نحوه سازماندهی کد، ما را مجبور می‌کند که فقط در یک مکان نگاه کنیم تا راه‌های مختلف رفتار یک پست منتشرشده را بدانیم: پیاده‌سازی ویژگی `State` روی ساختار `Published`.

اگر بخواهیم یک پیاده‌سازی جایگزین ایجاد کنیم که از الگوی حالت استفاده نکند، ممکن است به جای آن از عبارت‌های `match` در متدهای روی `Post` یا حتی در کد اصلی که حالت پست را بررسی می‌کند و رفتار را در آن مکان‌ها تغییر می‌دهد استفاده کنیم. این به این معناست که باید در چندین مکان نگاه کنیم تا همه پیامدهای حضور یک پست در حالت منتشرشده را درک کنیم! این با افزودن حالت‌های بیشتر افزایش می‌یابد: هر یک از آن عبارت‌های `match` به یک بازوی دیگر نیاز خواهد داشت.

با الگوی حالت، متدهای `Post` و مکان‌هایی که از `Post` استفاده می‌کنیم نیازی به عبارت‌های `match` ندارند، و برای افزودن یک حالت جدید، فقط باید یک ساختار جدید اضافه کنیم و متدهای ویژگی را روی آن ساختار پیاده‌سازی کنیم.

پیاده‌سازی با استفاده از الگوی حالت به‌راحتی می‌تواند برای افزودن عملکرد بیشتر گسترش یابد. برای دیدن سادگی نگهداری کدی که از الگوی حالت استفاده می‌کند، چند پیشنهاد زیر را امتحان کنید:

- افزودن یک متد `reject` که حالت پست را از `PendingReview` به `Draft` تغییر دهد.
- نیاز به دو فراخوانی `approve` قبل از اینکه حالت به `Published` تغییر کند.
- اجازه دادن به کاربران برای افزودن محتوای متنی فقط وقتی پست در حالت `Draft` است. نکته: شیء حالت را مسئول آنچه ممکن است در مورد محتوا تغییر کند کنید اما نه مسئول تغییر `Post`.

یکی از معایب الگوی حالت این است که، چون حالت‌ها انتقال بین حالت‌ها را پیاده‌سازی می‌کنند، برخی از حالت‌ها به یکدیگر وابسته هستند. اگر حالت دیگری بین `PendingReview` و `Published` اضافه کنیم، مانند `Scheduled`، باید کد در `PendingReview` را تغییر دهیم تا به جای آن به `Scheduled` منتقل شود. اگر `PendingReview` با افزودن یک حالت جدید نیازی به تغییر نداشته باشد، کار کمتری لازم بود، اما این به این معناست که به یک الگوی طراحی دیگر تغییر کنیم.

یکی دیگر از معایب این است که برخی منطق‌ها را تکرار کرده‌ایم. برای حذف برخی از این تکرار، ممکن است سعی کنیم پیاده‌سازی‌های پیش‌فرض برای متدهای `request_review` و `approve` روی ویژگی `State` ایجاد کنیم که `self` را برگردانند؛ با این حال، این کار نمی‌کند: وقتی از `State` به‌عنوان یک شیء ویژگی استفاده می‌کنیم، ویژگی نمی‌داند که `self` مشخص دقیقاً چه خواهد بود، بنابراین نوع بازگشتی در زمان کامپایل مشخص نیست. (این یکی از قوانین سازگاری dyn است که قبلاً ذکر شد.)

تکرار دیگر شامل پیاده‌سازی‌های مشابه متدهای `request_review` و `approve` روی `Post` است. هر دو متد از `Option::take` با فیلد `state` از `Post` استفاده می‌کنند، و اگر `state` یک `Some` باشد، به پیاده‌سازی مقدار بسته‌بندی‌شده از همان متد واگذار می‌کنند و مقدار جدید فیلد `state` را به نتیجه تنظیم می‌کنند. اگر متدهای زیادی روی `Post` داشتیم که این الگو را دنبال می‌کردند، ممکن بود تعریف یک ماکرو را در نظر بگیریم تا تکرار را حذف کنیم (به بخش «ماکروها» در فصل بیستم مراجعه کنید).

با پیاده‌سازی الگوی حالت دقیقاً همان‌طور که برای زبان‌های شیءگرا تعریف شده است، ما به‌طور کامل از نقاط قوت Rust بهره نمی‌بریم. بیایید به برخی تغییرات که می‌توانیم در کریت `blog` ایجاد کنیم نگاه کنیم که می‌توانند حالت‌ها و انتقال‌های نامعتبر را به خطاهای زمان کامپایل تبدیل کنند.

## کدگذاری حالت‌ها و رفتار به‌عنوان نوع‌ها

ما به شما نشان خواهیم داد که چگونه الگوی حالت را بازاندیشی کنید تا مجموعه متفاوتی از معاوضه‌ها به دست آید. به جای کپسوله‌سازی کامل حالت‌ها و انتقال‌ها به‌گونه‌ای که کد خارجی هیچ اطلاعی از آن‌ها نداشته باشد، حالت‌ها را به نوع‌های مختلف کدگذاری خواهیم کرد. در نتیجه، سیستم بررسی نوع Rust تلاش برای استفاده از پست‌های پیش‌نویس در جایی که فقط پست‌های منتشرشده مجاز هستند را با صدور یک خطای کامپایلر جلوگیری خواهد کرد.

بیایید به بخش اول `main` در Listing 18-11 نگاه کنیم:

**فایل: src/main.rs**

```rust
fn main() {
    let mut post = Post::new();

    post.add_text("امروز برای ناهار سالاد خوردم"); // I ate a salad for lunch today
    assert_eq!("", post.content());
}
```

ما همچنان ایجاد پست‌های جدید در حالت پیش‌نویس را با `Post::new` و امکان افزودن متن به محتوای پست فعال می‌کنیم. اما به جای داشتن یک متد `content` روی یک پست پیش‌نویس که یک رشته خالی برمی‌گرداند، کاری خواهیم کرد که پست‌های پیش‌نویس اصلاً متد `content` نداشته باشند. به این ترتیب، اگر سعی کنیم محتوای یک پست پیش‌نویس را دریافت کنیم، یک خطای کامپایلر دریافت خواهیم کرد که به ما می‌گوید متد وجود ندارد. در نتیجه، غیرممکن خواهد بود که به‌طور تصادفی محتوای پست پیش‌نویس را در تولید نمایش دهیم زیرا آن کد حتی کامپایل نمی‌شود. Listing 18-19 تعریف یک ساختار `Post` و یک ساختار `DraftPost`، و همچنین متدهای روی هر کدام را نشان می‌دهد.

**فایل: src/lib.rs**

```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```

**Listing 18-19: یک Post با متد content و DraftPost بدون متد content**

هر دو ساختار `Post` و `DraftPost` یک فیلد خصوصی `content` دارند که متن پست وبلاگ را ذخیره می‌کند. ساختارها دیگر فیلد `state` ندارند زیرا ما کدگذاری حالت را به نوع‌های ساختارها منتقل کرده‌ایم. ساختار `Post` یک پست منتشرشده را نشان خواهد داد، و یک متد `content` دارد که محتوا را برمی‌گرداند.

ما همچنان یک تابع `Post::new` داریم، اما به جای برگرداندن یک نمونه از `Post`، یک نمونه از `DraftPost` برمی‌گرداند. چون `content` خصوصی است و هیچ تابعی وجود ندارد که `Post` را برگرداند، در حال حاضر ایجاد یک نمونه از `Post` ممکن نیست.

ساختار `DraftPost` یک متد `add_text` دارد، بنابراین می‌توانیم متن را به `content` مثل قبل اضافه کنیم، اما توجه کنید که `DraftPost` متد `content` تعریف‌شده‌ای ندارد! بنابراین حالا برنامه اطمینان می‌دهد که همه پست‌ها به‌عنوان پست‌های پیش‌نویس شروع می‌شوند، و پست‌های پیش‌نویس محتوای خود را برای نمایش در دسترس ندارند. هر تلاشی برای دور زدن این محدودیت‌ها منجر به یک خطای کامپایلر خواهد شد.

## پیاده‌سازی انتقال‌ها به‌عنوان تبدیل به نوع‌های مختلف

پس چگونه یک پست منتشرشده به دست می‌آوریم؟ ما می‌خواهیم قانونی را اعمال کنیم که یک پست پیش‌نویس باید بررسی و تأیید شود تا بتواند منتشر شود. یک پست در حالت در انتظار بررسی همچنان نباید هیچ محتوایی نمایش دهد. بیایید این محدودیت‌ها را با افزودن یک ساختار دیگر، `PendingReviewPost`، تعریف متد `request_review` روی `DraftPost` برای برگرداندن یک `PendingReviewPost`، و تعریف یک متد `approve` روی `PendingReviewPost` برای برگرداندن یک `Post` پیاده‌سازی کنیم، همان‌طور که در Listing 18-20 نشان داده شده است.

**فایل: src/lib.rs**

```rust
impl DraftPost {
    // --snip--
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```

**Listing 18-20: یک PendingReviewPost که با فراخوانی request_review روی DraftPost ایجاد می‌شود و یک متد approve که یک PendingReviewPost را به یک Post منتشرشده تبدیل می‌کند**

متدهای `request_review` و `approve` مالکیت `self` را می‌گیرند، بنابراین نمونه‌های `DraftPost` و `PendingReviewPost` را مصرف می‌کنند و آن‌ها را به ترتیب به یک `PendingReviewPost` و یک `Post` منتشرشده تبدیل می‌کنند. به این ترتیب، پس از فراخوانی `request_review` روی آن‌ها، هیچ نمونه `DraftPost` باقی‌مانده‌ای نخواهیم داشت، و غیره. ساختار `PendingReviewPost` متد `content` تعریف‌شده‌ای روی آن ندارد، بنابراین تلاش برای خواندن محتوای آن منجر به یک خطای کامپایلر می‌شود، همان‌طور که برای `DraftPost` بود. چون تنها راه برای به دست آوردن یک نمونه `Post` منتشرشده که متد `content` تعریف‌شده‌ای دارد، فراخوانی متد `approve` روی یک `PendingReviewPost` است، و تنها راه برای به دست آوردن یک `PendingReviewPost` فراخوانی متد `request_review` روی یک `DraftPost` است، ما حالا جریان کاری پست وبلاگ را در سیستم نوع کدگذاری کرده‌ایم.

اما باید تغییرات کوچکی هم در `main` ایجاد کنیم. متدهای `request_review` و `approve` نمونه‌های جدیدی برمی‌گردانند به جای اینکه ساختاری که روی آن فراخوانی شده‌اند را تغییر دهند، بنابراین باید تخصیص‌های سایه‌زنی (shadowing) بیشتری با `let post =` اضافه کنیم تا نمونه‌های برگردانده‌شده را ذخیره کنیم. همچنین نمی‌توانیم ادعا کنیم که محتوای پست‌های پیش‌نویس و در انتظار بررسی رشته‌های خالی هستند، و دیگر به آن‌ها نیازی نداریم: ما دیگر نمی‌توانیم کدی را که سعی می‌کند از محتوای پست‌ها در آن حالت‌ها استفاده کند کامپایل کنیم. کد به‌روز‌شده در `main` در Listing 18-21 نشان داده شده است.

**فایل: src/main.rs**

```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("امروز برای ناهار سالاد خوردم"); // I ate a salad for lunch today

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("امروز برای ناهار سالاد خوردم", post.content()); // I ate a salad for lunch today
}
```

**Listing 18-21: تغییرات در main برای استفاده از پیاده‌سازی جدید جریان کاری پست وبلاگ**

تغییراتی که برای تخصیص مجدد `post` در `main` نیاز داشتیم به این معناست که این پیاده‌سازی دیگر کاملاً الگوی حالت شیءگرا را دنبال نمی‌کند: تبدیل‌ها بین حالت‌ها دیگر کاملاً در پیاده‌سازی `Post` کپسوله نشده‌اند. با این حال، سود ما این است که حالت‌های نامعتبر حالا به دلیل سیستم نوع و بررسی نوع که در زمان کامپایل اتفاق می‌افتد غیرممکن هستند! این اطمینان می‌دهد که برخی اشکالات، مانند نمایش محتوای یک پست منتشرنشده، قبل از اینکه به تولید برسند کشف خواهند شد.

سعی کنید وظایف پیشنهادی در ابتدای این بخش را روی کریت `blog` همان‌طور که پس از Listing 18-21 است انجام دهید تا ببینید درباره طراحی این نسخه از کد چه فکر می‌کنید. توجه کنید که برخی از وظایف ممکن است در این طراحی قبلاً تکمیل شده باشند.

ما دیدیم که اگرچه Rust قادر به پیاده‌سازی الگوهای طراحی شیءگرا است، الگوهای دیگری، مانند کدگذاری حالت در سیستم نوع، نیز در Rust در دسترس هستند. این الگوها معاوضه‌های متفاوتی دارند. اگرچه ممکن است با الگوهای شیءگرا بسیار آشنا باشید، بازاندیشی مسئله برای بهره‌برداری از ویژگی‌های Rust می‌تواند مزایایی مانند جلوگیری از برخی اشکالات در زمان کامپایل فراهم کند. الگوهای شیءگرا همیشه بهترین راه‌حل در Rust نیستند به دلیل ویژگی‌هایی مانند مالکیت که زبان‌های شیءگرا ندارند.

## خلاصه

صرف‌نظر از اینکه پس از خواندن این فصل فکر می‌کنید Rust یک زبان شیءگرا است یا نه، حالا می‌دانید که می‌توانید از اشیاء ویژگی برای به دست آوردن برخی ویژگی‌های شیءگرا در Rust استفاده کنید. ارسال پویا می‌تواند به کد شما مقداری انعطاف‌پذیری بدهد در ازای مقداری عملکرد زمان اجرا. می‌توانید از این انعطاف‌پذیری برای پیاده‌سازی الگوهای شیءگرا استفاده کنید که می‌توانند به قابلیت نگهداری کد شما کمک کنند. Rust همچنین ویژگی‌های دیگری مانند مالکیت دارد که زبان‌های شیءگرا ندارند. یک الگوی شیءگرا همیشه بهترین راه برای بهره‌برداری از نقاط قوت Rust نیست، اما یک گزینه در دسترس است.

در ادامه، به الگوها نگاه خواهیم کرد، که یکی دیگر از ویژگی‌های Rust هستند که انعطاف‌پذیری زیادی را فراهم می‌کنند. ما آن‌ها را به‌صورت مختصر در طول کتاب دیده‌ایم اما هنوز قابلیت کامل آن‌ها را ندیده‌ایم. بیایید شروع کنیم!
## برنامه‌نویسی یک بازی حدس

بیایید با کار روی یک پروژه عملی با هم به Rust شیرجه بزنیم! این فصل شما را با چند مفهوم رایج Rust آشنا می‌کند و نشان می‌دهد چگونه از آن‌ها در یک برنامه واقعی استفاده کنید. درباره `let`، `match`، متدها، توابع مرتبط، crateهای خارجی و موارد دیگر خواهید آموخت! در فصل‌های بعدی، این ایده‌ها را با جزئیات بیشتری بررسی خواهیم کرد. در این فصل، فقط اصول اولیه را تمرین می‌کنید.

ما یک مسئله کلاسیک برنامه‌نویسی برای مبتدیان را پیاده‌سازی می‌کنیم: یک بازی حدس. نحوه کار به این صورت است: برنامه یک عدد صحیح تصادفی بین ۱ تا ۱۰۰ تولید می‌کند. سپس از بازیکن می‌خواهد یک حدس وارد کند. پس از وارد کردن حدس، برنامه نشان می‌دهد که حدس خیلی کم است یا خیلی زیاد. اگر حدس درست باشد، بازی یک پیام تبریک چاپ می‌کند و خارج می‌شود.

### راه‌اندازی پروژه جدید
برای راه‌اندازی یک پروژه جدید، به پوشه `projects` که در فصل اول ایجاد کردید بروید و با استفاده از Cargo یک پروژه جدید بسازید، مانند این:

```bash
$ cargo new guessing_game
$ cd guessing_game
```

دستور اول، `cargo new`، نام پروژه (`guessing_game`) را به‌عنوان آرگومان اول می‌گیرد. دستور دوم به پوشه پروژه جدید می‌رود.

فایل تولیدشده `Cargo.toml` را ببینید:

**نام فایل:** `Cargo.toml`

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
```

همان‌طور که در فصل اول دیدید، `cargo new` یک برنامه «Hello, world!» برای شما تولید می‌کند. فایل `src/main.rs` را بررسی کنید:

**نام فایل:** `src/main.rs`

```rust
fn main() {
    println!("Hello, world!");
}
```

حالا بیایید این برنامه «Hello, world!» را با استفاده از دستور `cargo run` در یک مرحله کامپایل و اجرا کنیم:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `file:///projects/guessing_game/target/debug/guessing_game`
Hello, world!
```

دستور `run` وقتی نیاز دارید به‌سرعت روی پروژه‌ای تکرار کنید، مانند این بازی، بسیار مفید است، زیرا هر تکرار را سریع آزمایش می‌کنید قبل از رفتن به تکرار بعدی.

فایل `src/main.rs` را دوباره باز کنید. تمام کد را در این فایل خواهید نوشت.

### پردازش یک حدس
بخش اول برنامه بازی حدس از کاربر ورودی می‌گیرد، آن ورودی را پردازش می‌کند و بررسی می‌کند که ورودی به شکل مورد انتظار است. برای شروع، به بازیکن اجازه می‌دهیم یک حدس وارد کند. کد زیر را در لیست ۲-۱ به `src/main.rs` وارد کنید.

**نام فایل:** `src/main.rs`

```rust
use std::io;

fn main() {
    println!("عدد را حدس بزن!");

    println!("لطفاً حدس خود را وارد کنید.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("خطا در خواندن خط");

    println!("شما حدس زدید: {}", guess);
}
```

**لیست ۲-۱:** کدی که حدس را از کاربر می‌گیرد و آن را چاپ می‌کند

این کد اطلاعات زیادی دارد، پس بیایید خط به خط آن را بررسی کنیم. برای دریافت ورودی کاربر و سپس چاپ نتیجه به‌عنوان خروجی، باید کتابخانه ورودی/خروجی `io` را به محدوده (scope) بیاوریم. کتابخانه `io` از کتابخانه استاندارد، معروف به `std`، می‌آید:

```rust
use std::io;
```

به‌طور پیش‌فرض، Rust مجموعه‌ای از آیتم‌های تعریف‌شده در کتابخانه استاندارد را به محدوده هر برنامه می‌آورد. این مجموعه به نام *prelude* شناخته می‌شود، و می‌توانید همه‌چیز در آن را در مستندات کتابخانه استاندارد ببینید.

اگر نوعی که می‌خواهید استفاده کنید در prelude نیست، باید آن نوع را با یک عبارت `use` صراحتاً به محدوده بیاورید. استفاده از کتابخانه `std::io` ویژگی‌های مفیدی از جمله توانایی پذیرش ورودی کاربر را به شما می‌دهد.

همان‌طور که در فصل اول دیدید، تابع `main` نقطه ورود به برنامه است:

```rust
fn main() {
```

نحو `fn` یک تابع جدید اعلان می‌کند؛ پرانتزها، `()`، نشان می‌دهند که هیچ پارامتری وجود ندارد؛ و کروشه باز، `{`، بدنه تابع را شروع می‌کند.

همچنین در فصل اول آموختید که `println!` یک ماکرو است که رشته‌ای را روی صفحه چاپ می‌کند:

```rust
    println!("عدد را حدس بزن!");

    println!("لطفاً حدس خود را وارد کنید.");
```

این کد یک اعلان چاپ می‌کند که بازی چیست و از کاربر درخواست ورودی می‌کند.

### ذخیره مقادیر با متغیرها
بعد، یک متغیر برای ذخیره ورودی کاربر ایجاد می‌کنیم، مانند این:

```rust
    let mut guess = String::new();
```

حالا برنامه جالب‌تر می‌شود! در این خط کوچک اتفاقات زیادی رخ می‌دهد. ما از عبارت `let` برای ایجاد متغیر استفاده می‌کنیم. مثال دیگری این است:

```rust
let apples = 5;
```

این خط یک متغیر جدید به نام `apples` ایجاد می‌کند و آن را به مقدار ۵ متصل می‌کند. در Rust، متغیرها به‌طور پیش‌فرض غیرقابل‌تغییر (immutable) هستند، به این معنی که وقتی به متغیر مقداری می‌دهیم، آن مقدار تغییر نمی‌کند. ما این مفهوم را در بخش «متغیرها و تغییرپذیری» در فصل سوم با جزئیات بحث خواهیم کرد. برای اینکه متغیر قابل‌تغییر (mutable) شود، قبل از نام متغیر `mut` اضافه می‌کنیم:

```rust
let apples = 5; // غیرقابل‌تغییر
let mut bananas = 5; // قابل‌تغییر
```

> **توجه:** نحو `//` یک کامنت را شروع می‌کند که تا پایان خط ادامه دارد. Rust هر چیزی در کامنت‌ها را نادیده می‌گیرد. درباره کامنت‌ها در فصل سوم بیشتر بحث خواهیم کرد.

**توضیح اضافی:** کامنت‌ها در Rust برای توضیح کد یا غیرفعال کردن موقت بخشی از کد استفاده می‌شوند و تأثیری در اجرای برنامه ندارند.

برگردیم به برنامه بازی حدس، حالا می‌دانید که `let mut guess` یک متغیر قابل‌تغییر به نام `guess` معرفی می‌کند. علامت مساوی (`=`) به Rust می‌گوید که می‌خواهیم چیزی را به متغیر متصل کنیم. در سمت راست علامت مساوی، مقداری است که `guess` به آن متصل می‌شود، که نتیجه فراخوانی `String::new` است، تابعی که یک نمونه جدید از `String` برمی‌گرداند. `String` یک نوع رشته‌ای است که توسط کتابخانه استاندارد ارائه شده و یک متن قابل‌رشد، کدگذاری‌شده با UTF-8 است.

نحو `::` در خط `::new` نشان می‌دهد که `new` یک تابع مرتبط (associated function) از نوع `String` است. تابع مرتبط، تابعی است که روی یک نوع، در اینجا `String`، پیاده‌سازی شده است. این تابع `new` یک رشته جدید و خالی ایجاد می‌کند. تابع `new` را در بسیاری از نوع‌ها خواهید یافت، زیرا نام رایجی برای تابعی است که یک مقدار جدید از نوعی می‌سازد.

به‌طور کامل، خط `let mut guess = String::new();` یک متغیر قابل‌تغییر ایجاد کرده که در حال حاضر به یک نمونه جدید و خالی از `String` متصل است. عجب!

### دریافت ورودی کاربر
به یاد بیاورید که با `use std::io;` در خط اول برنامه، قابلیت ورودی/خروجی را از کتابخانه استاندارد وارد کردیم. حالا تابع `stdin` را از ماژول `io` فراخوانی می‌کنیم، که به ما امکان مدیریت ورودی کاربر را می‌دهد:

```rust
    io::stdin()
        .read_line(&mut guess)
```

اگر ماژول `io` را با `use std::io;` در ابتدای برنامه وارد نکرده بودیم، می‌توانستیم این فراخوانی تابع را به‌صورت `std::io::stdin` بنویسیم. تابع `stdin` یک نمونه از `std::io::Stdin` برمی‌گرداند، که نوعی است که دسته‌ای (handle) به ورودی استاندارد ترمینال شما را نشان می‌دهد.

خط بعدی، `.read_line(&mut guess)`، متد `read_line` را روی دسته ورودی استاندارد فراخوانی می‌کند تا ورودی را از کاربر بگیرد. ما همچنین `&mut guess` را به‌عنوان آرگومان به `read_line` پاس می‌دهیم تا بگوییم ورودی کاربر در کدام رشته ذخیره شود. وظیفه کامل `read_line` این است که هر چیزی که کاربر در ورودی استاندارد تایپ می‌کند را بگیرد و آن را به یک رشته اضافه کند (بدون بازنویسی محتوای آن)، بنابراین ما این رشته را به‌عنوان آرگومان پاس می‌دهیم. آرگومان رشته باید قابل‌تغییر باشد تا متد بتواند محتوای رشته را تغییر دهد.

علامت `&` نشان می‌دهد که این آرگومان یک ارجاع (reference) است، که راهی برای دسترسی چندین بخش از کد شما به یک قطعه داده بدون نیاز به کپی چندباره آن داده در حافظه فراهم می‌کند. ارجاع‌ها یک ویژگی پیچیده هستند، و یکی از مزایای اصلی Rust ایمنی و سهولت استفاده از ارجاع‌هاست. برای تکمیل این برنامه نیازی به دانستن جزئیات زیاد درباره آن‌ها ندارید. فعلاً فقط باید بدانید که، مانند متغیرها، ارجاع‌ها به‌طور پیش‌فرض غیرقابل‌تغییر هستند. بنابراین، باید `&mut guess` را به‌جای `&guess` بنویسیم تا قابل‌تغییر باشد. (فصل چهارم ارجاع‌ها را با جزئیات بیشتری توضیح خواهد داد.)

### مدیریت شکست احتمالی با Result
ما هنوز روی این خط کد کار می‌کنیم. حالا درباره خط سوم متن بحث می‌کنیم، اما توجه کنید که هنوز بخشی از یک خط منطقی کد است. بخش بعدی این متد است:

```rust
        .expect("خطا در خواندن خط");
```

می‌توانستیم این کد را به‌صورت زیر بنویسیم:

```rust
io::stdin().read_line(&mut guess).expect("خطا در خواندن خط");
```

اما یک خط طولانی خواندن را دشوار می‌کند، بنابراین بهتر است آن را تقسیم کنیم. وقتی با نحو `.method_name()` متدی را فراخوانی می‌کنید، اغلب عاقلانه است که خط جدید و فضای خالی اضافه کنید تا خطوط طولانی را بشکنید. حالا بیایید ببینیم این خط چه می‌کند.

همان‌طور که قبلاً ذکر شد، `read_line` هر چیزی که کاربر وارد می‌کند را در رشته‌ای که به آن پاس می‌دهیم قرار می‌دهد، اما همچنین یک مقدار `Result` برمی‌گرداند. `Result` یک شمارش (enumeration)، که اغلب به آن enum می‌گویند، است، نوعی که می‌تواند در یکی از چندین حالت ممکن باشد. ما به هر حالت ممکن یک واریانت (variant) می‌گوییم.

فصل ششم enumها را با جزئیات بیشتری پوشش خواهد داد. هدف از نوع‌های `Result` کدگذاری اطلاعات مدیریت خطاست.

واریانت‌های `Result` شامل `Ok` و `Err` هستند. واریانت `Ok` نشان می‌دهد عملیات موفق بوده و حاوی مقدار تولیدشده با موفقیت است. واریانت `Err` یعنی عملیات شکست خورده و حاوی اطلاعاتی درباره چگونگی یا چرایی شکست است.

مقادیر نوع `Result`، مانند مقادیر هر نوع دیگری، متدهایی دارند که روی آن‌ها تعریف شده‌اند. یک نمونه از `Result` متد `expect` دارد که می‌توانید آن را فراخوانی کنید. اگر این نمونه از `Result` یک مقدار `Err` باشد، `expect` باعث می‌شود برنامه خراب شود و پیامی که به‌عنوان آرگومان به `expect` پاس داده‌اید را نمایش دهد. اگر متد `read_line` یک `Err` برگرداند، احتمالاً نتیجه خطایی از سیستم‌عامل زیرین است. اگر این نمونه از `Result` یک مقدار `Ok` باشد، `expect` مقدار بازگشتی که `Ok` نگه داشته را می‌گیرد و فقط آن مقدار را به شما برمی‌گرداند تا بتوانید از آن استفاده کنید. در این مورد، آن مقدار تعداد بایت‌های ورودی کاربر است.

اگر `expect` را فراخوانی نکنید، برنامه کامپایل می‌شود، اما یک هشدار دریافت خواهید کرد:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
```

Rust هشدار می‌دهد که شما از مقدار `Result` برگشتی از `read_line` استفاده نکرده‌اید، که نشان می‌دهد برنامه یک خطای ممکن را مدیریت نکرده است.

راه درست برای سرکوب این هشدار نوشتن کد مدیریت خطاست، اما در مورد ما فقط می‌خواهیم وقتی مشکلی رخ می‌دهد برنامه خراب شود، بنابراین می‌توانیم از `expect` استفاده کنیم. درباره بازیابی از خطاها در فصل نهم خواهید آموخت.

### چاپ مقادیر با جایگاه‌های `println!`
به‌جز کروشه بسته، فقط یک خط دیگر در کد تا اینجا برای بحث باقی مانده است:

```rust
    println!("شما حدس زدید: {}", guess);
```

این خط رشته‌ای را که حالا حاوی ورودی کاربر است چاپ می‌کند. کروشه‌های `{}` یک جایگاه‌دار (placeholder) هستند: `{}` را مانند چنگال‌های کوچک خرچنگ تصور کنید که یک مقدار را در جای خود نگه می‌دارند. وقتی مقدار یک متغیر را چاپ می‌کنید، نام متغیر می‌تواند داخل کروشه‌ها قرار گیرد. وقتی نتیجه ارزیابی یک عبارت را چاپ می‌کنید، کروشه‌های خالی را در رشته فرمت قرار دهید، سپس رشته فرمت را با لیستی از عبارات جدا شده با کاما دنبال کنید تا در هر جایگاه‌دار کروشه خالی به همان ترتیب چاپ شوند. چاپ یک متغیر و نتیجه یک عبارت در یک فراخوانی `println!` به این شکل است:

```rust
let x = 5;
let y = 10;

println!("x = {x} و y + 2 = {}", y + 2);
```

این کد `x = 5 و y + 2 = 12` را چاپ می‌کند.

### آزمایش بخش اول
بیایید بخش اول بازی حدس را آزمایش کنیم. آن را با استفاده از `cargo run` اجرا کنید:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
لطفاً حدس خود را وارد کنید.
6
شما حدس زدید: 6
```

در این مرحله، بخش اول بازی تمام شده است: ما ورودی را از کیبورد می‌گیریم و سپس آن را چاپ می‌کنیم.

### تولید یک عدد مخفی
بعد، باید یک عدد مخفی تولید کنیم که کاربر سعی کند آن را حدس بزند. عدد مخفی باید هر بار متفاوت باشد تا بازی بیش از یک بار سرگرم‌کننده باشد. ما از یک عدد تصادفی بین ۱ تا ۱۰۰ استفاده می‌کنیم تا بازی خیلی دشوار نباشد. Rust هنوز قابلیت تولید عدد تصادفی را در کتابخانه استاندارد خود شامل نکرده است. با این حال، تیم Rust یک crate به نام `rand` با این قابلیت ارائه می‌دهد.

### استفاده از یک Crate برای قابلیت بیشتر
به یاد بیاورید که یک crate مجموعه‌ای از فایل‌های کد منبع Rust است. پروژه‌ای که ساخته‌ایم یک crate باینری است، که یک فایل اجرایی است. crate `rand` یک crate کتابخانه‌ای است، که شامل کدی است که برای استفاده در برنامه‌های دیگر در نظر گرفته شده و نمی‌تواند به‌تنهایی اجرا شود.

هماهنگی Cargo با crateهای خارجی جایی است که Cargo واقعاً می‌درخشد. قبل از اینکه بتوانیم کدی بنویسیم که از `rand` استفاده کند، باید فایل `Cargo.toml` را اصلاح کنیم تا crate `rand` را به‌عنوان یک وابستگی شامل کنیم. حالا آن فایل را باز کنید و خط زیر را در پایین، زیر عنوان بخش `[dependencies]` که Cargo برای شما ایجاد کرده، اضافه کنید. مطمئن شوید که `rand` را دقیقاً همان‌طور که اینجا مشخص کرده‌ایم، با این شماره نسخه، وارد کنید، وگرنه مثال‌های کد در این آموزش ممکن است کار نکنند:

**نام فایل:** `Cargo.toml`

```toml
[dependencies]
rand = "0.8.5"
```

در فایل `Cargo.toml`، هر چیزی که بعد از یک عنوان می‌آید بخشی از آن بخش است که تا شروع بخش بعدی ادامه دارد. در `[dependencies]` به Cargo می‌گویید پروژه شما به کدام crateهای خارجی وابسته است و به کدام نسخه‌های آن crateها نیاز دارید. در این مورد، ما crate `rand` را با مشخص‌کننده نسخه معنایی `0.8.5` مشخص می‌کنیم. Cargo نسخه‌بندی معنایی (Semantic Versioning یا گاهی SemVer) را درک می‌کند، که استانداردی برای نوشتن شماره‌های نسخه است. مشخص‌کننده `0.8.5` در واقع مخفف `^0.8.5` است، که به این معنی است هر نسخه‌ای که حداقل `0.8.5` باشد اما زیر `0.9.0`.

Cargo این نسخه‌ها را دارای API عمومی سازگار با نسخه `0.8.5` می‌داند، و این مشخصات تضمین می‌کند که آخرین نسخه پچ را دریافت خواهید کرد که همچنان با کد این فصل کامپایل می‌شود. هر نسخه `0.9.0` یا بالاتر تضمین نمی‌شود که همان API را داشته باشد که مثال‌های بعدی استفاده می‌کنند.

حالا، بدون تغییر هیچ‌کدام از کدها، بیایید پروژه را بسازیم، همان‌طور که در لیست ۲-۲ نشان داده شده است.

```bash
$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
```

**لیست ۲-۲:** خروجی از اجرای `cargo build` پس از افزودن crate `rand` به‌عنوان وابستگی

ممکن است شماره‌های نسخه متفاوتی ببینید (اما همه آن‌ها با کد سازگار خواهند بود، به لطف SemVer!) و خطوط متفاوتی (بسته به سیستم‌عامل)، و خطوط ممکن است به ترتیب متفاوتی باشند.

وقتی یک وابستگی خارجی را شامل می‌کنیم، Cargo آخرین نسخه‌های هر چیزی که آن وابستگی نیاز دارد را از رجیستری، که کپی‌ای از داده‌های Crates.io است، دریافت می‌کند. Crates.io جایی است که افراد در اکوسیستم Rust پروژه‌های منبع‌باز Rust خود را برای استفاده دیگران قرار می‌دهند.

پس از به‌روزرسانی رجیستری، Cargo بخش `[dependencies]` را بررسی می‌کند و هر crate ذکرشده‌ای که قبلاً دانلود نشده را دانلود می‌کند. در این مورد، گرچه ما فقط `rand` را به‌عنوان وابستگی ذکر کردیم، Cargo crateهای دیگری که `rand` برای کار کردن به آن‌ها وابسته است را نیز دریافت کرد. پس از دانلود crateها، Rust آن‌ها را کامپایل می‌کند و سپس پروژه را با وابستگی‌های موجود کامپایل می‌کند.

اگر بلافاصله دوباره `cargo build` را بدون هیچ تغییری اجرا کنید، هیچ خروجی‌ای جز خط `Finished` دریافت نخواهید کرد. Cargo می‌داند که قبلاً وابستگی‌ها را دانلود و کامپایل کرده و شما چیزی درباره آن‌ها در فایل `Cargo.toml` تغییر نداده‌اید. Cargo همچنین می‌داند که شما چیزی در کد خود تغییر نداده‌اید، بنابراین آن را دوباره کامپایل نمی‌کند. چون کاری برای انجام ندارد، به‌سادگی خارج می‌شود.

اگر فایل `src/main.rs` را باز کنید، تغییر جزئی ایجاد کنید، و سپس آن را ذخیره کنید و دوباره بسازید، فقط دو خط خروجی خواهید دید:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
```

این خطوط نشان می‌دهند که Cargo فقط ساخت را با تغییر کوچک شما در فایل `src/main.rs` به‌روزرسانی می‌کند. وابستگی‌های شما تغییر نکرده‌اند، بنابراین Cargo می‌داند که می‌تواند آنچه قبلاً دانلود و کامپایل کرده را دوباره استفاده کند.

### اطمینان از ساخت‌های قابل‌تکرار با فایل `Cargo.lock`
Cargo مکانیزمی دارد که تضمین می‌کند هر بار که شما یا شخص دیگری کد شما را بسازد، همان آرتیفکت را بازسازی کنید: Cargo فقط از نسخه‌های وابستگی‌هایی که شما مشخص کرده‌اید استفاده خواهد کرد تا زمانی که شما چیز دیگری را مشخص کنید. برای مثال، فرض کنید هفته آینده نسخه `0.8.6` از crate `rand` منتشر شود، و آن نسخه شامل یک رفع اشکال مهم باشد، اما همچنین شامل یک رگرسیون که کد شما را خراب می‌کند. برای مدیریت این، Rust فایل `Cargo.lock` را اولین باری که `cargo build` را اجرا می‌کنید ایجاد می‌کند، بنابراین حالا این را در پوشه `guessing_game` داریم.

وقتی برای اولین بار پروژه‌ای را می‌سازید، Cargo تمام نسخه‌های وابستگی‌هایی که با معیارها مطابقت دارند را مشخص می‌کند و سپس آن‌ها را در فایل `Cargo.lock` می‌نویسد. وقتی در آینده پروژه خود را می‌سازید، Cargo می‌بیند که فایل `Cargo.lock` وجود دارد و از نسخه‌های مشخص‌شده در آنجا استفاده می‌کند به‌جای اینکه دوباره تمام کار مشخص کردن نسخه‌ها را انجام دهد. این به شما امکان می‌دهد به‌طور خودکار ساخت قابل‌تکراری داشته باشید. به عبارت دیگر، پروژه شما تا زمانی که صراحتاً ارتقا ندهید در نسخه `0.8.5` باقی می‌ماند، به لطف فایل `Cargo.lock`. چون فایل `Cargo.lock` برای ساخت‌های قابل‌تکرار مهم است، اغلب همراه با بقیه کد پروژه شما در سیستم کنترل منبع چک-این می‌شود.

### به‌روزرسانی یک Crate برای دریافت نسخه جدید
وقتی بخواهید یک crate را به‌روزرسانی کنید، Cargo دستور `update` را ارائه می‌دهد، که فایل `Cargo.lock` را نادیده می‌گیرد و تمام آخرین نسخه‌هایی که با مشخصات شما در `Cargo.toml` مطابقت دارند را مشخص می‌کند. سپس Cargo آن نسخه‌ها را در فایل `Cargo.lock` می‌نویسد. در این مورد، Cargo فقط به دنبال نسخه‌های بزرگ‌تر از `0.8.5` و کمتر از `0.9.0` خواهد بود. اگر crate `rand` دو نسخه جدید `0.8.6` و `0.9.0` منتشر کرده باشد، اگر `cargo update` را اجرا کنید، موارد زیر را خواهید دید:

```bash
$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -> v0.8.6 (available: v0.9.0)
```

Cargo نسخه `0.9.0` را نادیده می‌گیرد. در این مرحله، همچنین متوجه تغییری در فایل `Cargo.lock` خود خواهید شد که نشان می‌دهد نسخه crate `rand` که حالا استفاده می‌کنید `0.8.6` است. برای استفاده از نسخه `0.9.0` یا هر نسخه‌ای در سری `0.9.x`، باید فایل `Cargo.toml` را به این شکل به‌روزرسانی کنید:

```toml
[dependencies]
rand = "0.9.0"
```

دفعه بعدی که `cargo build` را اجرا کنید، Cargo رجیستری crateهای موجود را به‌روزرسانی خواهد کرد و نیازهای `rand` شما را طبق نسخه جدیدی که مشخص کرده‌اید بازنگری می‌کند.

درباره Cargo و اکوسیستم آن چیزهای بیشتری برای گفتن وجود دارد که در فصل چهاردهم بحث خواهیم کرد، اما فعلاً این تمام چیزی است که باید بدانید. Cargo استفاده مجدد از کتابخانه‌ها را بسیار آسان می‌کند، بنابراین Rustaceanها می‌توانند پروژه‌های کوچک‌تری بنویسند که از تعداد زیادی بسته مونتاژ شده‌اند.

### تولید یک عدد تصادفی
بیایید از `rand` استفاده کنیم تا عددی برای حدس زدن تولید کنیم. مرحله بعدی به‌روزرسانی `src/main.rs` است، همان‌طور که در لیست ۲-۳ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
use std::io;
use rand::Rng;

fn main() {
    println!("عدد را حدس بزن!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("عدد مخفی این است: {secret_number}");

    println!("لطفاً حدس خود را وارد کنید.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("خطا در خواندن خط");

    println!("شما حدس زدید: {guess}");
}
```

**لیست ۲-۳:** افزودن کد برای تولید یک عدد تصادفی

ابتدا خط `use rand::Rng;` را اضافه می‌کنیم. trait `Rng` متدهایی را تعریف می‌کند که تولیدکنندگان عدد تصادفی پیاده‌سازی می‌کنند، و این trait باید در محدوده باشد تا بتوانیم از آن متدها استفاده کنیم. فصل دهم traitها را با جزئیات پوشش خواهد داد.

بعد، دو خط در وسط اضافه می‌کنیم. در خط اول، تابع `rand::thread_rng` را فراخوانی می‌کنیم که تولیدکننده عدد تصادفی خاصی را به ما می‌دهد: یکی که محلی برای نخ اجرایی فعلی است و توسط سیستم‌عامل بذرپاشی (seeded) می‌شود. سپس متد `gen_range` را روی تولیدکننده عدد تصادفی فراخوانی می‌کنیم. این متد توسط trait `Rng` تعریف شده که با عبارت `use rand::Rng;` به محدوده آوردیم. متد `gen_range` یک عبارت محدوده به‌عنوان آرگومان می‌گیرد و یک عدد تصادفی در آن محدوده تولید می‌کند. نوع عبارت محدوده‌ای که اینجا استفاده می‌کنیم به شکل `start..=end` است و شامل مرزهای پایین و بالا می‌شود، بنابراین باید `1..=100` را مشخص کنیم تا عددی بین ۱ تا ۱۰۰ درخواست کنیم.

> **توجه:** شما فقط نمی‌دانید کدام traitها را باید استفاده کنید و کدام متدها و توابع را از یک crate فراخوانی کنید، بنابراین هر crate مستنداتی با دستورالعمل‌های استفاده از آن دارد. یک ویژگی جالب دیگر Cargo این است که اجرای دستور `cargo doc --open` مستندات ارائه‌شده توسط تمام وابستگی‌های شما را به‌صورت محلی می‌سازد و در مرورگر شما باز می‌کند. اگر به قابلیت‌های دیگر در crate `rand` علاقه‌مندید، مثلاً، `cargo doc --open` را اجرا کنید و روی `rand` در نوار کناری سمت چپ کلیک کنید.

**توضیح اضافی:** مستندات crateها منبعی کلیدی برای یادگیری نحوه استفاده از قابلیت‌های آن‌ها هستند. دستور `cargo doc --open` به شما امکان می‌دهد به‌سرعت به مستندات آفلاین دسترسی پیدا کنید.

خط دوم جدید عدد مخفی را چاپ می‌کند. این در حین توسعه برنامه برای آزمایش آن مفید است، اما در نسخه نهایی آن را حذف خواهیم کرد. اگر برنامه به‌محض شروع جواب را چاپ کند، بازی چندان جذابی نخواهد بود!

برنامه را چند بار اجرا کنید:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
عدد مخفی این است: 7
لطفاً حدس خود را وارد کنید.
4
شما حدس زدید: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
عدد مخفی این است: 83
لطفاً حدس خود را وارد کنید.
5
شما حدس زدید: 5
```

باید اعداد تصادفی متفاوتی دریافت کنید، و همه آن‌ها باید بین ۱ تا ۱۰۰ باشند. عالیه!

### مقایسه حدس با عدد مخفی
حالا که ورودی کاربر و یک عدد تصادفی داریم، می‌توانیم آن‌ها را مقایسه کنیم. این مرحله در لیست ۲-۴ نشان داده شده است. توجه کنید که این کد هنوز کامپایل نمی‌شود، همان‌طور که توضیح خواهیم داد.

**نام فایل:** `src/main.rs`

**این کد کامپایل نمی‌شود!**

```rust
use std::cmp::Ordering;
use std::io;
use rand::Rng;

fn main() {
    // --snip--

    println!("شما حدس زدید: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("خیلی کمه!"),
        Ordering::Greater => println!("خیلی زیاده!"),
        Ordering::Equal => println!("شما بردید!"),
    }
}
```

**لیست ۲-۴:** مدیریت مقادیر بازگشتی ممکن از مقایسه دو عدد

ابتدا یک عبارت `use` دیگر اضافه می‌کنیم، که نوع `std::cmp::Ordering` را از کتابخانه استاندارد به محدوده می‌آورد. نوع `Ordering` یک enum دیگر است و واریانت‌های `Less`، `Greater` و `Equal` دارد. این‌ها سه نتیجه ممکن هنگام مقایسه دو مقدار هستند.

سپس پنج خط جدید در پایین اضافه می‌کنیم که از نوع `Ordering` استفاده می‌کنند. متد `cmp` دو مقدار را مقایسه می‌کند و می‌توان آن را روی هر چیزی که قابل‌مقایسه باشد فراخوانی کرد. این متد یک ارجاع به چیزی که می‌خواهید با آن مقایسه کنید می‌گیرد: اینجا `guess` را با `secret_number` مقایسه می‌کند. سپس یک واریانت از enum `Ordering` که با عبارت `use` به محدوده آوردیم برمی‌گرداند. ما از یک عبارت `match` استفاده می‌کنیم تا بر اساس اینکه کدام واریانت `Ordering` از فراخوانی `cmp` با مقادیر `guess` و `secret_number` برگردانده شده، تصمیم بگیریم چه کنیم.

یک عبارت `match` از بازوها (arms) تشکیل شده است. یک بازو شامل یک الگو (pattern) برای تطبیق و کدی است که اگر مقدار داده‌شده به `match` با الگوی آن بازو مطابقت داشته باشد، باید اجرا شود. Rust مقدار داده‌شده به `match` را می‌گیرد و الگوی هر بازو را به‌نوبت بررسی می‌کند. الگوها و ساختار `match` ویژگی‌های قدرتمند Rust هستند: آن‌ها به شما امکان می‌دهند موقعیت‌های مختلفی که کد شما ممکن است با آن‌ها مواجه شود را بیان کنید و مطمئن شوید همه آن‌ها را مدیریت می‌کنید. این ویژگی‌ها در فصل ششم و فصل نوزدهم به‌تفصیل پوشش داده خواهند شد.

بیایید مثالی را با عبارت `match` که اینجا استفاده می‌کنیم بررسی کنیم. فرض کنید کاربر ۵۰ را حدس زده و عدد مخفی تولیدشده تصادفی این بار ۳۸ است.

وقتی کد ۵۰ را با ۳۸ مقایسه می‌کند، متد `cmp` مقدار `Ordering::Greater` را برمی‌گرداند چون ۵۰ بزرگ‌تر از ۳۸ است. عبارت `match` مقدار `Ordering::Greater` را می‌گیرد و بررسی الگوی هر بازو را شروع می‌کند. به الگوی بازوی اول، `Ordering::Less`، نگاه می‌کند و می‌بیند که مقدار `Ordering::Greater` با `Ordering::Less` مطابقت ندارد، بنابراین کد آن بازو را نادیده می‌گیرد و به بازوی بعدی می‌رود. الگوی بازوی بعدی `Ordering::Greater` است، که با `Ordering::Greater` مطابقت دارد! کد مرتبط در آن بازو اجرا می‌شود و `خیلی زیاده!` را روی صفحه چاپ می‌کند. عبارت `match` پس از اولین تطبیق موفق پایان می‌یابد، بنابراین در این سناریو به بازوی آخر نگاه نمی‌کند.

با این حال، کد در لیست ۲-۴ هنوز کامپایل نمی‌شود. بیایید امتحان کنیم:

```bash
$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --> src/main.rs:22:21
    |
22  |     match guess.cmp(&secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&String`, found `&{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&String`
               found reference `&{integer}`
note: method defined here
   --> file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/cmp.rs:964:8
    |
964 |     fn cmp(&self, other: &Self) -> Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
```

هسته خطا بیان می‌کند که نوع‌ها همخوانی ندارند. Rust یک سیستم نوع قوی و ایستا دارد. با این حال، همچنین استنتاج نوع (type inference) دارد. وقتی نوشتیم `let mut guess = String::new()`، Rust توانست استنتاج کند که `guess` باید یک `String` باشد و ما را مجبور به نوشتن نوع نکرد. از سوی دیگر، `secret_number` یک نوع عددی است. چند نوع عددی Rust می‌توانند مقداری بین ۱ تا ۱۰۰ داشته باشند: `i32`، یک عدد ۳۲ بیتی؛ `u32`، یک عدد ۳۲ بیتی بدون علامت؛ `i64`، یک عدد ۶۴ بیتی؛ و غیره. مگر اینکه مشخص شود، Rust به‌طور پیش‌فرض از `i32` استفاده می‌کند، که نوع `secret_number` است مگر اینکه اطلاعات نوع دیگری در جای دیگر اضافه کنید که باعث شود Rust نوع عددی متفاوتی استنتاج کند. دلیل خطا این است که Rust نمی‌تواند یک رشته و یک نوع عددی را مقایسه کند.

در نهایت، می‌خواهیم رشته‌ای که برنامه به‌عنوان ورودی می‌خواند را به یک نوع عددی تبدیل کنیم تا بتوانیم آن را به‌صورت عددی با عدد مخفی مقایسه کنیم. این کار را با افزودن این خط به بدنه تابع `main` انجام می‌دهیم:

**نام فایل:** `src/main.rs`

```rust
    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("خطا در خواندن خط");

    let guess: u32 = guess.trim().parse().expect("لطفاً یک عدد وارد کنید!");

    println!("شما حدس زدید: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("خیلی کمه!"),
        Ordering::Greater => println!("خیلی زیاده!"),
        Ordering::Equal => println!("شما بردید!"),
    }
```

خط موردنظر این است:

```rust
let guess: u32 = guess.trim().parse().expect("لطفاً یک عدد وارد کنید!");
```

ما یک متغیر به نام `guess` ایجاد می‌کنیم. اما صبر کنید، مگر برنامه از قبل متغیری به نام `guess` نداشت؟ بله، اما خوشبختانه Rust به ما اجازه می‌دهد مقدار قبلی `guess` را با یک مقدار جدید سایه (shadow) کنیم. سایه‌زدن به ما امکان می‌دهد نام متغیر `guess` را دوباره استفاده کنیم به‌جای اینکه مجبور شویم دو متغیر منحصربه‌فرد، مانند `guess_str` و `guess`، ایجاد کنیم. این را در فصل سوم با جزئیات بیشتری پوشش خواهیم داد، اما فعلاً بدانید که این ویژگی اغلب وقتی می‌خواهید مقداری را از یک نوع به نوع دیگر تبدیل کنید استفاده می‌شود.

ما این متغیر جدید را به عبارت `guess.trim().parse()` متصل می‌کنیم. `guess` در عبارت به متغیر اصلی `guess` اشاره دارد که ورودی را به‌عنوان یک رشته داشت. متد `trim` روی نمونه `String` هر گونه فضای خالی در ابتدا و انتها را حذف می‌کند، که باید انجام دهیم تا بتوانیم رشته را به `u32` تبدیل کنیم، که فقط می‌تواند داده‌های عددی داشته باشد. کاربر باید کلید enter را فشار دهد تا `read_line` را راضی کند و حدس خود را وارد کند، که یک کاراکتر خط جدید به رشته اضافه می‌کند. برای مثال، اگر کاربر ۵ را تایپ کند و enter را فشار دهد، `guess` به این شکل خواهد بود: `5\n`. کاراکتر `\n` نشان‌دهنده «خط جدید» است. (در ویندوز، فشار دادن enter یک بازگشت واگن و خط جدید، `\r\n`، ایجاد می‌کند.) متد `trim` `\n` یا `\r\n` را حذف می‌کند و فقط ۵ باقی می‌ماند.

متد `parse` روی رشته‌ها یک رشته را به نوع دیگری تبدیل می‌کند. اینجا، ما از آن برای تبدیل از رشته به عدد استفاده می‌کنیم. باید به Rust نوع دقیق عددی که می‌خواهیم را با استفاده از `let guess: u32` بگوییم. دو نقطه (`:`) بعد از `guess` به Rust می‌گوید که نوع متغیر را حاشیه‌نویسی (annotate) خواهیم کرد. Rust چند نوع عددی داخلی دارد؛ `u32` که اینجا می‌بینید یک عدد صحیح ۳۲ بیتی بدون علامت است. این یک انتخاب پیش‌فرض خوب برای یک عدد مثبت کوچک است. درباره نوع‌های عددی دیگر در فصل سوم خواهید آموخت.

علاوه بر این، حاشیه‌نویسی `u32` در این برنامه نمونه و مقایسه با `secret_number` به این معنی است که Rust استنتاج خواهد کرد که `secret_number` نیز باید `u32` باشد. بنابراین حالا مقایسه بین دو مقدار از یک نوع خواهد بود!

متد `parse` فقط روی کاراکترهایی کار می‌کند که به‌طور منطقی می‌توانند به اعداد تبدیل شوند و بنابراین به‌راحتی می‌تواند باعث خطا شود. اگر، برای مثال، رشته شامل `A👍%` باشد، هیچ راهی برای تبدیل آن به عدد وجود ندارد. چون ممکن است شکست بخورد، متد `parse` یک نوع `Result` برمی‌گرداند، دقیقاً مانند متد `read_line` (که قبلاً در «مدیریت شکست احتمالی با Result» بحث کردیم). ما این `Result` را به همان روش با استفاده دوباره از متد `expect` مدیریت خواهیم کرد. اگر `parse` یک واریانت `Err` از `Result` برگرداند چون نتوانسته رشته را به عدد تبدیل کند، فراخوانی `expect` بازی را خراب می‌کند و پیامی که به آن می‌دهیم را چاپ می‌کند. اگر `parse` بتواند با موفقیت رشته را به عدد تبدیل کند، واریانت `Ok` از `Result` را برمی‌گرداند، و `expect` عددی که می‌خواهیم را از مقدار `Ok` برمی‌گرداند.

حالا برنامه را اجرا کنیم:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
عدد مخفی این است: 58
لطفاً حدس خود را وارد کنید.
  76
شما حدس زدید: 76
خیلی زیاده!
```

عالیه! حتی با وجود اینکه قبل از حدس فاصله‌هایی اضافه شده بود، برنامه همچنان تشخیص داد که کاربر ۷۶ را حدس زده است. برنامه را چند بار اجرا کنید تا رفتارهای مختلف با ورودی‌های متفاوت را تأیید کنید: عدد را درست حدس بزنید، عددی که خیلی زیاد است حدس بزنید، و عددی که خیلی کم است حدس بزنید.

حالا بخش زیادی از بازی کار می‌کند، اما کاربر فقط می‌تواند یک حدس بزند. بیایید با افزودن یک حلقه این را تغییر دهیم!

### اجازه دادن به حدس‌های متعدد با حلقه
کلمه‌کلیدی `loop` یک حلقه بی‌نهایت ایجاد می‌کند. ما یک حلقه اضافه خواهیم کرد تا به کاربران شانس‌های بیشتری برای حدس زدن عدد بدهیم:

**نام فایل:** `src/main.rs`

```rust
    // --snip--

    println!("عدد مخفی این است: {secret_number}");

    loop {
        println!("لطفاً حدس خود را وارد کنید.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("خیلی کمه!"),
            Ordering::Greater => println!("خیلی زیاده!"),
            Ordering::Equal => println!("شما بردید!"),
        }
    }
}
```

همان‌طور که می‌بینید، همه‌چیز را از اعلان ورودی حدس به بعد به یک حلقه منتقل کرده‌ایم. مطمئن شوید که خطوط داخل حلقه را چهار فاصله دیگر تورفتگی (indent) کنید و برنامه را دوباره اجرا کنید. حالا برنامه برای همیشه درخواست حدس دیگری خواهد کرد، که در واقع یک مشکل جدید ایجاد می‌کند. به نظر نمی‌رسد کاربر بتواند خارج شود!

کاربر همیشه می‌تواند با استفاده از میانبر کیبورد `ctrl-c` برنامه را قطع کند. اما راه دیگری برای فرار از این هیولای سیری‌ناپذیر وجود دارد، همان‌طور که در بحث `parse` در «مقایسه حدس با عدد مخفی» ذکر شد: اگر کاربر پاسخی غیرعددی وارد کند، برنامه خراب خواهد شد. ما می‌توانیم از این برای اجازه دادن به کاربر برای خروج استفاده کنیم، همان‌طور که اینجا نشان داده شده است:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
عدد مخفی این است: 59
لطفاً حدس خود را وارد کنید.
45
شما حدس زدید: 45
خیلی کمه!
لطفاً حدس خود را وارد کنید.
60
شما حدس زدید: 60
خیلی زیاده!
لطفاً حدس خود را وارد کنید.
59
شما حدس زدید: 59
شما بردید!
لطفاً حدس خود را وارد کنید.
quit

thread 'main' panicked at src/main.rs:28:47:
لطفاً یک عدد وارد کنید!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

تایپ `quit` بازی را خارج می‌کند، اما همان‌طور که متوجه خواهید شد، هر ورودی غیرعددی دیگری هم همین کار را می‌کند. این به‌هیچ‌وجه بهینه نیست؛ ما می‌خواهیم بازی وقتی عدد درست حدس زده می‌شود نیز متوقف شود.

### خروج پس از حدس درست
بیایید بازی را طوری برنامه‌ریزی کنیم که وقتی کاربر برنده می‌شود با افزودن یک عبارت `break` خارج شود:

**نام فایل:** `src/main.rs`

```rust
        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("خیلی کمه!"),
            Ordering::Greater => println!("خیلی زیاده!"),
            Ordering::Equal => {
                println!("شما بردید!");
                break;
            }
        }
    }
}
```

افزودن خط `break` بعد از `شما بردید!` باعث می‌شود وقتی کاربر عدد مخفی را درست حدس می‌زند، برنامه از حلقه خارج شود. خروج از حلقه همچنین به این معنی است که از برنامه خارج می‌شود، چون حلقه آخرین بخش `main` است.

### مدیریت ورودی نامعتبر
برای بهبود بیشتر رفتار بازی، به‌جای خراب کردن برنامه وقتی کاربر یک غیرعدد وارد می‌کند، بیایید بازی را طوری کنیم که یک غیرعدد را نادیده بگیرد تا کاربر بتواند به حدس زدن ادامه دهد. می‌توانیم این کار را با تغییر خطی که `guess` از یک `String` به یک `u32` تبدیل می‌شود انجام دهیم، همان‌طور که در لیست ۲-۵ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
        // --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("خطا در خواندن خط");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("شما حدس زدید: {guess}");

        // --snip--
```

**لیست ۲-۵:** نادیده گرفتن حدس غیرعددی و درخواست حدس دیگری به‌جای خراب کردن برنامه

ما از فراخوانی `expect` به یک عبارت `match` تغییر می‌کنیم تا از خراب شدن در خطا به مدیریت خطا برویم. به یاد بیاورید که `parse` یک نوع `Result` برمی‌گرداند و `Result` یک enum است که واریانت‌های `Ok` و `Err` دارد. ما اینجا از یک عبارت `match` استفاده می‌کنیم، همان‌طور که با نتیجه `Ordering` از متد `cmp` کردیم.

اگر `parse` بتواند با موفقیت رشته را به یک عدد تبدیل کند، یک مقدار `Ok` برمی‌گرداند که حاوی عدد حاصل است. آن مقدار `Ok` با الگوی بازوی اول مطابقت خواهد داشت، و عبارت `match` فقط مقدار `num` که `parse` تولید کرده و داخل مقدار `Ok` قرار داده را برمی‌گرداند. آن عدد دقیقاً جایی که می‌خواهیم در متغیر جدید `guess` که ایجاد می‌کنیم قرار خواهد گرفت.

اگر `parse` نتواند رشته را به یک عدد تبدیل کند، یک مقدار `Err` برمی‌گرداند که حاوی اطلاعات بیشتری درباره خطاست. مقدار `Err` با الگوی `Ok(num)` در بازوی اول `match` مطابقت ندارد، اما با الگوی `Err(_)` در بازوی دوم مطابقت دارد. زیرخط، `_`، یک مقدار گیر-همه (catch-all) است؛ در این مثال، ما می‌گوییم که می‌خواهیم تمام مقادیر `Err` را مطابقت دهیم، صرف‌نظر از اینکه چه اطلاعاتی داخل آن‌ها دارند. بنابراین برنامه کد بازوی دوم، `continue`، را اجرا خواهد کرد، که به برنامه می‌گوید به تکرار بعدی حلقه برود و یک حدس دیگر بخواهد. به این ترتیب، برنامه به‌طور مؤثر تمام خطاهایی که `parse` ممکن است با آن‌ها مواجه شود را نادیده می‌گیرد!

حالا همه‌چیز در برنامه باید همان‌طور که انتظار می‌رود کار کند. بیایید امتحان کنیم:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
عدد را حدس بزن!
عدد مخفی این است: 61
لطفاً حدس خود را وارد کنید.
10
شما حدس زدید: 10
خیلی کمه!
لطفاً حدس خود را وارد کنید.
99
شما حدس زدید: 99
خیلی زیاده!
لطفاً حدس خود را وارد کنید.
foo
لطفاً حدس خود را وارد کنید.
61
شما حدس زدید: 61
شما بردید!
```

عالیه! با یک تغییر کوچک نهایی، بازی حدس را تمام خواهیم کرد. به یاد بیاورید که برنامه هنوز عدد مخفی را چاپ می‌کند. این برای آزمایش خوب کار کرد، اما بازی را خراب می‌کند. بیایید `println!` که عدد مخفی را خروجی می‌دهد حذف کنیم. لیست ۲-۶ کد نهایی را نشان می‌دهد.

**نام فایل:** `src/main.rs`

```rust
use std::cmp::Ordering;
use std::io;
use rand::Rng;

fn main() {
    println!("عدد را حدس بزن!");
    let secret_number = rand::thread_rng().gen_range(1..=100);
    loop {
        println!("لطفاً حدس خود را وارد کنید.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("خطا در خواندن خط");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("شما حدس زدید: {guess}");
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("خیلی کمه!"),
            Ordering::Greater => println!("خیلی زیاده!"),
            Ordering::Equal => {
                println!("شما بردید!");
                break;
            }
        }
    }
}
```

**لیست ۲-۶:** کد کامل بازی حدس

در این مرحله، شما با موفقیت بازی حدس را ساخته‌اید. تبریک می‌گویم!

### خلاصه
این پروژه راهی عملی برای معرفی شما به بسیاری از مفاهیم جدید Rust بود: `let`، `match`، توابع، استفاده از crateهای خارجی، و غیره. در چند فصل بعدی، درباره این مفاهیم با جزئیات بیشتری خواهید آموخت. فصل سوم مفاهیمی را پوشش می‌دهد که اکثر زبان‌های برنامه‌نویسی دارند، مانند متغیرها، نوع‌های داده، و توابع، و نشان می‌دهد چگونه از آن‌ها در Rust استفاده کنید. فصل چهارم مالکیت (ownership) را کاوش می‌کند، ویژگی‌ای که Rust را از دیگر زبان‌ها متمایز می‌کند. فصل پنجم درباره structها و نحو متد بحث می‌کند، و فصل ششم توضیح می‌دهد که enumها چگونه کار می‌کنند.

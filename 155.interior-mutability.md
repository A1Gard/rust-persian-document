# الگوی تغییرپذیری داخلی و `RefCell<T>`

الگوی **تغییرپذیری داخلی** (Interior Mutability) در زبان Rust به شما امکان می‌دهد داده‌ها را حتی زمانی که ارجاعات غیرقابل تغییر به آن‌ها وجود دارد، تغییر دهید. به‌طور معمول، قوانین قرض‌گیری (borrowing rules) این کار را ممنوع می‌کنند. این الگو از کدهای ناامن (unsafe code) در داخل یک ساختار داده استفاده می‌کند تا قوانین معمول Rust در مورد تغییرپذیری و قرض‌گیری را دور بزند. کد ناامن به کامپایلر نشان می‌دهد که ما خودمان قوانین را بررسی می‌کنیم و به جای تکیه بر کامپایلر، مسئولیت صحت آن‌ها را بر عهده می‌گیریم. در فصل بیستم، بیشتر درباره کدهای ناامن صحبت خواهیم کرد.

انواع داده‌ای که از الگوی تغییرپذیری داخلی استفاده می‌کنند، تنها زمانی قابل استفاده‌اند که بتوانیم اطمینان حاصل کنیم قوانین قرض‌گیری در زمان اجرا (runtime) رعایت می‌شوند، حتی اگر کامپایلر نتواند این موضوع را تضمین کند. کد ناامن در یک API امن (safe API) پیچیده شده و نوع بیرونی همچنان غیرقابل تغییر (immutable) باقی می‌ماند.

برای بررسی این مفهوم، نوع `RefCell<T>` را که از الگوی تغییرپذیری داخلی پیروی می‌کند، مورد مطالعه قرار می‌دهیم.

## اعمال قوانین قرض‌گیری در زمان اجرا با `RefCell<T>`

برخلاف `Rc<T>` که امکان مالکیت چندگانه را فراهم می‌کند، نوع `RefCell<T>` نشان‌دهنده مالکیت واحد (single ownership) بر داده‌هایی است که نگه می‌دارد. پس چه چیزی `RefCell<T>` را از نوع‌هایی مثل `Box<T>` متمایز می‌کند؟ قوانین قرض‌گیری که در فصل چهارم آموختید را به خاطر بیاورید:

- در هر لحظه، می‌توانید **یا** یک ارجاع قابل تغییر (mutable reference) **یا** هر تعداد ارجاع غیرقابل تغییر (immutable reference) داشته باشید، اما نه هر دو.
- ارجاعات همیشه باید معتبر باشند.

با ارجاعات معمولی و `Box<T>`، این قوانین در زمان کامپایل (compile time) بررسی می‌شوند. اما با `RefCell<T>`، این قوانین در زمان اجرا (runtime) اعمال می‌شوند. اگر با ارجاعات معمولی این قوانین را نقض کنید، خطای کامپایل دریافت می‌کنید. اما با `RefCell<T>`، اگر قوانین را نقض کنید، برنامه شما با خطای **پنیک** (panic) متوقف می‌شود.

### مزایای بررسی قوانین در زمان کامپایل

بررسی قوانین قرض‌گیری در زمان کامپایل باعث می‌شود:
- خطاها زودتر در فرآیند توسعه شناسایی شوند.
- هیچ تأثیری بر عملکرد زمان اجرا وجود نداشته باشد، زیرا تمام تحلیل‌ها از قبل انجام شده‌اند.

به همین دلایل، بررسی قوانین در زمان کامپایل در اکثر موارد بهترین انتخاب است و به همین دلیل این روش پیش‌فرض Rust است.

### مزایای بررسی قوانین در زمان اجرا

بررسی قوانین قرض‌گیری در زمان اجرا امکان سناریوهای ایمن از نظر حافظه را فراهم می‌کند که در بررسی‌های زمان کامپایل ممنوع شده‌اند. تحلیل استاتیک، مانند آنچه کامپایلر Rust انجام می‌دهد، ذاتاً محافظه‌کارانه است. برخی ویژگی‌های کد را نمی‌توان با تحلیل کد تشخیص داد. معروف‌ترین مثال، مسئله توقف (Halting Problem) است که خارج از محدوده این کتاب است اما موضوع جالبی برای تحقیق است.

چون برخی تحلیل‌ها غیرممکن است، اگر کامپایلر Rust نتواند مطمئن شود که کد شما با قوانین مالکیت سازگار است، ممکن است یک برنامه درست را رد کند؛ این رویکرد محافظه‌کارانه است. اگر Rust یک برنامه نادرست را بپذیرد، کاربران نمی‌توانند به تضمین‌های ایمنی Rust اعتماد کنند. اما اگر Rust یک برنامه درست را رد کند، برنامه‌نویس ممکن است اذیت شود، ولی هیچ فاجعه‌ای رخ نمی‌دهد. نوع `RefCell<T>` زمانی مفید است که مطمئن هستید کدتان قوانین قرض‌گیری را رعایت می‌کند، اما کامپایلر نمی‌تواند این را درک یا تضمین کند.

> **توجه**: مشابه `Rc<T>`، نوع `RefCell<T>` فقط برای سناریوهای تک‌رشته‌ای (single-threaded) مناسب است و اگر در محیط چندرشته‌ای استفاده شود، خطای زمان کامپایل می‌دهد. در فصل شانزدهم، نحوه استفاده از قابلیت‌های مشابه `RefCell<T>` در برنامه‌های چندرشته‌ای را بررسی می‌کنیم.

### مقایسه دلایل انتخاب `Box<T>`، `Rc<T>` یا `RefCell<T>`

| نوع | مالکیت | نوع قرض‌گیری | زمان بررسی |
|-----|--------|-------------|-------------|
| `Box<T>` | مالکیت واحد | قرض‌گیری قابل تغییر یا غیرقابل تغییر | زمان کامپایل |
| `Rc<T>` | مالکیت چندگانه | فقط قرض‌گیری غیرقابل تغییر | زمان کامپایل |
| `RefCell<T>` | مالکیت واحد | قرض‌گیری قابل تغییر یا غیرقابل تغییر | زمان اجرا |

به دلیل اینکه `RefCell<T>` امکان قرض‌گیری قابل تغییر در زمان اجرا را فراهم می‌کند، می‌توانید مقدار داخل `RefCell<T>` را حتی زمانی که خود `RefCell<T>` غیرقابل تغییر است، تغییر دهید. این همان الگوی تغییرپذیری داخلی است.

## تغییرپذیری داخلی: قرض‌گیری قابل تغییر به یک مقدار غیرقابل تغییر

یکی از نتایج قوانین قرض‌گیری این است که وقتی یک مقدار غیرقابل تغییر دارید، نمی‌توانید آن را به‌صورت قابل تغییر قرض کنید. برای مثال، کد زیر کامپایل نمی‌شود:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
fn main() {
    let x = 5;
    let y = &mut x;
}
```

**خطای کامپایل:**

```
$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --> src/main.rs:3:13
  |
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
```

اما گاهی اوقات مفید است که یک مقدار بتواند در متدهای خودش تغییر کند، در حالی که برای کدهای دیگر غیرقابل تغییر به نظر برسد. کدهای خارجی نمی‌توانند مقدار را تغییر دهند. استفاده از `RefCell<T>` یکی از راه‌های دستیابی به قابلیت تغییرپذیری داخلی است. با این حال، `RefCell<T>` قوانین قرض‌گیری را به‌طور کامل دور نمی‌زند: بررسی‌کننده قرض‌گیری (borrow checker) در کامپایلر این تغییرپذیری داخلی را مجاز می‌داند، اما قوانین قرض‌گیری در زمان اجرا بررسی می‌شوند. اگر این قوانین را نقض کنید، به جای خطای کامپایل، با یک **پنیک** مواجه خواهید شد.

بیایید با یک مثال عملی ببینیم که چگونه می‌توان از `RefCell<T>` برای تغییر یک مقدار غیرقابل تغییر استفاده کرد و چرا این کار مفید است.

## مورد استفاده برای تغییرپذیری داخلی: اشیاء موک (Mock Objects)

گاهی اوقات در هنگام تست، برنامه‌نویس از یک نوع به جای نوع دیگر استفاده می‌کند تا رفتار خاصی را مشاهده و تأیید کند که به‌درستی پیاده‌سازی شده است. این نوع جایگزین به نام **تست دابل** (test double) شناخته می‌شود. مانند بدلکار در فیلم‌سازی که به جای بازیگر اصلی در صحنه‌های دشوار ظاهر می‌شود، تست دابل‌ها در تست‌ها به جای نوع اصلی استفاده می‌شوند. **اشیاء موک** (mock objects) نوعی خاص از تست دابل‌ها هستند که اتفاقاتی که در طول تست رخ می‌دهد را ثبت می‌کنند تا بتوانید تأیید کنید که اقدامات درست انجام شده‌اند.

Rust برخلاف برخی زبان‌ها، مفهوم شیء (object) به معنای مرسوم را ندارد و قابلیت اشیاء موک به‌صورت داخلی در کتابخانه استاندارد آن تعبیه نشده است. اما قطعاً می‌توانید ساختاری (struct) ایجاد کنید که همان اهداف یک شیء موک را برآورده کند.

### سناریوی تست

فرض کنید می‌خواهیم یک کتابخانه بسازیم که مقداری را نسبت به یک مقدار حداکثر ردیابی می‌کند و بر اساس نزدیکی مقدار فعلی به مقدار حداکثر، پیام‌هایی ارسال می‌کند. این کتابخانه می‌تواند برای ردیابی سهمیه کاربر برای تعداد تماس‌های API که مجاز به انجام آن‌هاست استفاده شود.

کتابخانه ما فقط قابلیت ردیابی میزان نزدیکی مقدار به حداکثر و تعیین پیام‌های مناسب در زمان‌های مختلف را فراهم می‌کند. برنامه‌هایی که از کتابخانه ما استفاده می‌کنند، باید مکانیزم ارسال پیام‌ها را فراهم کنند: برنامه می‌تواند پیام را در خود نمایش دهد، ایمیل بفرستد، پیام متنی ارسال کند یا کار دیگری انجام دهد. کتابخانه نیازی به دانستن این جزئیات ندارد. تنها چیزی که نیاز دارد، چیزی است که ویژگی (trait) `Messenger` را که ما ارائه می‌دهیم، پیاده‌سازی کند. کد کتابخانه در Listing 15-20 نشان داده شده است:

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("خطا: شما از سهمیه خود فراتر رفته‌اید!"); // Error: You are over your quota!
        } else if percentage_of_max >= 0.9 {
            self.messenger.send("هشدار فوری: بیش از 90٪ از سهمیه خود را استفاده کرده‌اید!"); // Urgent warning: You've used up over 90% of your quota!
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("هشدار: بیش از 75٪ از سهمیه خود را استفاده کرده‌اید!"); // Warning: You've used up over 75% of your quota!
        }
    }
}
```

**توضیح کد**:
- ویژگی `Messenger` یک متد به نام `send` دارد که یک ارجاع غیرقابل تغییر به `self` و متن پیام را می‌گیرد. این ویژگی، رابطی است که شیء موک ما باید پیاده‌سازی کند تا بتواند مانند یک شیء واقعی استفاده شود.
- ما می‌خواهیم رفتار متد `set_value` در `LimitTracker` را تست کنیم. می‌توانیم مقداری که برای پارامتر `value` پاس می‌کنیم را تغییر دهیم، اما `set_value` چیزی برنمی‌گرداند که بتوانیم روی آن ادعایی (assertion) انجام دهیم.
- هدف ما این است که بگوییم اگر یک `LimitTracker` با چیزی که ویژگی `Messenger` را پیاده‌سازی می‌کند و یک مقدار خاص برای `max` بسازیم، وقتی مقادیر مختلفی برای `value` پاس می‌کنیم، پیام‌رسان باید پیام‌های مناسب را ارسال کند.

### تلاش برای پیاده‌سازی شیء موک

ما به یک شیء موک نیاز داریم که به جای ارسال ایمیل یا پیام متنی وقتی متد `send` فراخوانی می‌شود، فقط پیام‌هایی که باید ارسال شوند را ردیابی کند. می‌توانیم یک نمونه جدید از شیء موک بسازیم، یک `LimitTracker` که از شیء موک استفاده می‌کند ایجاد کنیم، متد `set_value` را روی `LimitTracker` فراخوانی کنیم و سپس بررسی کنیم که شیء موک پیام‌های مورد انتظار ما را دارد. Listing 15-21 تلاشی برای پیاده‌سازی یک شیء موک را نشان می‌دهد، اما بررسی‌کننده قرض‌گیری (borrow checker) این را مجاز نمی‌داند:

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

**خطای کامپایل:**

```
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference
  --> src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&mut self, msg: &str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&mut self, message: &str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
```

**توضیح خطا**:
ما نمی‌توانیم `MockMessenger` را برای ردیابی پیام‌ها تغییر دهیم، چون متد `send` یک ارجاع غیرقابل تغییر به `self` می‌گیرد. همچنین نمی‌توانیم پیشنهاد متن خطا را برای استفاده از `&mut self` در تعریف متد و ویژگی اعمال کنیم، زیرا نمی‌خواهیم ویژگی `Messenger` را فقط برای تست تغییر دهیم. در عوض، باید راهی پیدا کنیم که کد تست ما با طراحی موجود به‌درستی کار کند.

### استفاده از `RefCell<T>` برای حل مشکل

اینجا جایی است که تغییرپذیری داخلی می‌تواند کمک کند! ما `sent_messages` را در یک `RefCell<T>` ذخیره می‌کنیم، و سپس متد `send` می‌تواند `sent_messages` را برای ذخیره پیام‌هایی که دیده‌ایم تغییر دهد. Listing 15-22 نشان می‌دهد که این چگونه به نظر می‌رسد:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```

**توضیح کد**:
- فیلد `sent_messages` حالا از نوع `RefCell<Vec<String>>` است به جای `Vec<String>`.
- در تابع `new`، یک نمونه جدید از `RefCell<Vec<String>>` دور یک وکتور خالی ایجاد می‌کنیم.
- برای پیاده‌سازی متد `send`، پارامتر اول همچنان یک ارجاع غیرقابل تغییر به `self` است که با تعریف ویژگی سازگار است. ما `borrow_mut` را روی `RefCell<Vec<String>>` در `self.sent_messages` فراخوانی می‌کنیم تا یک ارجاع قابل تغییر به مقدار داخل `RefCell<Vec<String>>`، یعنی وکتور، به دست آوریم. سپس می‌توانیم `push` را روی ارجاع قابل تغییر به وکتور فراخوانی کنیم تا پیام‌های ارسال‌شده در طول تست را ردیابی کنیم.
- در ادعا (assertion)، برای دیدن تعداد آیتم‌های داخل وکتور، `borrow` را روی `RefCell<Vec<String>>` فراخوانی می‌کنیم تا یک ارجاع غیرقابل تغییر به وکتور بگیریم.

حالا که دیدید چگونه از `RefCell<T>` استفاده می‌کنیم، بیایید بررسی کنیم که چگونه کار می‌کند!

## ردیابی قرض‌گیری‌ها در زمان اجرا با `RefCell<T>`

وقتی ارجاعات غیرقابل تغییر و قابل تغییر ایجاد می‌کنیم، به ترتیب از نحو `&` و `&mut` استفاده می‌کنیم. با `RefCell<T>`، از متدهای `borrow` و `borrow_mut` استفاده می‌کنیم که بخشی از API امن `RefCell<T>` هستند. متد `borrow` یک اشاره‌گر هوشمند از نوع `Ref<T>` برمی‌گرداند و `borrow_mut` یک اشاره‌گر هوشمند از نوع `RefMut<T>` برمی‌گرداند. هر دو نوع، ویژگی `Deref` را پیاده‌سازی می‌کنند، بنابراین می‌توانیم با آن‌ها مانند ارجاعات معمولی رفتار کنیم.

`RefCell<T>` تعداد اشاره‌گرهای هوشمند `Ref<T>` و `RefMut<T>` که در حال حاضر فعال هستند را ردیابی می‌کند. هر بار که `borrow` را فراخوانی می‌کنیم، `RefCell<T>` تعداد قرض‌گیری‌های غیرقابل تغییر فعال را افزایش می‌دهد. وقتی یک مقدار `Ref<T>` از محدوده خارج می‌شود، تعداد قرض‌گیری‌های غیرقابل تغییر یک واحد کاهش می‌یابد. مشابه قوانین قرض‌گیری در زمان کامپایل، `RefCell<T>` به ما اجازه می‌دهد در هر لحظه چندین قرض‌گیری غیرقابل تغییر یا یک قرض‌گیری قابل تغییر داشته باشیم.

اگر سعی کنیم این قوانین را نقض کنیم، به جای خطای کامپایل، پیاده‌سازی `RefCell<T>` در زمان اجرا پنیک می‌کند. Listing 15-23 یک تغییر در پیاده‌سازی متد `send` در Listing 15-22 را نشان می‌دهد که عمداً سعی می‌کند دو قرض‌گیری قابل تغییر در یک محدوده ایجاد کند تا نشان دهد `RefCell<T>` از این کار در زمان اجرا جلوگیری می‌کند:

```rust
// این کد پنیک می‌کند!
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```

**خروجی تست:**

```
$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

**توضیح خروجی**:
کد بدون خطای کامپایل ساخته می‌شود، اما تست شکست می‌خورد و پیام پنیک `already borrowed: BorrowMutError` را نشان می‌دهد. این نشان می‌دهد که `RefCell<T>` نقض قوانین قرض‌گیری را در زمان اجرا تشخیص داده و برنامه را متوقف کرده است.

### مزایا و معایب استفاده از `RefCell<T>`

انتخاب بررسی خطاهای قرض‌گیری در زمان اجرا به جای زمان کامپایل، همان‌طور که در اینجا انجام دادیم، به این معناست که ممکن است خطاها را دیرتر در فرآیند توسعه پیدا کنید، شاید حتی تا زمانی که کدتان در محیط تولید مستقر شود. همچنین، کد شما به دلیل ردیابی قرض‌گیری‌ها در زمان اجرا، جریمه عملکردی کوچکی متحمل می‌شود. با این حال، استفاده از `RefCell<T>` امکان نوشتن یک شیء موک را فراهم می‌کند که می‌تواند خودش را برای ردیابی پیام‌هایی که دیده تغییر دهد، در حالی که در محیطی استفاده می‌شود که فقط مقادیر غیرقابل تغییر مجاز هستند. با وجود معایب، می‌توانید از `RefCell<T>` برای دستیابی به قابلیت‌های بیشتری نسبت به ارجاعات معمولی استفاده کنید.

## اجازه دادن به چندین مالک برای داده‌های قابل تغییر با `Rc<T>` و `RefCell<T>`

یک روش رایج برای استفاده از `RefCell<T>`، ترکیب آن با `Rc<T>` است. به یاد بیاورید که `Rc<T>` به شما امکان می‌دهد چندین مالک برای یک داده داشته باشید، اما فقط دسترسی غیرقابل تغییر به آن داده‌ها را می‌دهد. اگر یک `Rc<T>` داشته باشید که یک `RefCell<T>` را نگه می‌دارد، می‌توانید مقداری داشته باشید که چندین مالک دارد و قابل تغییر است!

برای مثال، به مثال لیست پیوندی در Listing 15-18 برگردیم که از `Rc<T>` برای اجازه دادن به چندین لیست برای به اشتراک گذاشتن مالکیت یک لیست دیگر استفاده کردیم. چون `Rc<T>` فقط مقادیر غیرقابل تغییر را نگه می‌دارد، نمی‌توانیم هیچ‌کدام از مقادیر لیست را بعد از ایجاد آن‌ها تغییر دهیم. حالا بیایید از `RefCell<T>` برای افزودن قابلیت تغییر مقادیر در لیست‌ها استفاده کنیم. Listing 15-24 نشان می‌دهد که با استفاده از `RefCell<T>` در تعریف `Cons`، می‌توانیم مقدار ذخیره‌شده در همه لیست‌ها را تغییر دهیم:

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a پس از تغییر = {a:?}"); // a after
    println!("b پس از تغییر = {b:?}"); // b after
    println!("c پس از تغییر = {c:?}"); // c after
}
```

**خروجی کد:**

```
$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a پس از تغییر = Cons(RefCell { value: 15 }, Nil)
b پس از تغییر = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c پس از تغییر = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```

**توضیح کد**:
- ما یک مقدار از نوع `Rc<RefCell<i32>>` ایجاد می‌کنیم و آن را در متغیر `value` ذخیره می‌کنیم تا بعداً بتوانیم مستقیماً به آن دسترسی داشته باشیم.
- سپس یک لیست در `a` با یک نوع `Cons` ایجاد می‌کنیم که `value` را نگه می‌دارد. ما باید `value` را کلون کنیم تا هم `a` و هم `value` مالکیت مقدار داخلی 5 را داشته باشند، به جای اینکه مالکیت از `value` به `a` منتقل شود یا `a` از `value` قرض بگیرد.
- لیست `a` را در یک `Rc<T>` می‌پیچیم تا وقتی لیست‌های `b` و `c` را ایجاد می‌کنیم، هر دو بتوانند به `a` اشاره کنند، همان‌طور که در Listing 15-18 انجام دادیم.
- پس از ایجاد لیست‌های `a`، `b` و `c`، می‌خواهیم 10 واحد به مقدار در `value` اضافه کنیم. این کار را با فراخوانی `borrow_mut` روی `value` انجام می‌دهیم که با استفاده از ویژگی رفع ارجاع خودکار (automatic dereferencing) که در فصل پنجم بحث کردیم، `Rc<T>` را به مقدار داخلی `RefCell<T>` رفع ارجاع می‌کند.
- متد `borrow_mut` یک اشاره‌گر هوشمند `RefMut<T>` برمی‌گرداند و ما از عملگر رفع ارجاع روی آن استفاده می‌کنیم و مقدار داخلی را تغییر می‌دهیم.

وقتی `a`، `b` و `c` را چاپ می‌کنیم، می‌بینیم که همه آن‌ها مقدار اصلاح‌شده 15 را دارند به جای 5. این تکنیک بسیار جالب است! با استفاده از `RefCell<T>`، ما یک مقدار لیست داریم که از بیرون غیرقابل تغییر به نظر می‌رسد. اما می‌توانیم از متدهای `RefCell<T>` که دسترسی به تغییرپذیری داخلی را فراهم می‌کنند استفاده کنیم تا داده‌هایمان را در صورت نیاز تغییر دهیم. بررسی‌های زمان اجرا از قوانین قرض‌گیری ما را از رقابت داده‌ای (data races) محافظت می‌کنند و گاهی ارزش دارد که کمی از سرعت را برای این انعطاف‌پذیری در ساختارهای داده‌مان فدا کنیم.

> **توجه**: `RefCell<T>` برای کدهای چندرشته‌ای مناسب نیست! نوع `Mutex<T>` نسخه امن برای چندرشته‌ای `RefCell<T>` است و در فصل شانزدهم درباره `Mutex<T>` بحث خواهیم کرد.
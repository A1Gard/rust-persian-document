# پیوست A: کلمات کلیدی

در زیر لیستی از کلمات کلیدی آورده شده است که برای استفاده فعلی یا آینده توسط زبان Rust رزرو شده‌اند. به همین دلیل، آن‌ها نمی‌توانند به‌عنوان شناسه (identifier) استفاده شوند (به جز به‌عنوان شناسه‌های خام که در بخش «شناسه‌های خام» بحث خواهیم کرد). شناسه‌ها نام‌های توابع، متغیرها، پارامترها، فیلدهای ساختار، ماژول‌ها، crate‌ها، ثابت‌ها، ماکروها، مقادیر static، ویژگی‌ها، انواع، صفات (traits)، یا طول‌عمرها هستند.

## کلمات کلیدی که در حال حاضر استفاده می‌شوند

در زیر لیستی از کلمات کلیدی که در حال حاضر استفاده می‌شوند، همراه با توضیح عملکرد آن‌ها آورده شده است:

- **as** - انجام تبدیل ابتدایی، رفع ابهام ویژگی‌ خاصی که یک آیتم را در بر دارد، یا تغییر نام آیتم‌ها در دستورات use
- **async** - بازگرداندن یک Future به‌جای بلاک کردن ریسمان فعلی
- **await** - تعلیق اجرا تا زمانی که نتیجه یک Future آماده شود
- **break** - خروج فوری از یک حلقه
- **const** - تعریف آیتم‌های ثابت یا اشاره‌گرهای خام ثابت
- **continue** - ادامه به تکرار بعدی حلقه
- **crate** - در مسیر ماژول، به ریشه crate اشاره دارد
- **dyn** - ارسال پویا به یک شیء ویژگی‌
- **else** - جایگزین برای سازه‌های کنترل جریان if و if let
- **enum** - تعریف یک شمارش
- **extern** - لینک به یک تابع یا متغیر خارجی
- **false** - مقدار لفظی بولی false
- **fn** - تعریف یک تابع یا نوع اشاره‌گر تابع
- **for** - حلقه روی آیتم‌ها از یک تکرارگر، پیاده‌سازی یک ویژگی‌، یا مشخص کردن طول‌عمر رتبه بالاتر
- **if** - انشعاب بر اساس نتیجه یک عبارت شرطی
- **impl** - پیاده‌سازی عملکرد ذاتی یا ویژگی‌
- **in** - بخشی از نحو حلقه for
- **let** - اتصال یک متغیر
- **loop** - حلقه بدون شرط
- **match** - تطبیق یک مقدار با الگوها
- **mod** - تعریف یک ماژول
- **move** - باعث می‌شود یک بسته‌بندی مالکیت تمام ضبط‌های خود را بگیرد
- **mut** - نشان‌دهنده قابلیت تغییر در ارجاعات، اشاره‌گرهای خام، یا اتصالات الگو
- **pub** - نشان‌دهنده دید عمومی در فیلدهای ساختار، بلوک‌های impl، یا ماژول‌ها
- **ref** - اتصال به‌صورت ارجاع
- **return** - بازگشت از تابع
- **Self** - نام مستعار نوع برای نوعی که در حال تعریف یا پیاده‌سازی آن هستیم
- **self** - موضوع متد یا ماژول فعلی
- **static** - متغیر جهانی یا طول‌عمری که کل اجرای برنامه را دوام می‌آورد
- **struct** - تعریف یک ساختار
- **super** - ماژول والد ماژول فعلی
- **trait** - تعریف یک ویژگی‌
- **true** - مقدار لفظی بولی true
- **type** - تعریف یک نام مستعار نوع یا نوع مرتبط
- **union** - تعریف یک اتحاد؛ تنها زمانی کلمه کلیدی است که در اعلام اتحاد استفاده شود
- **unsafe** - نشان‌دهنده کد، توابع، صفات، یا پیاده‌سازی‌های ناامن
- **use** - آوردن نمادها به حوزه؛ مشخص کردن ضبط‌های دقیق برای حدود عمومی و طول‌عمر
- **where** - نشان‌دهنده بندهایی که یک نوع را محدود می‌کنند
- **while** - حلقه شرطی بر اساس نتیجه یک عبارت

## کلمات کلیدی رزرو شده برای استفاده آینده

کلمات کلیدی زیر هنوز هیچ عملکردی ندارند اما توسط Rust برای استفاده بالقوه در آینده رزرو شده‌اند:

- abstract
- become
- box
- do
- final
- gen
- macro
- override
- priv
- try
- typeof
- unsized
- virtual
- yield

## شناسه‌های خام

شناسه‌های خام نحوی هستند که به شما امکان می‌دهند از کلمات کلیدی در جایی که معمولاً مجاز نیستند استفاده کنید. شما با پیشوند کردن یک کلمه کلیدی با `r#` از یک شناسه خام استفاده می‌کنید.

برای مثال، `match` یک کلمه کلیدی است. اگر سعی کنید تابع زیر را که از `match` به‌عنوان نام خود استفاده می‌کند کامپایل کنید:

**فایل: src/main.rs**

*این کد کامپایل نمی‌شود!*

```rust
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

این خطا را دریافت خواهید کرد:

```
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

این خطا نشان می‌دهد که نمی‌توانید از کلمه کلیدی `match` به‌عنوان شناسه تابع استفاده کنید. برای استفاده از `match` به‌عنوان نام تابع، باید از نحو شناسه خام استفاده کنید، مانند این:

**فایل: src/main.rs**

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

این کد بدون هیچ خطایی کامپایل خواهد شد. توجه کنید به پیشوند `r#` روی نام تابع در تعریف آن و همچنین جایی که تابع در `main` فراخوانی شده است.

شناسه‌های خام به شما امکان می‌دهند هر کلمه‌ای را که انتخاب می‌کنید به‌عنوان شناسه استفاده کنید، حتی اگر آن کلمه یک کلمه کلیدی رزرو شده باشد. این به ما آزادی بیشتری برای انتخاب نام‌های شناسه می‌دهد و همچنین به ما امکان می‌دهد با برنامه‌هایی که در زبانی نوشته شده‌اند که این کلمات در آن کلمه کلیدی نیستند ادغام شویم. علاوه بر این، شناسه‌های خام به شما امکان می‌دهند از کتابخانه‌هایی که در نسخه متفاوتی از Rust نسبت به crate شما نوشته شده‌اند استفاده کنید. برای مثال، `try` در نسخه 2015 کلمه کلیدی نیست اما در نسخه‌های 2018، 2021، و 2024 کلمه کلیدی است. اگر به کتابخانه‌ای وابسته باشید که با استفاده از نسخه 2015 نوشته شده و دارای تابع `try` باشد، باید از نحو شناسه خام، در این مورد `r#try`، برای فراخوانی آن تابع از کد خود در نسخه‌های بعدی استفاده کنید. برای اطلاعات بیشتر درباره نسخه‌ها به پیوست E مراجعه کنید.
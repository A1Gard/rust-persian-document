# نوع‌های داده Generic

ما از Generic‌ها برای ایجاد تعریف‌هایی برای مواردی مانند امضاهای تابع یا ساختارها استفاده می‌کنیم که سپس می‌توانیم با انواع داده‌های مشخص مختلف از آن‌ها استفاده کنیم. ابتدا به این می‌پردازیم که چگونه می‌توان توابع، ساختارها، انوم‌ها و متدها را با استفاده از Generic‌ها تعریف کرد. سپس درباره تأثیر Generic‌ها بر عملکرد کد صحبت خواهیم کرد.

## در تعریف‌های تابع

وقتی تابعی را تعریف می‌کنیم که از Generic‌ها استفاده می‌کند، Generic‌ها را در امضای تابع قرار می‌دهیم، جایی که معمولاً نوع داده‌های پارامترها و مقدار بازگشتی را مشخص می‌کنیم. این کار کد ما را انعطاف‌پذیرتر می‌کند و قابلیت‌های بیشتری به فراخوانندگان تابع ما ارائه می‌دهد، در حالی که از تکرار کد جلوگیری می‌کند.

با ادامه مثال تابع `largest`، **جدول 10-4** دو تابع را نشان می‌دهد که هر دو بزرگ‌ترین مقدار را در یک برش (slice) پیدا می‌کنند. سپس این‌ها را در یک تابع واحد که از Generic‌ها استفاده می‌کند ترکیب خواهیم کرد.

**فایل: src/main.rs**

```rust
// این تابع بزرگ‌ترین عدد صحیح را در یک برش پیدا می‌کند!
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

// این تابع بزرگ‌ترین کاراکتر را در یک برش پیدا می‌کند!
fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {result}");
}
```

**جدول 10-4**: دو تابع که فقط در نام‌ها و نوع‌های موجود در امضاهایشان متفاوت هستند

تابع `largest_i32` همان تابعی است که در **جدول 10-3** استخراج کردیم و بزرگ‌ترین `i32` را در یک برش پیدا می‌کند. تابع `largest_char` بزرگ‌ترین `char` را در یک برش پیدا می‌کند. بدنه توابع کد یکسانی دارند، بنابراین بیایید با معرفی یک پارامتر نوع Generic در یک تابع واحد، تکرار را حذف کنیم.

برای پارامتری کردن نوع‌ها در یک تابع واحد جدید، باید نامی برای پارامتر نوع انتخاب کنیم، همان‌طور که برای پارامترهای مقدار تابع انجام می‌دهیم. می‌توانید هر شناسه‌ای را به‌عنوان نام پارامتر نوع استفاده کنید. اما ما از `T` استفاده خواهیم کرد زیرا، طبق قرارداد، نام‌های پارامترهای نوع در **Rust** کوتاه هستند، اغلب فقط یک حرف، و قرارداد نام‌گذاری نوع در **Rust** به‌صورت CamelCase است. به‌صورت خلاصه برای "type"، `T` انتخاب پیش‌فرض اکثر برنامه‌نویسان **Rust** است.

وقتی از یک پارامتر در بدنه تابع استفاده می‌کنیم، باید نام پارامتر را در امضا اعلام کنیم تا کامپایلر بداند آن نام به چه معناست. به‌طور مشابه، وقتی از یک نام پارامتر نوع در امضای تابع استفاده می‌کنیم، باید نام پارامتر نوع را قبل از استفاده اعلام کنیم. برای تعریف تابع Generic `largest`، اعلام نام‌های نوع را داخل کروشه‌ها، `<>`، بین نام تابع و لیست پارامترها قرار می‌دهیم، مانند این:

```rust
fn largest<T>(list: &[T]) -> &T {
```

این تعریف را این‌گونه می‌خوانیم: تابع `largest` روی نوع `T` Generic است. این تابع یک پارامتر به نام `list` دارد که یک برش از مقادیر نوع `T` است. تابع `largest` یک مرجع به مقداری از همان نوع `T` برمی‌گرداند.

**جدول 10-5** تعریف تابع `largest` ترکیب‌شده را با استفاده از نوع داده Generic در امضای آن نشان می‌دهد. این جدول همچنین نشان می‌دهد که چگونه می‌توانیم تابع را با یک برش از مقادیر `i32` یا مقادیر `char` فراخوانی کنیم. توجه داشته باشید که این کد هنوز کامپایل نمی‌شود.

**فایل: src/main.rs**

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {result}");
}
```

**جدول 10-5**: تابع `largest` با استفاده از پارامترهای نوع Generic؛ این هنوز کامپایل نمی‌شود

اگر این کد را اکنون کامپایل کنیم، خطای زیر را دریافت خواهیم کرد:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `&T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- &T
  |            |
  |            &T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

متن راهنما به `std::cmp::PartialOrd` اشاره می‌کند، که یک ترییت است و ما در بخش بعدی درباره ترییت‌ها صحبت خواهیم کرد. برای حالا، بدانید که این خطا بیان می‌کند که بدنه `largest` برای همه نوع‌های ممکنی که `T` می‌تواند باشد کار نخواهد کرد. چون می‌خواهیم مقادیر نوع `T` را در بدنه مقایسه کنیم، فقط می‌توانیم از نوع‌هایی استفاده کنیم که مقادیرشان قابل مرتب‌سازی باشند. برای فعال کردن مقایسه‌ها، کتابخانه استاندارد ترییت `std::cmp::PartialOrd` را دارد که می‌توانید روی نوع‌ها پیاده‌سازی کنید (برای اطلاعات بیشتر درباره این ترییت به پیوست C مراجعه کنید). برای رفع کد مثال بالا، باید پیشنهادات متن راهنما را دنبال کنیم و نوع‌های معتبر برای `T` را فقط به آن‌هایی محدود کنیم که `PartialOrd` را پیاده‌سازی کرده‌اند. سپس مثال کامپایل خواهد شد، زیرا کتابخانه استاندارد `PartialOrd` را هم روی `i32` و هم روی `char` پیاده‌سازی کرده است.

> **توجه**: برای رفع این خطا، می‌توانیم امضای تابع را به این صورت تغییر دهیم:
>
> ```rust
> fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
> ```
>
> این محدودیت تضمین می‌کند که `T` می‌تواند با عملگر `>` مقایسه شود، و کد برای نوع‌هایی مانند `i32` و `char` که `PartialOrd` را پیاده‌سازی کرده‌اند، کار خواهد کرد.

## در تعریف‌های ساختار

ما همچنین می‌توانیم ساختارها را برای استفاده از یک پارامتر نوع Generic در یک یا چند فیلد با استفاده از نحو `<>` تعریف کنیم. **جدول 10-6** یک ساختار `Point<T>` را تعریف می‌کند که مقادیر مختصات `x` و `y` از هر نوع را نگه می‌دارد.

**فایل: src/main.rs**

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

**جدول 10-6**: ساختار `Point<T>` که مقادیر `x` و `y` از نوع `T` را نگه می‌دارد

نحو برای استفاده از Generic‌ها در تعریف‌های ساختار مشابه نحوی است که در تعریف‌های تابع استفاده می‌شود. ابتدا نام پارامتر نوع را داخل کروشه‌ها درست بعد از نام ساختار اعلام می‌کنیم. سپس از نوع Generic در تعریف ساختار در جایی استفاده می‌کنیم که در غیر این صورت نوع‌های داده مشخص را مشخص می‌کردیم.

توجه داشته باشید که چون فقط از یک نوع Generic برای تعریف `Point<T>` استفاده کرده‌ایم، این تعریف می‌گوید که ساختار `Point<T>` روی یک نوع `T` Generic است، و فیلدهای `x` و `y` هر دو از همان نوع هستند، هرچه که آن نوع باشد. اگر بخواهیم نمونه‌ای از `Point<T>` ایجاد کنیم که مقادیر از نوع‌های مختلف داشته باشد، مانند **جدول 10-7**، کد ما کامپایل نخواهد شد.

**فایل: src/main.rs**

```rust
// <img src="img/does_not_compile.svg" class="err"> این کد کامپایل نمی‌شود!
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

**جدول 10-7**: فیلدهای `x` و `y` باید از یک نوع باشند زیرا هر دو نوع داده Generic یکسانی `T` دارند.

در این مثال، وقتی مقدار صحیح 5 را به `x` اختصاص می‌دهیم، به کامپایلر اطلاع می‌دهیم که نوع Generic `T` برای این نمونه از `Point<T>` یک عدد صحیح خواهد بود. سپس وقتی 4.0 را برای `y` مشخص می‌کنیم، که تعریف کرده‌ایم همان نوع `x` را داشته باشد، خطای عدم تطابق نوع دریافت خواهیم کرد مانند این:

```bash
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
```

برای تعریف یک ساختار `Point` که در آن `x` و `y` هر دو Generic باشند اما بتوانند نوع‌های متفاوتی داشته باشند، می‌توانیم از چندین پارامتر نوع Generic استفاده کنیم. برای مثال، در **جدول 10-8**، تعریف `Point` را تغییر می‌دهیم تا روی نوع‌های `T` و `U` Generic باشد، جایی که `x` از نوع `T` و `y` از نوع `U` است.

**فایل: src/main.rs**

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

**جدول 10-8**: یک `Point<T, U>` Generic روی دو نوع، بنابراین `x` و `y` می‌توانند مقادیر از نوع‌های مختلف باشند

اکنون تمام نمونه‌های `Point` نشان‌داده‌شده مجاز هستند! می‌توانید هر تعداد پارامتر نوع Generic که می‌خواهید در یک تعریف استفاده کنید، اما استفاده از تعداد زیادی کد شما را سخت‌خوان می‌کند. اگر متوجه شدید که به تعداد زیادی نوع Generic در کد خود نیاز دارید، ممکن است نشان‌دهنده این باشد که کد شما نیاز به بازسازی به قطعات کوچک‌تر دارد.

## در تعریف‌های انوم

مانند ساختارها، می‌توانیم انوم‌ها را برای نگه داشتن نوع‌های داده Generic در واریانت‌هایشان تعریف کنیم. بیایید دوباره به انوم `Option<T>` که کتابخانه استاندارد ارائه می‌دهد و در فصل ششم استفاده کردیم، نگاهی بیندازیم:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

این تعریف اکنون برای شما منطقی‌تر باید باشد. همان‌طور که می‌بینید، انوم `Option<T>` روی نوع `T` Generic است و دو واریانت دارد: `Some` که یک مقدار از نوع `T` را نگه می‌دارد، و واریانت `None` که هیچ مقداری نگه نمی‌دارد. با استفاده از انوم `Option<T>`، می‌توانیم مفهوم انتزاعی یک مقدار اختیاری را بیان کنیم، و چون `Option<T>` Generic است، می‌توانیم از این انتزاع صرف‌نظر از نوع مقدار اختیاری استفاده کنیم.

انوم‌ها همچنین می‌توانند از چندین نوع Generic استفاده کنند. تعریف انوم `Result` که در فصل نهم استفاده کردیم یک مثال است:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

انوم `Result` روی دو نوع `T` و `E` Generic است و دو واریانت دارد: `Ok` که یک مقدار از نوع `T` را نگه می‌دارد، و `Err` که یک مقدار از نوع `E` را نگه می‌دارد. این تعریف استفاده از انوم `Result` را در هر جایی که عملیاتی داریم که ممکن است موفق شود (مقداری از نوع `T` را برگرداند) یا شکست بخورد (خطایی از نوع `E` را برگرداند) راحت می‌کند. در واقع، این همان چیزی بود که در **جدول 9-3** برای باز کردن یک فایل استفاده کردیم، جایی که `T` وقتی فایل با موفقیت باز شد با نوع `std::fs::File` پر شد و `E` وقتی مشکلی در باز کردن فایل وجود داشت با نوع `std::io::Error` پر شد.

وقتی در کد خود موقعیت‌هایی را تشخیص می‌دهید که چندین تعریف ساختار یا انوم دارید که فقط در نوع مقادیرشان متفاوت هستند، می‌توانید با استفاده از نوع‌های Generic به‌جای آن از تکرار جلوگیری کنید.

## در تعریف‌های متد

ما می‌توانیم متدها را روی ساختارها و انوم‌ها پیاده‌سازی کنیم (همان‌طور که در فصل پنجم انجام دادیم) و از نوع‌های Generic در تعریف‌هایشان استفاده کنیم. **جدول 10-9** ساختار `Point<T>` را که در **جدول 10-6** تعریف کردیم نشان می‌دهد با یک متد به نام `x` که روی آن پیاده‌سازی شده است.

**فایل: src/main.rs**

```rust
struct Point<T> {
    x: T,
    y: T,
}

// این متد مرجعی به فیلد x از نوع T برمی‌گرداند!
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

**جدول 10-9**: پیاده‌سازی متدی به نام `x` روی ساختار `Point<T>` که مرجعی به فیلد `x` از نوع `T` برمی‌گرداند

در اینجا، ما متدی به نام `x` روی `Point<T>` تعریف کرده‌ایم که مرجعی به داده در فیلد `x` برمی‌گرداند.

توجه داشته باشید که باید `T` را درست بعد از `impl` اعلام کنیم تا بتوانیم از `T` برای مشخص کردن اینکه در حال پیاده‌سازی متدها روی نوع `Point<T>` هستیم استفاده کنیم. با اعلام `T` به‌عنوان یک نوع Generic بعد از `impl`، **Rust** می‌تواند تشخیص دهد که نوع داخل کروشه‌ها در `Point` یک نوع Generic است نه یک نوع مشخص. می‌توانستیم نامی متفاوت برای این پارامتر Generic نسبت به پارامتر Generic اعلام‌شده در تعریف ساختار انتخاب کنیم، اما استفاده از همان نام طبق قرارداد است. اگر متدی را در یک `impl` بنویسید که یک نوع Generic اعلام می‌کند، آن متد روی هر نمونه‌ای از نوع تعریف خواهد شد، صرف‌نظر از اینکه چه نوع مشخصی در نهایت جایگزین نوع Generic شود.

ما همچنین می‌توانیم محدودیت‌هایی روی نوع‌های Generic هنگام تعریف متدها روی نوع مشخص کنیم. برای مثال، می‌توانیم متدها را فقط روی نمونه‌های `Point<f32>` پیاده‌سازی کنیم به‌جای نمونه‌های `Point<T>` با هر نوع Generic. در **جدول 10-10** از نوع مشخص `f32` استفاده می‌کنیم، به این معنی که هیچ نوع دیگری بعد از `impl` اعلام نمی‌کنیم.

**فایل: src/main.rs**

```rust
// این متد فاصله از مبدا را برای Point<f32> محاسبه می‌کند!
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

**جدول 10-10**: یک بلاک `impl` که فقط روی ساختاری با یک نوع مشخص برای پارامتر نوع Generic `T` اعمال می‌شود

این کد به این معناست که نوع `Point<f32>` یک متد `distance_from_origin` خواهد داشت؛ نمونه‌های دیگر `Point<T>` که `T` از نوع `f32` نیست، این متد را تعریف‌شده نخواهند داشت. این متد فاصله نقطه ما از نقطه در مختصات (0.0, 0.0) را اندازه‌گیری می‌کند و از عملیات ریاضی استفاده می‌کند که فقط برای نوع‌های اعداد اعشاری در دسترس هستند.

پارامترهای نوع Generic در تعریف یک ساختار همیشه همان پارامترهایی نیستند که در امضاهای متدهای همان ساختار استفاده می‌کنید. **جدول 10-11** از نوع‌های Generic `X1` و `Y1` برای ساختار `Point` و `X2` و `Y2` برای امضای متد `mixup` استفاده می‌کند تا مثال واضح‌تر شود. این متد یک نمونه جدید `Point` ایجاد می‌کند با مقدار `x` از `Point` خود (از نوع `X1`) و مقدار `y` از `Point` منتقل‌شده (از نوع `Y2`).

**فایل: src/main.rs**

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

// این متد مقادیر x و y را از دو Point ترکیب می‌کند!
impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

**جدول 10-11**: متدی که از نوع‌های Generic متفاوتی نسبت به تعریف ساختار خود استفاده می‌کند

در `main`، ما یک `Point` تعریف کرده‌ایم که برای `x` یک `i32` (با مقدار 5) و برای `y` یک `f64` (با مقدار 10.4) دارد. متغیر `p2` یک ساختار `Point` است که برای `x` یک برش رشته‌ای (با مقدار `"Hello"`) و برای `y` یک `char` (با مقدار `c`) دارد. فراخوانی `mixup` روی `p1` با آرگومان `p2` به ما `p3` می‌دهد، که برای `x` یک `i32` خواهد داشت زیرا `x` از `p1` آمده است. متغیر `p3` برای `y` یک `char` خواهد داشت زیرا `y` از `p2` آمده است. فراخوانی ماکرو `println!` چاپ خواهد کرد: `p3.x = 5, p3.y = c`.

هدف این مثال نشان دادن موقعیتی است که برخی پارامترهای Generic با `impl` اعلام می‌شوند و برخی با تعریف متد اعلام می‌شوند. در اینجا، پارامترهای Generic `X1` و `Y1` بعد از `impl` اعلام شده‌اند زیرا با تعریف ساختار مرتبط هستند. پارامترهای Generic `X2` و `Y2` بعد از `fn mixup` اعلام شده‌اند زیرا فقط به متد مربوط هستند.

## عملکرد کد با استفاده از Generic‌ها

ممکن است تعجب کنید که آیا استفاده از پارامترهای نوع Generic هزینه‌ای در زمان اجرا دارد. خبر خوب این است که استفاده از نوع‌های Generic باعث نمی‌شود برنامه شما کندتر از حالتی که با نوع‌های مشخص اجرا می‌شود، اجرا شود.

**Rust** این را با انجام **تک‌گونه‌سازی (monomorphization)** کد با استفاده از Generic‌ها در زمان کامپایل به دست می‌آورد. تک‌گونه‌سازی فرآیند تبدیل کد Generic به کد خاص با پر کردن نوع‌های مشخصی است که در زمان کامپایل استفاده می‌شوند. در این فرآیند، کامپایلر برعکس مراحلی را که برای ایجاد تابع Generic در **جدول 10-5** استفاده کردیم انجام می‌دهد: کامپایلر تمام مکان‌هایی که کد Generic فراخوانی شده را بررسی می‌کند و کد را برای نوع‌های مشخصی که کد Generic با آن‌ها فراخوانی شده تولید می‌کند.

بیایید ببینیم این چگونه با استفاده از انوم Generic `Option<T>` کتابخانه استاندارد کار می‌کند:

```rust
let integer = Some(5);
let float = Some(5.0);
```

وقتی **Rust** این کد را کامپایل می‌کند، تک‌گونه‌سازی را انجام می‌دهد. در طول این فرآیند، کامپایلر مقادیر استفاده‌شده در نمونه‌های `Option<T>` را می‌خواند و دو نوع `Option<T>` را شناسایی می‌کند: یکی `i32` و دیگری `f64`. به این ترتیب، تعریف Generic `Option<T>` را به دو تعریف تخصصی‌شده برای `i32` و `f64` گسترش می‌دهد، در نتیجه تعریف Generic را با تعریف‌های خاص جایگزین می‌کند.

نسخه تک‌گونه‌شده کد شبیه به این است (کامپایلر از نام‌های متفاوتی نسبت به آنچه ما اینجا برای توضیح استفاده می‌کنیم، استفاده می‌کند):

**فایل: src/main.rs**

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

`Option<T>` Generic با تعریف‌های خاصی که توسط کامپایلر ایجاد شده‌اند جایگزین می‌شود. چون **Rust** کد Generic را به کدی کامپایل می‌کند که نوع را در هر نمونه مشخص می‌کند، هیچ هزینه‌ای در زمان اجرا برای استفاده از Generic‌ها پرداخت نمی‌کنیم. وقتی کد اجرا می‌شود، همان‌طور عمل می‌کند که گویی ما هر تعریف را به‌صورت دستی تکرار کرده بودیم. فرآیند تک‌گونه‌سازی Generic‌های **Rust** را در زمان اجرا بسیار کارآمد می‌کند.
## تعریف و نمونه‌سازی ساختارها

ساختارها (structs) شبیه به تاپل‌ها هستند، که در بخش «نوع تاپل» بحث شدند، به این معنا که هر دو چندین مقدار مرتبط را نگه می‌دارند. مانند تاپل‌ها، اجزای یک ساختار می‌توانند از نوع‌های مختلفی باشند. برخلاف تاپل‌ها، در یک ساختار شما هر قطعه داده را نام‌گذاری می‌کنید تا مشخص باشد مقادیر چه معنایی دارند. افزودن این نام‌ها باعث می‌شود ساختارها انعطاف‌پذیرتر از تاپل‌ها باشند: نیازی نیست برای مشخص کردن یا دسترسی به مقادیر یک نمونه به ترتیب داده‌ها وابسته باشید.

برای تعریف یک ساختار، از کلمه‌کلیدی `struct` استفاده می‌کنیم و کل ساختار را نام‌گذاری می‌کنیم. نام ساختار باید اهمیت قطعات داده‌ای که کنار هم گروه‌بندی شده‌اند را توصیف کند. سپس، داخل کروشه‌ها، نام‌ها و نوع‌های قطعات داده را تعریف می‌کنیم که به آن‌ها **فیلدها (fields)** می‌گوییم. برای مثال، لیست ۵-۱ یک ساختار را نشان می‌دهد که اطلاعاتی درباره یک حساب کاربری ذخیره می‌کند.

**نام فایل:** `src/main.rs`

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

**لیست ۵-۱:** تعریف ساختار `User`

برای استفاده از یک ساختار پس از تعریف آن، یک نمونه (instance) از آن ساختار ایجاد می‌کنیم با مشخص کردن مقادیر مشخص برای هر یک از فیلدها. یک نمونه را با ذکر نام ساختار ایجاد می‌کنیم و سپس کروشه‌هایی اضافه می‌کنیم که شامل جفت‌های کلید:مقدار هستند، که در آن کلیدها نام‌های فیلدها و مقادیر داده‌هایی هستند که می‌خواهیم در آن فیلدها ذخیره کنیم. لازم نیست فیلدها را به همان ترتیبی که در ساختار اعلان شده‌اند مشخص کنیم. به عبارت دیگر، تعریف ساختار مانند یک الگوی کلی برای نوع است، و نمونه‌ها آن الگو را با داده‌های خاص پر می‌کنند تا مقادیر آن نوع را ایجاد کنند. برای مثال، می‌توانیم یک کاربر خاص را همان‌طور که در لیست ۵-۲ نشان داده شده است، اعلان کنیم.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

**لیست ۵-۲:** ایجاد یک نمونه از ساختار `User`

برای به دست آوردن یک مقدار خاص از یک ساختار، از نگارش نقطه‌ای (dot notation) استفاده می‌کنیم. برای مثال، برای دسترسی به آدرس ایمیل این کاربر، از `user1.email` استفاده می‌کنیم. اگر نمونه قابل‌تغییر (mutable) باشد، می‌توانیم با استفاده از نگارش نقطه‌ای و تخصیص به یک فیلد خاص، مقداری را تغییر دهیم. لیست ۵-۳ نشان می‌دهد که چگونه مقدار در فیلد `email` یک نمونه قابل‌تغییر `User` را تغییر دهیم.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

**لیست ۵-۳:** تغییر مقدار در فیلد `email` یک نمونه `User`

توجه کنید که کل نمونه باید قابل‌تغییر باشد؛ Rust به ما اجازه نمی‌دهد فقط برخی فیلدها را به‌عنوان قابل‌تغییر علامت‌گذاری کنیم. مانند هر عبارت دیگری، می‌توانیم یک نمونه جدید از ساختار را به‌عنوان آخرین عبارت در بدنه تابع بسازیم تا به‌صورت ضمنی آن نمونه جدید را برگردانیم.

لیست ۵-۴ یک تابع `build_user` را نشان می‌دهد که یک نمونه `User` با ایمیل و نام کاربری داده‌شده برمی‌گرداند. فیلد `active` مقدار `true` می‌گیرد، و `sign_in_count` مقدار ۱ می‌گیرد.

**نام فایل:** `src/main.rs`

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

**لیست ۵-۴:** یک تابع `build_user` که یک ایمیل و نام کاربری می‌گیرد و یک نمونه `User` برمی‌گرداند

نام‌گذاری پارامترهای تابع با همان نام فیلدهای ساختار منطقی است، اما تکرار نام‌های فیلدهای `email` و `username` و متغیرها کمی خسته‌کننده است. اگر ساختار فیلدهای بیشتری داشت، تکرار هر نام حتی آزاردهنده‌تر می‌شد. خوشبختانه، یک میانبر راحت وجود دارد!

### استفاده از میانبر مقداردهی فیلد

چون نام‌های پارامترها و نام‌های فیلدهای ساختار در لیست ۵-۴ دقیقاً یکسان هستند، می‌توانیم از نحو میانبر مقداردهی فیلد (field init shorthand) استفاده کنیم تا `build_user` را بازنویسی کنیم تا همان رفتار را داشته باشد اما تکرار `username` و `email` را حذف کند، همان‌طور که در لیست ۵-۵ نشان داده شده است.

**نام فایل:** `src/main.rs`

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
```

**لیست ۵-۵:** یک تابع `build_user` که از میانبر مقداردهی فیلد استفاده می‌کند زیرا پارامترهای `username` و `email` همان نام فیلدهای ساختار را دارند

در اینجا، ما یک نمونه جدید از ساختار `User` ایجاد می‌کنیم که فیلدی به نام `email` دارد. می‌خواهیم مقدار فیلد `email` را به مقدار پارامتر `email` تابع `build_user` تنظیم کنیم. چون فیلد `email` و پارامتر `email` نام یکسانی دارند، فقط باید `email` را بنویسیم به‌جای `email: email`.

### ایجاد نمونه‌ها از نمونه‌های دیگر با نحو به‌روزرسانی ساختار

اغلب مفید است که یک نمونه جدید از یک ساختار ایجاد کنیم که شامل اکثر مقادیر یک نمونه دیگر باشد، اما برخی را تغییر دهد. می‌توانید این کار را با استفاده از **نحو به‌روزرسانی ساختار (struct update syntax)** انجام دهید.

ابتدا، در لیست ۵-۶ نشان می‌دهیم که چگونه یک نمونه جدید `User` در `user2` به‌طور معمولی، بدون نحو به‌روزرسانی، ایجاد کنیم. ما مقدار جدیدی برای `email` تنظیم می‌کنیم اما در غیر این صورت از همان مقادیر `user1` که در لیست ۵-۲ ایجاد کردیم استفاده می‌کنیم.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

**لیست ۵-۶:** ایجاد یک نمونه جدید `User` با استفاده از همه مقادیر به‌جز یکی از `user1`

با استفاده از نحو به‌روزرسانی ساختار، می‌توانیم همان اثر را با کد کمتری به دست آوریم، همان‌طور که در لیست ۵-۷ نشان داده شده است. نحو `..` مشخص می‌کند که فیلدهای باقی‌مانده‌ای که به‌صراحت تنظیم نشده‌اند باید همان مقدار فیلدهای نمونه داده‌شده را داشته باشند.

**نام فایل:** `src/main.rs`

```rust
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
```

**لیست ۵-۷:** استفاده از نحو به‌روزرسانی ساختار برای تنظیم مقدار جدید `email` برای یک نمونه `User` اما استفاده از بقیه مقادیر از `user1`

کد در لیست ۵-۷ همچنین یک نمونه در `user2` ایجاد می‌کند که مقدار متفاوتی برای `email` دارد اما مقادیر یکسانی برای فیلدهای `username`، `active`، و `sign_in_count` از `user1` دارد. `..user1` باید آخر بیاید تا مشخص کند که هر فیلد باقی‌مانده باید مقادیر خود را از فیلدهای متناظر در `user1` بگیرد، اما می‌توانیم مقادیر را برای هر تعداد فیلدی که می‌خواهیم به هر ترتیبی مشخص کنیم، صرف‌نظر از ترتیب فیلدها در تعریف ساختار.

توجه کنید که نحو به‌روزرسانی ساختار از `=` مانند یک تخصیص استفاده می‌کند؛ این به این دلیل است که داده را منتقل (move) می‌کند، همان‌طور که در بخش «متغیرها و داده‌ها در تعامل با انتقال» دیدیم. در این مثال، نمی‌توانیم پس از ایجاد `user2` از `user1` استفاده کنیم زیرا `String` در فیلد `username` از `user1` به `user2` منتقل شد. اگر به `user2` مقادیر `String` جدید برای هر دو `email` و `username` داده بودیم و بنابراین فقط از مقادیر `active` و `sign_in_count` از `user1` استفاده می‌کردیم، آنگاه `user1` پس از ایجاد `user2` همچنان معتبر می‌بود. هر دو `active` و `sign_in_count` نوع‌هایی هستند که ویژگی‌ `Copy` را پیاده‌سازی می‌کنند، بنابراین رفتاری که در بخش «داده‌های فقط پشته: کپی» بحث کردیم اعمال می‌شود. در این مثال، همچنان می‌توانیم از `user1.email` استفاده کنیم، زیرا مقدار آن منتقل نشده است.

### استفاده از ساختارهای تاپلی بدون فیلدهای نام‌گذاری‌شده برای ایجاد نوع‌های مختلف

Rust همچنین از ساختارهایی پشتیبانی می‌کند که شبیه تاپل‌ها هستند، به نام **ساختارهای تاپلی (tuple structs)**. ساختارهای تاپلی معنای اضافه‌ای که نام ساختار ارائه می‌دهد را دارند اما نام‌هایی برای فیلدهایشان ندارند؛ بلکه فقط نوع‌های فیلدها را دارند. ساختارهای تاپلی زمانی مفید هستند که بخواهید کل تاپل را نام‌گذاری کنید و تاپل را به نوع متفاوتی از سایر تاپل‌ها تبدیل کنید، و زمانی که نام‌گذاری هر فیلد مانند یک ساختار معمولی بیش از حد طولانی یا اضافی باشد.

برای تعریف یک ساختار تاپلی، با کلمه‌کلیدی `struct` و نام ساختار شروع کنید و سپس نوع‌ها را در تاپل مشخص کنید. برای مثال، در اینجا دو ساختار تاپلی به نام‌های `Color` و `Point` تعریف و استفاده می‌کنیم:

**نام فایل:** `src/main.rs`

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

توجه کنید که مقادیر `black` و `origin` نوع‌های متفاوتی هستند زیرا نمونه‌هایی از ساختارهای تاپلی متفاوتی هستند. هر ساختاری که تعریف می‌کنید نوع خودش است، حتی اگر فیلدهای درون ساختار نوع‌های یکسانی داشته باشند. برای مثال، تابعی که پارامتری از نوع `Color` می‌گیرد نمی‌تواند یک `Point` را به‌عنوان آرگومان بپذیرد، حتی اگر هر دو نوع از سه مقدار `i32` تشکیل شده باشند. در غیر این صورت، نمونه‌های ساختار تاپلی شبیه به تاپل‌ها هستند به این معنا که می‌توانید آن‌ها را به قطعات جداگانه تجزیه کنید، و می‌توانید از یک نقطه (`.`) به دنبال ایندکس برای دسترسی به یک مقدار خاص استفاده کنید. برخلاف تاپل‌ها، ساختارهای تاپلی نیازمند آن هستند که هنگام تجزیه، نوع ساختار را نام‌گذاری کنید. برای مثال، باید بنویسیم `let Point(x, y, z) = point`.

### ساختارهای شبه‌واحد بدون هیچ فیلدی

همچنین می‌توانید ساختارهایی تعریف کنید که هیچ فیلدی نداشته باشند! این‌ها به نام **ساختارهای شبه‌واحد (unit-like structs)** شناخته می‌شوند زیرا رفتاری مشابه نوع واحد `()` دارند که در بخش «نوع تاپل» ذکر کردیم. ساختارهای شبه‌واحد زمانی مفید هستند که نیاز دارید یک ویژگی‌ (trait) را روی نوعی پیاده‌سازی کنید اما هیچ داده‌ای ندارید که بخواهید در خود نوع ذخیره کنید. درباره صفات در فصل دهم بحث خواهیم کرد. در اینجا مثالی از اعلان و نمونه‌سازی یک ساختار شبه‌واحد به نام `AlwaysEqual` آورده شده است:

**نام فایل:** `src/main.rs`

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

برای تعریف `AlwaysEqual`، از کلمه‌کلیدی `struct`، نامی که می‌خواهیم، و سپس یک سمی‌کالن استفاده می‌کنیم. نیازی به کروشه یا پرانتز نیست! سپس می‌توانیم یک نمونه از `AlwaysEqual` را در متغیر `subject` به روش مشابهی دریافت کنیم: با استفاده از نامی که تعریف کردیم، بدون هیچ کروشه یا پرانتزی. تصور کنید که بعداً رفتاری برای این نوع پیاده‌سازی خواهیم کرد به‌گونه‌ای که هر نمونه از `AlwaysEqual` همیشه با هر نمونه از هر نوع دیگری برابر باشد، شاید برای داشتن یک نتیجه شناخته‌شده برای اهداف تست. برای پیاده‌سازی آن رفتار نیازی به هیچ داده‌ای نخواهیم داشت! در فصل دهم خواهید دید که چگونه صفات را تعریف کنیم و آن‌ها را روی هر نوع، از جمله ساختارهای شبه‌واحد، پیاده‌سازی کنیم.

### مالکیت داده‌های ساختار

در تعریف ساختار `User` در لیست ۵-۱، از نوع مالکیتی `String` به‌جای نوع برش رشته‌ای `&str` استفاده کردیم. این یک انتخاب عمدی است زیرا می‌خواهیم هر نمونه از این ساختار مالک تمام داده‌های خود باشد و آن داده‌ها تا زمانی که کل ساختار معتبر است، معتبر باشند.

همچنین ممکن است ساختارها ارجاعاتی به داده‌هایی که متعلق به چیز دیگری هستند ذخیره کنند، اما برای این کار نیاز به استفاده از **طول‌عمرها (lifetimes)**، یک ویژگی Rust است که در فصل دهم بحث خواهیم کرد. طول‌عمرها اطمینان می‌دهند که داده‌ای که ساختار به آن ارجاع می‌دهد تا زمانی که ساختار معتبر است، معتبر باشد. فرض کنید سعی کنید ارجاعی را در یک ساختار بدون مشخص کردن طول‌عمرها ذخیره کنید، مانند زیر؛ این کار نخواهد کرد:

**نام فایل:** `src/main.rs`

<div class="err"> <img src="img/does_not_compile.svg" > <span> این کد کامپایل نمی‌شود! </span> </div>

```rust
struct User {
    active: bool,
    username: &str,
    email: &str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}
```

کامپایلر شکایت خواهد کرد که نیاز به مشخص‌کننده‌های طول‌عمر دارد:

```bash
$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --> src/main.rs:3:15
  |
3 |     username: &str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     active: bool,
3 ~     username: &'a str,
  |

error[E0106]: missing lifetime specifier
 --> src/main.rs:4:12
  |
4 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     active: bool,
3 |     username: &str,
4 ~     email: &'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
```

در فصل دهم، درباره نحوه رفع این خطاها برای ذخیره ارجاعات در ساختارها بحث خواهیم کرد، اما فعلاً، خطاهایی مانند این را با استفاده از نوع‌های مالکیتی مانند `String` به‌جای ارجاعات مانند `&str` برطرف خواهیم کرد.
